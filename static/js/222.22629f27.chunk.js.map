{"version":3,"file":"static/js/222.22629f27.chunk.js","mappings":"qJAsCMA,EAAS,IAAIC,eACbC,EAAc,SAAAC,GAClB,IAAMC,EAASJ,EAAOK,kBAAkBF,GAClCG,EAAO,IAAIC,EAAAA,GAAW,IAAIC,WAAWJ,IAErCK,EAAWH,EAAKI,cACtB,GAvCsB,SAAAD,GAAa,IAAD,gBAClC,OAAIA,EAASE,UAAY,MACoB,IAAzCC,OAAOC,KAAKJ,EAASK,SAASC,QAC9B,UAACN,EAASK,QAAQ,UAAlB,iBAAC,EAAqBE,aAAtB,QAAC,EAA4BC,SAC7B,UAACR,EAASK,QAAQ,UAAlB,iBAAC,EAAqBE,aAAtB,QAAC,EAA4BE,MAC7B,UAACT,EAASK,QAAQ,UAAlB,iBAAC,EAAqBE,aAAtB,QAAC,EAA4BC,SAC7B,UAACR,EAASK,QAAQ,UAAlB,iBAAC,EAAqBE,aAAtB,QAAC,EAA4BE,KAiC7BC,CAAgBV,GAAW,OAAO,KACtC,IAAMW,EAAQd,EAAKe,WACnB,OA9BmB,SAAC,GAAkC,IAAhCC,EAA+B,EAA/BA,SAAUC,EAAqB,EAArBA,OAAQC,EAAa,EAAbA,OAExC,IACE,GAAIF,EAASG,SAAU,OAAO,EAC9B,GAAIH,EAASI,QAAU,GAAI,OAAO,EAClC,IAAK,CAAC,EAAG,GAAGC,SAASL,EAASM,UAAW,OAAO,EAEhD,IAAMC,EAAYN,EAAOO,QAAO,SAAAC,GAAC,OAAsB,IAAlBA,EAAEC,aAAqBD,EAAEE,YAAUlB,OAClEmB,EAAYX,EAAOO,QAAO,SAAAC,GAAC,OAAsB,IAAlBA,EAAEC,aAAqBD,EAAEE,YAAUlB,OACxE,GAAIc,GAAa,GAAKK,GAAa,EAAG,OAAO,EAE7C,IAAMC,EAAoBX,EAAO,GAAGY,SAC9BC,EAAoBb,EAAO,GAAGY,SACpC,OAAKD,IAAsBE,EAG3B,MAAOC,GACP,OAAO,GAaLC,CAAanB,GAAe,KAEzB,CACLX,SAAAA,EACAW,MAAAA,IAIJoB,KAAKC,UAAL,yCAAiB,8FAASC,EAAT,EAASA,KAClBvC,EAAOuC,EAAKvC,KACZC,EAASF,EAAYC,GAC3BqC,KAAKG,YAAYvC,GAHF,2CAAjB,uD,2UCtDYwC,EAoCAC,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,GApCAD,EAAAA,QAAZA,GAAYA,EAAAA,EAAAA,KAAAA,EAAAA,GAkCX,KAjCCA,EAAAA,eAAAA,GAAA,iBACAA,EAAAA,EAAAA,YAAAA,GAAAA,cACAA,EAAAA,EAAAA,IAAAA,GAAAA,MACAA,EAAAA,EAAAA,eAAAA,GAAAA,iBACAA,EAAAA,EAAAA,MAAAA,GAAAA,QACAA,EAAAA,EAAAA,OAAAA,GAAAA,SACAA,EAAAA,EAAAA,KAAAA,GAAAA,OACAA,EAAAA,EAAAA,MAAAA,GAAAA,QACAA,EAAAA,EAAAA,MAAAA,GAAAA,QACAA,EAAAA,EAAAA,MAAAA,GAAAA,QACAA,EAAAA,EAAAA,OAAAA,IAAAA,SACAA,EAAAA,EAAAA,KAAAA,IAAAA,OACAA,EAAAA,EAAAA,MAAAA,IAAAA,QACAA,EAAAA,EAAAA,QAAAA,IAAAA,UACAA,EAAAA,EAAAA,aAAAA,IAAAA,eACAA,EAAAA,EAAAA,WAAAA,IAAAA,aACAA,EAAAA,EAAAA,MAAAA,IAAAA,QACAA,EAAAA,EAAAA,MAAAA,IAAAA,QACAA,EAAAA,EAAAA,MAAAA,IAAAA,QACAA,EAAAA,EAAAA,MAAAA,IAAAA,QACAA,EAAAA,EAAAA,MAAAA,IAAAA,QACAA,EAAAA,EAAAA,WAAAA,IAAAA,aACAA,EAAAA,EAAAA,SAAAA,IAAAA,WACAA,EAAAA,EAAAA,IAAAA,IAAAA,MACAA,EAAAA,EAAAA,MAAAA,IAAAA,QACAA,EAAAA,EAAAA,UAAAA,IAAAA,YACAA,EAAAA,EAAAA,YAAAA,IAAAA,cACAA,EAAAA,EAAAA,eAAAA,IAAAA,iBACAA,EAAAA,EAAAA,iBAAAA,IAAAA,mBACAA,EAAAA,EAAAA,YAAAA,IAAAA,cACAA,EAAAA,EAAAA,WAAAA,IAAAA,aACAA,EAAAA,EAAAA,QAAAA,IAAAA,UACAA,EAAAA,EAAAA,KAAAA,IAAAA,OAGUC,EAAAA,QAAZA,GAAYA,EAAAA,EAAAA,KAAAA,EAAAA,GA0DX,KAzDCA,EAAAA,mBAAAA,GAAA,qBACAA,EAAAA,EAAAA,gBAAAA,GAAAA,kBACAA,EAAAA,EAAAA,cAAAA,GAAAA,gBACAA,EAAAA,EAAAA,aAAAA,GAAAA,eACAA,EAAAA,EAAAA,SAAAA,GAAAA,WACAA,EAAAA,EAAAA,SAAAA,GAAAA,WACAA,EAAAA,EAAAA,aAAAA,GAAAA,eACAA,EAAAA,EAAAA,MAAAA,GAAAA,QACAA,EAAAA,EAAAA,UAAAA,IAAAA,YACAA,EAAAA,EAAAA,eAAAA,IAAAA,iBACAA,EAAAA,EAAAA,aAAAA,IAAAA,eACAA,EAAAA,EAAAA,UAAAA,IAAAA,YACAA,EAAAA,EAAAA,cAAAA,IAAAA,gBACAA,EAAAA,EAAAA,gBAAAA,IAAAA,kBACAA,EAAAA,EAAAA,cAAAA,IAAAA,gBACAA,EAAAA,EAAAA,aAAAA,IAAAA,eACAA,EAAAA,EAAAA,SAAAA,IAAAA,WACAA,EAAAA,EAAAA,iBAAAA,IAAAA,mBACAA,EAAAA,EAAAA,mBAAAA,IAAAA,qBACAA,EAAAA,EAAAA,MAAAA,IAAAA,QACAA,EAAAA,EAAAA,YAAAA,IAAAA,cACAA,EAAAA,EAAAA,SAAAA,IAAAA,WACAA,EAAAA,EAAAA,gBAAAA,IAAAA,kBACAA,EAAAA,EAAAA,OAAAA,IAAAA,SACAA,EAAAA,EAAAA,UAAAA,IAAAA,YACAA,EAAAA,EAAAA,UAAAA,IAAAA,YACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,iBAAAA,IAAAA,mBACAA,EAAAA,EAAAA,YAAAA,IAAAA,cACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,2BAAAA,IAAAA,6BACAA,EAAAA,EAAAA,uBAAAA,IAAAA,yBACAA,EAAAA,EAAAA,wBAAAA,IAAAA,0BACAA,EAAAA,EAAAA,qBAAAA,IAAAA,uBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,gBAAAA,IAAAA,kBACAA,EAAAA,EAAAA,yBAAAA,IAAAA,2BACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,mBAAAA,IAAAA,qBACAA,EAAAA,EAAAA,iBAAAA,IAAAA,mBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,mBAAAA,IAAAA,qBACAA,EAAAA,EAAAA,iBAAAA,IAAAA,mBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,oBAAAA,IAAAA,sBACAA,EAAAA,EAAAA,uBAAAA,IAAAA,yBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,2BAAAA,IAAAA,6BACAA,EAAAA,EAAAA,gBAAAA,IAAAA,kBACAA,EAAAA,EAAAA,sBAAAA,IAAAA,wBACAA,EAAAA,EAAAA,iBAAAA,IAAAA,mBC1FF,IASaC,EAAkC,CAC7CC,IAAK,EACLC,KAAM,oBACNC,UAAW,UACXC,OAAQ,CAb4B,YAgBhCC,EAAsC,CAC1C,CACEJ,GAAIH,EAAAA,GAAAA,eACJI,KAAM,iBACNC,UAAW,SACXC,OAAQ,CArB0B,UAqBV,QAAS,MAAO,QAAS,QAAS,SAE5D,CACEH,GAAIH,EAAAA,GAAAA,YACJI,KAAM,cACNC,UAAW,KACXC,OAAQ,CA3B0B,UA2BV,QAAS,MAAO,OAAQ,UAElD,CACEH,GAAIH,EAAAA,GAAAA,IACJI,KAAM,MACNC,UAAW,MACXC,OAAQ,CAjC0B,UAiCV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,EAAAA,GAAAA,eACJI,KAAM,mBACNC,UAAW,MACXC,OAAQ,CAvC0B,UAuCV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CA7C0B,UA6CV,SAAU,OAAQ,MAAO,QAAS,UAE5D,CACEH,GAAIH,EAAAA,GAAAA,OACJI,KAAM,SACNC,UAAW,SACXC,OAAQ,CAnD0B,UAmDV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,EAAAA,GAAAA,KACJI,KAAM,OACNC,UAAW,OACXC,OAAQ,CAzD0B,UAyDV,MAAO,OAAQ,QAAS,UAElD,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CA/D0B,UA+DV,QAAS,OAAQ,QAE3C,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CArE0B,UAqEV,SAAU,QAAS,OAAQ,UAErD,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CA3E0B,UA2EV,MAAO,QAAS,QAAS,UAEnD,CACEH,GAAIH,EAAAA,GAAAA,OACJI,KAAM,SACNC,UAAW,SACXC,OAAQ,CAjF0B,UAiFV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,EAAAA,GAAAA,KACJI,KAAM,OACNC,UAAW,OACXC,OAAQ,CAvF0B,UAuFV,SAAU,OAAQ,UAE5C,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CA7F0B,UA6FV,QAAS,QAAS,OAAQ,UAEpD,CACEH,GAAIH,EAAAA,GAAAA,QACJI,KAAM,UACNC,UAAW,UACXC,OAAQ,CAnG0B,UAmGV,MAAO,YAAa,eAE9C,CACEH,GAAIH,EAAAA,GAAAA,aACJI,KAAM,eACNC,UAAW,MACXC,OAAQ,CAzG0B,UAyGV,QAAS,SAAU,QAE7C,CACEH,GAAIH,EAAAA,GAAAA,WACJI,KAAM,aACNC,UAAW,OACXC,OAAQ,CA/G0B,UA+GV,MAAO,OAAQ,WAAY,UAErD,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CArH0B,UAqHV,OAAQ,QAAS,QAAS,WAEpD,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CA3H0B,UA2HV,MAAO,OAAQ,SAAU,OAAQ,SAE3D,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CAjI0B,UAiIV,MAAO,OAAQ,QAAS,UAElD,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CAvI0B,UAuIV,MAAO,OAAQ,QAAS,UAElD,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CA7I0B,UA6IV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,EAAAA,GAAAA,WACJI,KAAM,aACNC,UAAW,QACXC,OAAQ,CAnJ0B,UAmJV,MAAO,OAAQ,QAAS,UAElD,CACEH,GAAIH,EAAAA,GAAAA,SACJI,KAAM,YACNC,UAAW,MACXC,OAAQ,CAzJ0B,UAyJV,MAAO,OAAQ,QAAS,UAElD,CACEH,GAAIH,EAAAA,GAAAA,IACJI,KAAM,MACNC,UAAW,MACXC,OAAQ,CA/J0B,UA+JV,MAAO,OAAQ,QAAS,WAElD,CACEH,GAAIH,EAAAA,GAAAA,MACJI,KAAM,QACNC,UAAW,QACXC,OAAQ,CArK0B,UAqKV,MAAO,OAAQ,UAEzC,CACEH,GAAIH,EAAAA,GAAAA,UACJI,KAAM,YACNC,UAAW,QACXC,OAAQ,CA3K0B,UA2KV,MAAO,OAAQ,QAAS,YAQ9C,SAAUE,EAAiBC,GAE/B,OADiBF,EAAmBE,IAI7BP,EAAAA,IAAAA,EAAAA,CAAAA,UAAAA,KAAAA,iBAAAA,EAAAA,iBAAAA,WARP,OAAOK,GAAAA,iBAAAA,EAAAA,sBAWH,SAAgCE,GAEpC,OADkBD,EAAiBC,GAClBJ,WAAAA,iBAGb,SAA2BI,GAE/B,OADkBD,EAAiBC,GAClBL,MAAAA,sBAIH,SAAsBK,EAA6BC,GAGjE,OAFkBF,EAAiBC,GACXH,OAAOI,IAxMK,YCGzBC,EAAoB,CAC/BR,IAAK,EACLC,KAAM,eACNC,UAAW,WAGPO,EAAgC,CACpC,EAAG,CAEDT,GAAI,EACJC,KAAM,gBACNC,UAAW,QAEb,EAAG,CACDF,GAAI,EACJC,KAAM,MACNC,UAAW,OAEb,EAAG,CACDF,GAAI,EACJC,KAAM,MACNC,UAAW,OAEb,EAAG,CACDF,GAAI,EACJC,KAAM,MACNC,UAAW,OAEb,EAAG,CACDF,GAAI,EACJC,KAAM,aACNC,UAAW,cAEb,EAAG,CACDF,GAAI,EACJC,KAAM,cACNC,UAAW,QAEb,EAAG,CACDF,GAAI,EACJC,KAAM,eACNC,UAAW,SAEb,EAAG,CACDF,GAAI,EACJC,KAAM,UACNC,UAAW,SAEb,EAAG,CACDF,GAAI,EACJC,KAAM,YACNC,UAAW,SAEb,GAAI,CACFF,GAAI,GACJC,KAAM,gBACNC,UAAW,UAEb,GAAI,CACFF,GAAI,GACJC,KAAM,WACNC,UAAW,UAEb,GAAI,CACFF,GAAI,GACJC,KAAM,aACNC,UAAW,UAEb,GAAI,CACFF,GAAI,GACJC,KAAM,cACNC,UAAW,QAEb,GAAI,CACFF,GAAI,GACJC,KAAM,cACNC,UAAW,QAEb,GAAI,CACFF,GAAI,GACJC,KAAM,WACNC,UAAW,QAEb,GAAI,CACFF,GAAI,GACJC,KAAM,SACNC,UAAW,QAEb,GAAI,CACFF,GAAI,GACJC,KAAM,WACNC,UAAW,QAEb,GAAI,CACFF,GAAI,GACJC,KAAM,YACNC,UAAW,aAEb,GAAI,CACFF,GAAI,GACJC,KAAM,SACNC,UAAW,UAEb,GAAI,CACFF,GAAI,GACJC,KAAM,OACNC,UAAW,QAEb,GAAI,CACFF,GAAI,GACJC,KAAM,SACNC,UAAW,UAEb,GAAI,CACFF,GAAI,GACJC,KAAM,eACNC,UAAW,SAEb,GAAI,CACFF,GAAI,GACJC,KAAM,sBACNC,UAAW,cAEb,GAAI,CACFF,GAAI,GACJC,KAAM,cACNC,UAAW,UAEb,GAAI,CACFF,GAAI,GACJC,KAAM,gBACNC,UAAW,UAEb,GAAI,CACFF,GAAI,GACJC,KAAM,aACNC,UAAW,UAEb,GAAI,CACFF,GAAI,GACJC,KAAM,WACNC,UAAW,UAEb,GAAI,CACFF,GAAI,GACJC,KAAM,aACNC,UAAW,UAEb,GAAI,CACFF,GAAI,GACJC,KAAM,qBACNC,UAAW,aAEb,GAAI,CACFF,GAAI,GACJC,KAAM,cACNC,UAAW,SAIT,SAAUQ,EAAYC,GAE1B,OADUF,EAAME,IAEPH,EAAAA,IAAAA,EAAAA,CAAAA,UAAAA,KAAAA,YAAAA,EAAAA,YAAAA,EAAAA,iBAKL,SAA2BG,GAE/B,OADaD,EAAYC,GACbT,WAAAA,YAGR,SAAsBS,GAE1B,OADaD,EAAYC,GACbV,OC9KDW,EAA0B,CACrCZ,IAAK,EACLC,KAAM,iBAGFY,GAAAA,EAAAA,EAAAA,GACHf,EAAAA,GAAAA,mBAA2B,CAC1BE,GAAIF,EAAAA,GAAAA,mBACJG,KAAM,uBAHJY,EAAAA,EAKHf,EAAAA,GAAAA,gBAAwB,CACvBE,GAAIF,EAAAA,GAAAA,gBACJG,KAAM,uBAPJY,EAAAA,EASHf,EAAAA,GAAAA,cAAsB,CACrBE,GAAIF,EAAAA,GAAAA,cACJG,KAAM,4BAXJY,EAAAA,EAaHf,EAAAA,GAAAA,aAAqB,CACpBE,GAAIF,EAAAA,GAAAA,aACJG,KAAM,iBAfJY,EAAAA,EAiBHf,EAAAA,GAAAA,SAAiB,CAChBE,GAAIF,EAAAA,GAAAA,SACJG,KAAM,aAnBJY,EAAAA,EAqBHf,EAAAA,GAAAA,SAAiB,CAChBE,GAAIF,EAAAA,GAAAA,SACJG,KAAM,aAvBJY,EAAAA,EAyBHf,EAAAA,GAAAA,aAAqB,CACpBE,GAAIF,EAAAA,GAAAA,aACJG,KAAM,kBA3BJY,EAAAA,EA6BHf,EAAAA,GAAAA,MAAc,CACbE,GAAIF,EAAAA,GAAAA,MACJG,KAAM,UA/BJY,EAAAA,EAiCHf,EAAAA,GAAAA,UAAkB,CACjBE,GAAIF,EAAAA,GAAAA,UACJG,KAAM,cAnCJY,EAAAA,EAqCHf,EAAAA,GAAAA,eAAuB,CACtBE,GAAIF,EAAAA,GAAAA,eACJG,KAAM,mBAvCJY,EAAAA,EAyCHf,EAAAA,GAAAA,aAAqB,CACpBE,GAAIF,EAAAA,GAAAA,aACJG,KAAM,iBA3CJY,EAAAA,EA6CHf,EAAAA,GAAAA,UAAkB,CACjBE,GAAIF,EAAAA,GAAAA,UACJG,KAAM,cA/CJY,EAAAA,EAiDHf,EAAAA,GAAAA,cAAsB,CACrBE,GAAIF,EAAAA,GAAAA,cACJG,KAAM,kBAnDJY,EAAAA,EAqDHf,EAAAA,GAAAA,gBAAwB,CACvBE,GAAIF,EAAAA,GAAAA,gBACJG,KAAM,oBAvDJY,EAAAA,EAyDHf,EAAAA,GAAAA,cAAsB,CACrBE,GAAIF,EAAAA,GAAAA,cACJG,KAAM,mBA3DJY,EAAAA,EA6DHf,EAAAA,GAAAA,aAAqB,CACpBE,GAAIF,EAAAA,GAAAA,aACJG,KAAM,iBA/DJY,EAAAA,EAiEHf,EAAAA,GAAAA,SAAiB,CAChBE,GAAIF,EAAAA,GAAAA,SACJG,KAAM,aAnEJY,EAAAA,EAqEHf,EAAAA,GAAAA,iBAAyB,CACxBE,GAAIF,EAAAA,GAAAA,iBACJG,KAAM,uBAvEJY,EAAAA,EAyEHf,EAAAA,GAAAA,mBAA2B,CAC1BE,GAAIF,EAAAA,GAAAA,mBACJG,KAAM,wBA3EJY,EAAAA,EA6EHf,EAAAA,GAAAA,MAAc,CACbE,GAAIF,EAAAA,GAAAA,MACJG,KAAM,UA/EJY,EAAAA,EAiFHf,EAAAA,GAAAA,YAAoB,CACnBE,GAAIF,EAAAA,GAAAA,YACJG,KAAM,mBAnFJY,EAAAA,EAqFHf,EAAAA,GAAAA,SAAiB,CAChBE,GAAIF,EAAAA,GAAAA,SACJG,KAAM,aAvFJY,EAAAA,EAyFHf,EAAAA,GAAAA,gBAAwB,CACvBE,GAAIF,EAAAA,GAAAA,gBACJG,KAAM,oBA3FJY,EAAAA,EA6FHf,EAAAA,GAAAA,OAAe,CACdE,GAAIF,EAAAA,GAAAA,OACJG,KAAM,WA/FJY,EAAAA,EAiGHf,EAAAA,GAAAA,UAAkB,CACjBE,GAAIF,EAAAA,GAAAA,UACJG,KAAM,cAnGJY,EAAAA,EAqGHf,EAAAA,GAAAA,UAAkB,CACjBE,GAAIF,EAAAA,GAAAA,UACJG,KAAM,mBAvGJY,EAAAA,EAyGHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,uBA3GJY,EAAAA,EA6GHf,EAAAA,GAAAA,iBAAyB,CACxBE,GAAIF,EAAAA,GAAAA,iBACJG,KAAM,qBA/GJY,EAAAA,EAiHHf,EAAAA,GAAAA,YAAoB,CACnBE,GAAIF,EAAAA,GAAAA,YACJG,KAAM,gBAnHJY,EAAAA,EAqHHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,sBAvHJY,EAAAA,EAyHHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBA3HJY,EAAAA,EA6HHf,EAAAA,GAAAA,2BAAmC,CAClCE,GAAIF,EAAAA,GAAAA,2BACJG,KAAM,iCA/HJY,EAAAA,EAiIHf,EAAAA,GAAAA,uBAA+B,CAC9BE,GAAIF,EAAAA,GAAAA,uBACJG,KAAM,6BAnIJY,EAAAA,EAqIHf,EAAAA,GAAAA,wBAAgC,CAC/BE,GAAIF,EAAAA,GAAAA,wBACJG,KAAM,8BAvIJY,EAAAA,EAyIHf,EAAAA,GAAAA,qBAA6B,CAC5BE,GAAIF,EAAAA,GAAAA,qBACJG,KAAM,4BA3IJY,EAAAA,EA6IHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBA/IJY,EAAAA,EAiJHf,EAAAA,GAAAA,gBAAwB,CACvBE,GAAIF,EAAAA,GAAAA,gBACJG,KAAM,sBAnJJY,EAAAA,EAqJHf,EAAAA,GAAAA,yBAAiC,CAChCE,GAAIF,EAAAA,GAAAA,yBACJG,KAAM,+BAvJJY,EAAAA,EAyJHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBA3JJY,EAAAA,EA6JHf,EAAAA,GAAAA,mBAA2B,CAC1BE,GAAIF,EAAAA,GAAAA,mBACJG,KAAM,yBA/JJY,EAAAA,EAiKHf,EAAAA,GAAAA,iBAAyB,CACxBE,GAAIF,EAAAA,GAAAA,iBACJG,KAAM,uBAnKJY,EAAAA,EAqKHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBAvKJY,EAAAA,EAyKHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBA3KJY,EAAAA,EA6KHf,EAAAA,GAAAA,mBAA2B,CAC1BE,GAAIF,EAAAA,GAAAA,mBACJG,KAAM,yBA/KJY,EAAAA,EAiLHf,EAAAA,GAAAA,iBAAyB,CACxBE,GAAIF,EAAAA,GAAAA,iBACJG,KAAM,uBAnLJY,EAAAA,EAqLHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBAvLJY,EAAAA,EAyLHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBA3LJY,EAAAA,EA6LHf,EAAAA,GAAAA,oBAA4B,CAC3BE,GAAIF,EAAAA,GAAAA,oBACJG,KAAM,0BA/LJY,EAAAA,EAiMHf,EAAAA,GAAAA,uBAA+B,CAC9BE,GAAIF,EAAAA,GAAAA,uBACJG,KAAM,6BAnMJY,EAAAA,EAqMHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBAvMJY,EAAAA,EAyMHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBA3MJY,EAAAA,EA6MHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBA/MJY,EAAAA,EAiNHf,EAAAA,GAAAA,kBAA0B,CACzBE,GAAIF,EAAAA,GAAAA,kBACJG,KAAM,wBAnNJY,EAAAA,EAqNHf,EAAAA,GAAAA,2BAAmC,CAClCE,GAAIF,EAAAA,GAAAA,2BACJG,KAAM,mCAvNJY,EAAAA,EAyNHf,EAAAA,GAAAA,gBAAwB,CACvBE,GAAIF,EAAAA,GAAAA,gBACJG,KAAM,sBA3NJY,EAAAA,EA6NHf,EAAAA,GAAAA,sBAA8B,CAC7BE,GAAIF,EAAAA,GAAAA,sBACJG,KAAM,4BA/NJY,EAAAA,EAiOHf,EAAAA,GAAAA,iBAAyB,CACxBE,GAAIF,EAAAA,GAAAA,iBACJG,KAAM,qBAnOJY,GAuOA,SAAUC,EAAanC,GAE3B,OADUkC,EAAOlC,IAERiC,EAAAA,IC9HCG,EAAAA,EAAAA,CAAAA,UAAAA,KAAAA,aAAAA,EAAAA,aAAAA,EAAAA,aDmIN,SAAuBpC,GAE3B,OADcmC,EAAanC,GACdsB,OCrIHc,EAAAA,QAAZA,GAAYA,EAAAA,EAAAA,KAAAA,EAAAA,GAiEX,KA/DCA,EAAAA,aAAAA,IAAA,eACAA,EAAAA,EAAAA,WAAAA,IAAAA,aACAA,EAAAA,EAAAA,cAAAA,KAAAA,gBACAA,EAAAA,EAAAA,YAAAA,KAAAA,cACAA,EAAAA,EAAAA,YAAAA,KAAAA,cACAA,EAAAA,EAAAA,UAAAA,KAAAA,YACAA,EAAAA,EAAAA,uBAAAA,IAAAA,yBACAA,EAAAA,EAAAA,qBAAAA,IAAAA,uBACAA,EAAAA,EAAAA,YAAAA,IAAAA,cACAA,EAAAA,EAAAA,UAAAA,IAAAA,YACAA,EAAAA,EAAAA,WAAAA,KAAAA,aACAA,EAAAA,EAAAA,SAAAA,KAAAA,WACAA,EAAAA,EAAAA,WAAAA,KAAAA,aACAA,EAAAA,EAAAA,SAAAA,KAAAA,WACAA,EAAAA,EAAAA,YAAAA,GAAAA,cACAA,EAAAA,EAAAA,UAAAA,IAAAA,YACAA,EAAAA,EAAAA,sBAAAA,IAAAA,wBACAA,EAAAA,EAAAA,oBAAAA,IAAAA,sBACAA,EAAAA,EAAAA,oBAAAA,IAAAA,sBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,oBAAAA,IAAAA,sBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBAGAA,EAAAA,EAAAA,aAAAA,KAAAA,eACAA,EAAAA,EAAAA,cAAAA,KAAAA,gBACAA,EAAAA,EAAAA,WAAAA,KAAAA,aACAA,EAAAA,EAAAA,UAAAA,KAAAA,YACAA,EAAAA,EAAAA,YAAAA,IAAAA,cACAA,EAAAA,EAAAA,YAAAA,IAAAA,cACAA,EAAAA,EAAAA,iBAAAA,IAAAA,mBACAA,EAAAA,EAAAA,SAAAA,KAAAA,WACAA,EAAAA,EAAAA,aAAAA,KAAAA,eACAA,EAAAA,EAAAA,eAAAA,KAAAA,iBACAA,EAAAA,EAAAA,aAAAA,KAAAA,eACAA,EAAAA,EAAAA,aAAAA,KAAAA,eACAA,EAAAA,EAAAA,cAAAA,KAAAA,gBACAA,EAAAA,EAAAA,UAAAA,KAAAA,YACAA,EAAAA,EAAAA,iBAAAA,KAAAA,mBACAA,EAAAA,EAAAA,KAAAA,IAAAA,OACAA,EAAAA,EAAAA,KAAAA,IAAAA,OACAA,EAAAA,EAAAA,qBAAAA,IAAAA,uBACAA,EAAAA,EAAAA,aAAAA,IAAAA,eACAA,EAAAA,EAAAA,cAAAA,IAAAA,gBACAA,EAAAA,EAAAA,aAAAA,IAAAA,eACAA,EAAAA,EAAAA,cAAAA,IAAAA,gBACAA,EAAAA,EAAAA,KAAAA,KAAAA,OACAA,EAAAA,EAAAA,UAAAA,KAAAA,YACAA,EAAAA,EAAAA,OAAAA,KAAAA,SACAA,EAAAA,EAAAA,YAAAA,KAAAA,cACAA,EAAAA,EAAAA,SAAAA,KAAAA,WACAA,EAAAA,EAAAA,cAAAA,KAAAA,gBACAA,EAAAA,EAAAA,WAAAA,KAAAA,aACAA,EAAAA,EAAAA,WAAAA,KAAAA,aACAA,EAAAA,EAAAA,YAAAA,IAAAA,cAGAA,EAAAA,EAAAA,YAAAA,KAAAA,cACAA,EAAAA,EAAAA,0BAAAA,KAAAA,4BACAA,EAAAA,EAAAA,wBAAAA,KAAAA,0BAEAA,EAAAA,EAAAA,0BAAAA,KAAAA,4BACAA,EAAAA,EAAAA,wBAAAA,KAAAA,0BAGK,IAAMC,EAAS,CACpBC,oBAAqB,GACrBC,sBAAuB,GACvBC,0BAA2B,IAGvB,SAAUC,EAAyC7C,GACvD,OAAKA,GAAwC,IAA5BA,EAASR,QAAQC,OAK3B,CACL,CACEiB,YAAaV,EAASR,QAAQ,GAAIkB,YAClCoC,cAAe9C,EAASR,QAAQ,GAAIkB,aAEtC,CACEA,YAAaV,EAASR,QAAQ,GAAIkB,YAClCoC,cAAe9C,EAASR,QAAQ,GAAIkB,cAV/B,GAeK,WAAaqC,EAA4BC,GACvD,SAAKD,IAAUC,IAIRA,EAAUC,gBAAmBF,EAAME,gBAAmB,EAGzD,SAAUC,EAAYC,GAC1B,IAAMC,EAASD,GAASX,EAAAA,GAAAA,wBAAgCW,GAASX,EAAAA,GAAAA,qBAC3Da,EAAQF,GAASX,EAAAA,GAAAA,aAAqBW,GAASX,EAAAA,GAAAA,UAC/Cc,EAAeH,EAAQX,EAAAA,GAAAA,qBAA6BW,GAASX,EAAAA,GAAAA,kBAC7De,EAASJ,IAAUX,EAAAA,GAAAA,KAEzB,OAAOY,GAAUC,GAASC,GAAgBC,EAGtC,SAAUC,EAAUL,GACxB,OAAOA,GAASX,EAAAA,GAAAA,YAAoBW,GAASX,EAAAA,GAAAA,SAGzC,SAAUiB,EAAON,GACrB,OAAOA,GAASX,EAAAA,GAAAA,YAAoBW,GAASX,EAAAA,GAAAA,SAGzC,SAAUkB,EAAUP,GACxB,OAAQA,GAASX,EAAAA,GAAAA,cAAsBW,GAASX,EAAAA,GAAAA,YAAqBW,IAAUX,EAAAA,GAAAA,YAG3E,SAAUmB,EAAUR,GACxB,OAAOA,GAASX,EAAAA,GAAAA,eAAuBW,GAASX,EAAAA,GAAAA,YAI5C,SAAUoB,EAAiBT,GAC/B,OACIA,GAASX,EAAAA,GAAAA,2BAAmCW,GAASX,EAAAA,GAAAA,yBACpDW,GAASX,EAAAA,GAAAA,2BAAmCW,GAASX,EAAAA,GAAAA,0BACxDW,IAAUX,EAAAA,GAAAA,YAIR,SAAUqB,EAAOV,GACrB,OAAOA,GAASX,EAAAA,GAAAA,aAAqBW,GAASX,EAAAA,GAAAA,UAGhC,WAAgBO,EAA4BC,GAA8B,QAIxF,cAHgBD,EAAAA,EAAMe,SAAAA,EAAW,WACbd,EAAAA,EAAUc,SAAAA,EAAW,GC3P3C,ICWYC,ECnBAC,EAwBAC,EA+IAC,ECjKPC,EHECC,GAAsB,CAAC5B,EAAAA,GAAAA,KAAYA,EAAAA,GAAAA,KAAYA,EAAAA,GAAAA,MAOxC6B,GAAAA,WAAeC,SAAAA,IAAAA,EAAAA,KAAAA,GAAAC,KAClBC,mBAAqB,IAAIC,MADPF,KAElBpB,MAAQ,IAAIuB,I,+BAEbC,SAAM3E,GAAAA,IAAAA,EAAAA,KACXuE,KAAKpB,MAAQ,IAAIuB,IACjBH,KAAKC,mBAAqB3B,EAAyC7C,GACnEuE,KAAKC,mBAAmBI,SAASC,SAAAA,GAwC/BN,EAAKpB,MAAM2B,IAAID,EAJwB,CACrCE,aApCqC,CACrCrE,YAAamE,EAAQnE,YACrBsE,cAAe,EACfC,cAAe,EACfC,cAAe,EACfC,eAAgB,EAChBC,eAAgB,EAChBC,eAAgB,EAChBC,UAAW,EACXC,aAAc,CACZC,QAAS,EACTC,KAAM,GAERC,UAAW,CACTF,QAAS,EACTC,KAAM,GAERE,WAAY,CACVC,GAAI,EACJC,QAAS,EACTC,KAAM,EACNC,KAAM,GAERC,gBAAiB,CAEfC,KAAM,EACNC,GAAI,EACJC,QAAS,EACTV,KAAM,GAERW,cAAe,CACbZ,QAAS,EACTC,KAAM,IAKRY,WAAY,U,0BAMXC,SAAavD,GAAAA,IAAAA,EAAAA,KAClBwB,KAAKC,mBAAmBI,SAASC,SAAAA,GAC/B,IAAM1B,EAAQoB,EAAKpB,MAAMoD,IAAI1B,GACzB1B,GAsEV,SAA6BA,EAA0B0B,EAA4B9B,GACjF,IAAMyD,EAAczD,EAAMvD,QAAQqF,EAAQnE,aAAc+F,KAClDC,EAAgB3D,EAAMvD,QAAQqF,EAAQ/B,eAAgB2D,KACtDE,EAAiB,SAACC,EAAeC,GACrC,GAAKA,EAAL,CAIA,IAAMC,EAAkBP,EAAAA,IAAIpD,EAAM4B,aAAc6B,EAAO,GACvD9B,EAAGA,IAAC3B,EAAM4B,aAAc6B,EAAOE,EAAU,KAIrCC,EAAmBP,EAAYQ,cACrC7D,EAAMkD,WAAWY,KAAKF,GAGtB,IAAMG,EAAc/D,EAAMkD,WAAWc,OAAO,GACtCC,EAAgBF,EAAYA,EAAYzH,OAAS,GACjD4H,EAAeN,IAAqBK,EAI1CT,EAAe,iBADMW,EAAAA,QAAQJ,EAAa9C,KAG1C,IAAMmD,EA5ER,SAAsBR,EAA0BS,GAC9C,IAAMC,EAAqBC,GAAUX,GAC/BY,EAAuBD,GAAUF,GAEvC,OAAOC,IAAuBE,EAJhC,CA4E+BZ,EAAkBK,GAC/CT,EAAe,YAAaY,GAE5B,IAAMK,EA7DR,SAA2Bb,EAAyBS,GAClD,IAAMK,EAAqBC,GAAcf,GACnCgB,EAAuBD,GAAcN,GAE3C,OAAOK,IAAuBE,EAJhC,CA6DyChB,EAAkBK,GACzDT,EAAe,iBAAkBiB,GAEjC,IAAMI,EArDR,SAA0BjB,EAAyBS,GACjD,IAAMK,EAAqBI,GAAalB,GAClCgB,EAAuBE,GAAaT,GAE1C,OAAOK,IAAuBE,EAJhC,CAqDuChB,EAAkBK,GACvDT,EAAe,gBAAiBqB,GAEhC,IAAME,EAzCR,SAA2BnB,EAAyBS,GAClD,IAAMW,EAA2BC,GAAgBrB,GAC3CsB,EAA6BD,GAAgBZ,GAEnD,OAAOW,IAA6BE,EAJtC,CAyCyCtB,EAAkBK,GACzDT,EAAe,iBAAkBuB,GAEjC,IAAMI,EA7ER,SAA6BvB,EAAyBS,GACpD,OAAOA,IAAsBhF,EAAAA,GAAAA,MAAcuE,GAAoBvE,EAAAA,GAAAA,WAAmBuE,EAAmBvE,EAAAA,GAAAA,KADvG,CA6E6CuE,EAAkBK,GAC7DT,EAAe,oBAAqB2B,GACpC,IAlGyBC,EAkGnBC,EA5ER,SAA0BzB,EAAyBS,GACjD,OAAOA,IAAsBhF,EAAAA,GAAAA,OAAeuE,EAAmBvE,EAAAA,GAAAA,WAAmBuE,EAAmBvE,EAAAA,GAAAA,MADvG,CA4EuCuE,EAAkBK,GAQvD,GAPAT,EAAe,iBAAkB6B,GAEjC7B,EAAe,gBAAiBI,IAAqBvE,EAAAA,GAAAA,UAAkB6E,GACvEV,EAAe,qBAAsBI,IAAqBvE,EAAAA,GAAAA,eAAuB6E,GACjFV,EAAe,kBAAmBI,IAAqBvE,EAAAA,GAAAA,YAAoB6E,GAC3EV,EAAe,kBAAmBI,IAAqBvE,EAAAA,GAAAA,YAAoB6E,GAEvEA,EAAc,CAEhBV,EAAe,wBA5GQ4B,EA2GexB,KA1GnBvE,EAAAA,GAAAA,gBAAwB+F,IAAc/F,EAAAA,GAAAA,cA4GzD,IAAIiG,EAAc,EACdC,GAAAA,EAEAlC,EAAYmC,UAAajC,EAAciC,YACzCF,GAAe,GAEbjC,EAAYoC,iBAAmBH,IACjCC,GAAAA,GAGF/B,EAAe,qBAAsBI,IAAqBvE,EAAAA,GAAAA,cAAsBkG,GAChF/B,EAAe,qBAAsBI,IAAqBvE,EAAAA,GAAAA,gBAAwBkG,GAClF/B,EAAe,0BAA2BI,IAAqBvE,EAAAA,GAAAA,cAC/DmE,EAAe,uBAAwBI,IAAqBvE,EAAAA,GAAAA,eAAuBkG,GACnF/B,EAAe,uBAAwBI,IAAqBvE,EAAAA,GAAAA,eAAuBkG,GAEnF/B,EAAe,wBAAyBI,IAAqBvE,EAAAA,GAAAA,WAC7DmE,EAAe,qBAAsBI,IAAqBvE,EAAAA,GAAAA,mBA9HnC+F,SAgDHA,GACtB,OAAOA,GAAa/F,EAAAA,GAAAA,qBAA6B+F,GAAa/F,EAAAA,GAAAA,mBAjDrC+F,CAiINxB,KACjBJ,EAAe,uBAAsD,IAA9BH,EAAYqC,eACnDlC,EAAe,oBAAmD,IAA9BH,EAAYqC,gBAOpD,SAA8BC,EAA0BzC,GACtD,IAGM0C,EAHmBC,EAAAA,KAAK3C,KAGgB7D,EAAAA,GAAAA,qBACxCyG,EAkCR,SAAuCV,GACrC,GAAIA,IAAc/F,EAAAA,GAAAA,UAChB,OAAO,EAGT,IAAM0G,EAAaX,GAAa/F,EAAAA,GAAAA,sBAC1B2G,EAAaZ,GAAa/F,EAAAA,GAAAA,oBAChC,OAAO0G,GAAcC,EAPvB,CArCwB9C,EAAWA,EAAW5G,OAAS,IAMrD,GAF2BsJ,GAAoBE,EAE/C,CAOA,IAAMG,EAAe/C,EAAWc,OAAO,GACjCkC,EAAmBC,EAAKA,MAACF,GAAeb,SAAAA,GAAAA,OAAcA,KAE7B,IAA3BgB,EAAAA,KAAKF,IAA2BA,EAAiB7G,EAAAA,GAAAA,aAMjD6G,EAAiB7G,EAAAA,GAAAA,aAGnBsG,EAAO5D,eAAiB,GAGtBmE,EAAiB7G,EAAAA,GAAAA,kBAEnBsG,EAAO9D,eAAiB,EAGxB8D,EAAO7D,eAAiB,IAnC5B,CAHuB9B,EAAM4B,aAAc5B,EAAMkD,YA5EjD,CArE4BlD,EAAO0B,EAAS9B,Q,mBAKnCyG,WACL,OAAO/E,MAAMgF,KAAKlF,KAAKpB,MAAMuG,UAAUC,KAAKC,SAAAA,GAAAA,OAAQA,EAAI7E,oB,EA7D/CV,GAqEb,SAASqD,GAAUa,GACjB,OAAOA,IAAc/F,EAAAA,GAAAA,eAAuB+F,IAAc/F,EAAAA,GAAAA,aAU5D,SAASsF,GAAcS,GACrB,OAAOA,IAAc/F,EAAAA,GAAAA,WAiBvB,SAASyF,GAAaM,GACpB,OAAOA,IAAc/F,EAAAA,GAAAA,UAUvB,SAAS4F,GAAgBG,GACvB,OAAOA,IAAc/F,EAAAA,GAAAA,aC1GvB,SAAYuB,GACVA,EAAAA,YAAAA,cACAA,EAAAA,aAAAA,eACAA,EAAAA,UAAAA,YAHF,CAAYA,IAAAA,EAIX,K,IAUY8F,GAAAA,SAAAA,G,kBAAkCvF,SAAAA,IAAAwF,IAAAA,EAAAA,EAAAA,KAAAA,GAAAA,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,UAAAA,GAAAA,OAAAC,EAAAA,EAAAA,KAAAA,MAAAA,EAAAA,CAAAA,MAAAA,OAAAA,KACrCvF,mBAAqB,IAAIC,MADYsF,EAErC5G,MAAQ,IAAIuB,IAFyBqF,EAGrCC,OAAS,IAAIvF,MAHwBsF,EAIrC/J,SAAiC,KAJI8J,E,+BAMtCnF,SAAM3E,GAAAA,IAAAA,EAAAA,KAEXuE,KAAKpB,MAAQ,IAAIuB,IACjBH,KAAKyF,OAAS,GACdzF,KAAKC,mBAAqB3B,EAAyC7C,GAEnEuE,KAAKC,mBAAmBI,SAASC,SAAAA,GAQ/BN,EAAKpB,MAAM2B,IAAID,EAPiB,CAC9BoF,MAAO,KACPC,KAAM,KACNC,aAAc,EACdC,iBAAkB,KAClBC,MAAO,Y,0BAMN/D,SAAavD,EAAuBuH,GAAAA,IAAAA,EAAAA,KACzC/F,KAAKC,mBAAmBI,SAASC,SAAAA,GAC/B,IAAM1B,EAAQoB,EAAKpB,MAAMoD,IAAI1B,GACzB1B,IAmBV,SACEoH,EACApH,EACA0B,EACA9B,EACAiH,GAEA,IAAMQ,EAAqBzH,EAAMA,MAC3ByD,EAAczD,EAAMvD,QAAQqF,EAAQnE,aAAc+F,KAClDC,EAAgB3D,EAAMvD,QAAQqF,EAAQ/B,eAAgB2D,KAEtDgE,EAAkBD,EAAqB,EACzCE,EAA8C,KAC9CC,EAAgD,KAEhDJ,EAAOE,KACTC,EAAkBH,EAAOE,GAAkBjL,QAAQqF,EAAQnE,aAAc+F,KACzEkE,EAAoBJ,EAAOE,GAAkBjL,QAAQqF,EAAQ/B,eAAgB2D,MAG/E,IAAMmE,EAAmBlE,EAAcM,cACjC6D,EAAgBnH,EAAUkH,GAC1BE,EAAgBnH,EAAUiH,GAC1BG,EAAuBnH,EAAiBgH,GACxCI,EAAkBL,EAAoBM,EAAgBvE,EAAeiE,GAAqB,EAkBhG,IAV8BnE,EAAYQ,gBAAkB7D,EAAMiH,kBAC5C5D,EAAY0E,oBACRR,EAAkBA,EAAgBQ,mBAAsB,MAGhF/H,EAAMiH,iBAAmB,MAKvBS,GAAiBC,GAAiBC,EAAsB,CAC1D,IACkB,IADdI,GAAAA,EACChI,EAAM8G,QACT9G,EAAM8G,MAAQ,CACZvJ,YAAamE,EAAQ/B,cACrBsI,WAAYZ,EACZ7J,SAAU,KACV0K,aAAcV,GAAiB,OAAGA,EAAAA,EAAkB7G,SAArBwH,EAAoC,EACnEC,eAAgB,OAAA7E,EAAAA,EAAc5C,SAAAA,EAAW,EACzC0H,WAAY,KACZtJ,MAAO,GACPuJ,SAAS,EACTC,UAAW7G,EAAQnE,aAGrBsJ,EAAO/C,KAAK9D,EAAM8G,OAGlBkB,GAAAA,GAGEH,IAG6B,OAA3B7H,EAAMiH,mBACRjH,EAAM+G,KAAO,CACXxJ,YAAamE,EAAQnE,YACrBqC,MAAOyH,EACPpI,OAAQoE,EAAYmF,iBACpBC,SAAU,EACVC,OAAQ,GAGV1I,EAAM8G,MAAM/H,MAAM+E,KAAK9D,EAAM+G,MAGxBiB,IACHhI,EAAMkH,MAAQtG,EAAW+H,eAIzB3I,EAAM+G,OACR/G,EAAM+G,KAAK0B,UAAY,EACvBzI,EAAM+G,KAAK2B,QAAUb,GAKvB7H,EAAMiH,iBAAmBM,EAAkBA,EAAgB1D,cAAgB,MAGzEmE,IACFhI,EAAMkH,MAAQtG,EAAWgI,aAI7B,GAAK5I,EAAM8G,MAAX,CAMA,IAMuB,EANjB+B,EAAgBxI,EAAUoH,GAC1BqB,EAAexI,EAAOmH,GACtBsB,EAAmBvB,GAAqBwB,EAAazF,EAAeiE,GACpEyB,EAAcvI,EAAO+G,GAGtBsB,IACH/I,EAAM8G,MAAMsB,eAAZpI,OAAAA,EAA6BuD,EAAc5C,SAA3C,EAAsD,GAGpD+G,GAAiBC,GAAiBC,GAAwBiB,GAAiBC,GAAgBG,EAE7FjJ,EAAMgH,aAAe,EAErBhH,EAAMgH,cAAgB,EAGxB,IAcqB,EAdjBkC,GAAAA,EAGAH,IACF/I,EAAM8G,MAAMwB,SAAAA,EACZY,GAAAA,GAIElJ,EAAMgH,aAAe1H,EAAOG,4BAC9ByJ,GAAAA,GAIEA,IACFlJ,EAAM8G,MAAMtJ,SAAW6F,EAAYzD,MACnCI,EAAM8G,MAAMuB,WAAab,GAAiD,OAA7BA,EAAAA,EAAkB7G,SAAWwI,EAAI,EAC9EnJ,EAAMkH,MAAQtG,EAAWwI,UAEzBpJ,EAAM8G,MAAQ,KACd9G,EAAM+G,KAAO,OA7IjB,CAlB2BI,EAAWnH,EAAO0B,EAAS9B,EAAOwB,EAAKyF,QAEtC,OAAhB7G,EAAMkH,QACR9F,EAAKiI,KAAKrJ,EAAMkH,MAAO,CACrBJ,MAAOjB,EAAAA,KAAKzE,EAAKyF,QACjBhK,SAAUuE,EAAKvE,WAEjBmD,EAAMkH,MAAQ,Y,mBAMfb,WACL,OAAOjF,KAAKyF,W,EA1CHH,CAAsB4C,EAAAA,cGHtBC,GAAAA,SAAAA,G,kBAOXpI,SAAAA,IAAAA,IAAAA,EAAAA,OAAAA,EAAAA,KAAAA,IACEyF,EAAAA,EAAAA,KAAAA,OAPMvF,mBAAqB,IAAIC,MAMjCF,EALQoI,YAAc,IAAIlI,MAK1BF,EAJQpB,MAAQ,IAAIuB,IAIpBH,EAHQpF,cAAAA,EAGRoF,EAFQvE,SAAiC,KAIvCuE,EAAKpF,SAAW,CACdyN,qBAAsB,IAH1BtI,E,+BAOOK,SAAM3E,GAAAA,IAAAA,EAAAA,KAEXuE,KAAKC,mBAAqB3B,EAAyC7C,GACnEuE,KAAKoI,YAAc,GACnBpI,KAAKpB,MAAQ,IAAIuB,IACjBH,KAAKpF,SAAW,CACdyN,qBAAsB,IAExBrI,KAAKvE,SAAWA,EAEhBuE,KAAKC,mBAAmBI,SAASC,SAAAA,GAO/BN,EAAKpB,MAAM2B,IAAID,EAN4B,CACzCgI,WAAY,KACZ3C,KAAM,KACNC,aAAc,EACdC,iBAAkB,Y,0BAMjB9D,SAAavD,EAAuBuH,GAAAA,IAAAA,EAAAA,KACzC/F,KAAKC,mBAAmBI,SAASC,SAAAA,GAC/B,IAAM1B,EAAQoB,EAAKpB,MAAMoD,IAAI1B,GAC7B,GAAI1B,EAAO,CACT,IAAM2J,EAkDd,SACEvC,EACApH,EACA0B,EACA9B,EACA4J,GAEA,IAAMnC,EAAqBzH,EAAMA,MAC3ByD,EAAmCzD,EAAMvD,QAAQqF,EAAQnE,aAAc+F,KACvEC,EAAgB3D,EAAMvD,QAAQqF,EAAQ/B,eAAgB2D,KAEtDgE,EAAkBD,EAAqB,EACzCE,EAA8C,KAC9CC,EAAgD,KAEhDJ,EAAOE,KACTC,EAAkBH,EAAOE,GAAkBjL,QAAQqF,EAAQnE,aAAc+F,KACzEkE,EAAoBJ,EAAOE,GAAkBjL,QAAQqF,EAAQ/B,eAAgB2D,MAG/E,IAuByB,IAvBnBmE,EAAmBlE,EAAcM,cACjC6D,EAAgBnH,EAAUkH,GAC1BE,EAAgBnH,EAAUiH,GAC1BG,EAAuBnH,EAAiBgH,GACxCI,EAAkBL,EAAoBM,EAAgBvE,EAAeiE,GAAqB,EA8DhG,IAtD8BnE,EAAYQ,gBAAkB7D,EAAMiH,kBAC5C5D,EAAY0E,oBACRR,EAAkBA,EAAgBQ,mBAAsB,MAGhF/H,EAAMiH,iBAAmB,OAKvBS,GAAiBC,GAAiBC,KAC/B5H,EAAM0J,aACT1J,EAAM0J,WAAa,CACjBnM,YAAamE,EAAQ/B,cACrB4I,UAAW7G,EAAQnE,YACnB0K,WAAYZ,EACZ7J,SAAU,KACV0K,aAAcV,GAAiB,OAAGA,EAAAA,EAAkB7G,SAArBwH,EAAoC,EACnEC,eAAgB,OAAA7E,EAAAA,EAAc5C,SAAAA,EAAW,EACzC0H,WAAY,KACZtJ,MAAO,GACPuJ,SAAS,EACTsB,YAAa,WAGfJ,EAAY1F,KAAK9D,EAAM0J,aAGrB7B,IAG6B,OAA3B7H,EAAMiH,mBACRjH,EAAM+G,KAAO,CACXxJ,YAAamE,EAAQnE,YACrBqC,MAAOyH,EACPpI,OAAQoE,EAAYmF,iBACpBC,SAAU,EACVC,OAAQ,GAGV1I,EAAM0J,WAAW3K,MAAM+E,KAAK9D,EAAM+G,OAGhC/G,EAAM+G,OACR/G,EAAM+G,KAAK0B,UAAY,EACvBzI,EAAM+G,KAAK2B,QAAUb,GAKvB7H,EAAMiH,iBAAmBM,EAAkBA,EAAgB1D,cAAgB,QAI1E7D,EAAM0J,WAGT,OAAO,EAGT,IAIuB,EAJjBG,EAAgB9J,EAAY0H,GAC5BsB,EAAmBvB,GAAqBwB,EAAazF,EAAeiE,GAGrEuB,IACH/I,EAAM0J,WAAWtB,eAAjBpI,OAAAA,EAAkCuD,EAAc5C,SAAhD,EAA2D,IAGzD+G,GAAiBC,GAAiBC,KAEpC5H,EAAMgH,aAAe,IAGgC,IAAvBhH,EAAMgH,cAAsB6C,GACzB7J,EAAMgH,aAAe,KAKtDhH,EAAMgH,cAAgB,GAGxB,IAcqB,EAdjBkC,GAAAA,EAsBJ,OAnBIH,IACF/I,EAAM0J,WAAWpB,SAAAA,EACjBY,GAAAA,GAIElJ,EAAMgH,aAAe1H,EAAOC,sBAC9B2J,GAAAA,GAIEA,IACFlJ,EAAM0J,WAAWlM,SAAW6F,EAAYzD,MACxCI,EAAM0J,WAAWrB,WAAab,GAAiD,OAA7BA,EAAAA,EAAkB7G,SAAWwI,EAAI,EAEnFnJ,EAAM0J,WAAa,KACnB1J,EAAM+G,KAAO,MAGRmC,EAxIT,CAlDmD/B,EAAWnH,EAAO0B,EAAS9B,EAAOwB,EAAKoI,aAC9EG,GACFvI,EAAKiI,KAAK,aAAc,CACtBvC,MAAOjB,EAAAA,KAAKzE,EAAKoI,aACjB3M,SAAUuE,EAAKvE,iB,mBAOlBwJ,WAEL,OADAjF,KAAK0I,2BACE1I,KAAKoI,c,sCAGNM,WAAAA,IAAAA,EAAAA,KAEAC,EAAsB1M,EAAMA,OAAC+D,KAAKoI,aAAcE,SAAAA,GAAAA,MAClB,YAA3BA,EAAWE,eAIdI,EAAqBC,EAAAA,QAAQF,EAAqB,cAC9BG,EAAAA,QAAQF,GAAqBR,SAAAA,GAAAA,OAAgBpG,EAAAA,IAAIoG,EAAa,CAAC,EAAG,kBAG1E/H,SAAS+H,SAAAA,GACzB,IAAMW,EAAUX,EAAYlN,QAAU,EACtCkN,EAAY/H,SAASiI,SAAAA,GAInB,GAFAtI,EAAKpF,SAASyN,qBAAqBC,EAAWnM,aAAemM,EAAWlM,SAEpE2M,EAEFT,EAAWE,YAAc,YAF3B,CAOA,IAAMQ,EAAWvE,EAAAA,KAAK6D,EAAW3K,OAC3BsL,EACJjJ,EAAKpF,SAASyN,qBAAqBW,EAAWA,EAAS7M,YAAcmM,EAAWnM,aAElFmM,EAAWE,YADaS,GAAeA,EAAcX,EAAWzB,WACrB,iBAAmB,yB,EAnFzDsB,CAA2BD,EAAAA,cF9B5BzI,EAAAA,QAAZA,GAAYA,EAAAA,EAAAA,KAAAA,EAAAA,GAQX,KAPCA,EAAAA,cAAAA,IAAA,gBACAA,EAAAA,EAAAA,WAAAA,IAAAA,aACAA,EAAAA,EAAAA,iBAAAA,IAAAA,mBACAA,EAAAA,EAAAA,kBAAAA,IAAAA,oBACAA,EAAAA,EAAAA,SAAAA,IAAAA,WACAA,EAAAA,EAAAA,YAAAA,IAAAA,cACAA,EAAAA,EAAAA,cAAAA,IAAAA,gBAiBUC,EAAAA,QAAZA,GAAYA,EAAAA,EAAAA,KAAAA,EAAAA,GAGX,KAFCA,EAAAA,GAAAA,GAAA,KACAA,EAAAA,EAAAA,OAAAA,GAAAA,SA6IUC,EAAAA,QAAZA,GAAYA,EAAAA,EAAAA,KAAAA,EAAAA,GAGX,KAFCA,EAAAA,OAAAA,KAAA,QACAA,EAAAA,EAAAA,gBAAAA,IAAAA,iBCnKF,SAAKC,GACHA,EAAAA,EAAAA,GAAAA,GAAAA,KACAA,EAAAA,EAAAA,GAAAA,GAAAA,KACAA,EAAAA,EAAAA,GAAAA,GAAAA,KACAA,EAAAA,EAAAA,GAAAA,GAAAA,KACAA,EAAAA,EAAAA,GAAAA,GAAAA,KACAA,EAAAA,EAAAA,EAAAA,GAAAA,IACAA,EAAAA,EAAAA,EAAAA,GAAAA,IACAA,EAAAA,EAAAA,EAAAA,GAAAA,IACAA,EAAAA,EAAAA,EAAAA,GAAAA,IATF,CAAKA,IAAAA,EAUJ,K,IAcYsJ,GAAAA,WAAanJ,SAAAA,IAAAA,EAAAA,KAAAA,GAAAC,KAChBpB,MAAQ,IAAIuB,IADIH,KAEhBC,mBAAqB,IAAIC,M,+BAE1BE,SAAM3E,GAAAA,IAAAA,EAAAA,KAEXuE,KAAKpB,MAAQ,IAAIuB,IACjBH,KAAKC,mBAAqB3B,EAAyC7C,GAEnEuE,KAAKC,mBAAmBI,SAASC,SAAAA,GAU/BN,EAAKpB,MAAM2B,IAAID,EATkB,CAC/BnE,YAAamE,EAAQnE,YACrBoC,cAAe+B,EAAQ/B,cACvB4K,WAAY,EACZC,mBAAoB,EACpBC,iBAAkB,EAClBC,iBAAkB,EAClBC,kBAAmB,S,0BAMlBxH,SAAavD,EAAuBuH,GAAAA,IAAAA,EAAAA,KACzC/F,KAAKC,mBAAmBI,SAASC,SAAAA,GAC/B,IAAM1B,EAAQoB,EAAKpB,MAAMoD,IAAI1B,GACzB1B,GAWV,SACEoH,EACApH,EACA0B,EACA9B,GAEA,IAAMyD,EAAczD,EAAMvD,QAAQqF,EAAQnE,aAAcqN,IAClDvD,EAAqBhE,EAAYzD,MACjC0H,EAAkBD,EAAqB,EACvCE,EAAkBH,EAAOE,GAAmBF,EAAOE,GAAkBjL,QAAQqF,EAAQnE,aAAcqN,IAAM,KAE/G,KAAIvD,EAAqBtG,EAAAA,GAAAA,iBAA0BwG,EAAnD,CAOA,IAAMsD,GAA2BtD,EAAgBuD,gBAC3CC,EAAiB1H,EAAYyH,gBAEnC9K,EAAMgL,kBADkC,KAAjBD,GAGvB/K,EAAMrC,WADkBiC,EAAMvD,QAAQqF,EAAQnE,aAAc+F,KAC3B2H,WACjC,IACMC,EAmCR,SAAsBC,GAKpB,IAEIC,EAFAC,EAAOF,EAGX,IAAKC,EAAQ,EAAGC,EAAMD,GAAS,EAC7BC,GAAQA,EAAO,EAEjB,OAAOD,EAXT,CApCwBP,EAA0BE,EAAiB,MAEjE/K,EAAMuK,YAAcW,EACpBlL,EAAM0K,kBAAoBQ,EAI1B,IAAMI,EAAmBC,GAAkBhE,EAAgBiE,UAAYjE,EAAgBkE,WACjFC,EAAsBH,GAAkBlI,EAAYmI,UAAYnI,EAAYoI,WAC9EH,IAAqBI,GAAuBA,IAAwB1K,EAAe2K,KACrF3L,EAAMuK,YAAc,EACpBvK,EAAMwK,oBAAsB,GAI9B,IAAMoB,EAAmBL,GAAkBhE,EAAgBsE,QAAUtE,EAAgBuE,SAC/EC,EAAsBR,GAAkBlI,EAAYwI,QAAUxI,EAAYyI,SAC5EF,IAAqBG,GAAuBA,IAAwB/K,EAAe2K,KACrF3L,EAAMuK,YAAc,EACpBvK,EAAMyK,kBAAoB,GAOxBlD,EAAgByE,iBAAoB,IAAO3I,EAAY2I,kBAAqB,KAC9EhM,EAAMuK,YAAc,EACpBvK,EAAM2K,mBAAqB,GAEzBpD,EAAgB0E,iBAAoB,IAAO5I,EAAY4I,kBAAqB,KAC9EjM,EAAMuK,YAAc,EACpBvK,EAAM2K,mBAAqB,IAxD/B,CAV2BxD,EAAWnH,EAAO0B,EAAS9B,Q,mBAK7CyG,WACL,OAAO/E,MAAMgF,KAAKlF,KAAKpB,MAAMuG,c,EAjCpB+D,GA+Gb,SAASiB,GAAkBJ,EAAWe,GACpC,IAAIC,EAASnL,EAAe2K,GAoB5B,OAlBIR,GAAK,OAAUe,GAAK,MACtBC,EAASnL,EAAeoL,GACfjB,GAAK,OAAUe,IAAM,MAC9BC,EAASnL,EAAeqL,GACflB,IAAM,OAAUe,IAAM,MAC/BC,EAASnL,EAAesL,GACfnB,IAAM,OAAUe,GAAK,MAC9BC,EAASnL,EAAeuL,GACfL,GAAK,MACdC,EAASnL,EAAewL,EACfrB,GAAK,MACdgB,EAASnL,EAAeyL,EACfP,IAAM,MACfC,EAASnL,EAAe0L,EACfvB,IAAM,QACfgB,EAASnL,EAAe2L,GAGnBR,EEtJH,SAAUS,GAAV,GAIJC,IAHAhQ,EAGAgQ,EAJmChQ,SAEnCE,EAEA8P,EAJmC9P,OAGnCyM,EACAqD,EAJmCrD,YAInCqD,EAAAA,EAJmCA,mBAW7BC,EAAiB3G,EAAAA,MAAMpJ,EAAQ,eAC/BgQ,EAAsBvD,EACtBwD,EAAsB/C,EAAAA,QAAQT,GAAcyD,SAAAA,GAAD,oBAAUA,EAAAA,EAAKlO,MAAM,WAAXmO,EAAe3P,eACpE4P,EAA6DC,EAASA,UAACJ,GAAsBxD,SAAAA,GAAAA,OACjGS,EAAAA,QAAQT,EAAa,kBAGjB6D,EAAcR,EAAqB,KAwEzC,OAtEgBhQ,EAASR,QAAQmK,KAAK8G,SAAAA,GACpC,IAAM/P,EAAc+P,EAAO/P,YAErBgQ,EAAenK,EAAGA,IAAC0J,EAAgBvP,IAAgB,GACnDiQ,EAA+B,CACnCC,QAASrK,EAAAA,IAAImK,EAAc,oBAC3BG,SAAUtK,EAAAA,IAAImK,EAAc,qBAC5BI,OAAQvK,EAAAA,IAAImK,EAAc,oBAC1BK,SAAUxK,EAAAA,IAAImK,EAAc,sBAC5BM,MAAOzK,EAAAA,IAAImK,EAAc,eAIvBO,EAAkB,EAClBC,EAA4B,EAE1BC,EAAkBnR,EAASR,QAC9BgB,QAAQ4Q,SAAAA,GAAAA,OAEHA,EAAI1Q,cAAgBA,KAKhBV,EAASqR,SAAWD,EAAIE,SAAWb,EAAOa,WAEnD3H,KAAKyH,SAAAA,GAAAA,OAAQA,EAAI1Q,eAEhB6Q,EAAc,EACdC,EAAY,EAuBhB,OApBAtB,EAEG1P,QAAQqM,SAAAA,GAAAA,OAAeA,EAAWnM,cAAgBA,KAClDkE,SAASiI,SAAAA,GACRoE,IAGIpE,EAAWpB,SAAWoB,EAAWnB,YAAchL,IACjD8Q,GAAa,GAEX3E,EAAW3K,MAAMzC,OAAS,GAAKoN,EAAW3K,MAAM,GAAIxB,cAAgBA,GACtEwQ,IAEFrE,EAAW3K,MAAM0C,SAASsF,SAAAA,GACpBA,EAAKxJ,cAAgBA,IACvB6Q,GAAerH,EAAK2B,cAKrB,CACLnL,YAAaA,EACbiQ,YAAaA,EACbM,gBAAiBA,EACjBM,YAAaA,EACbC,UAAWA,EAEXC,sBAAuBC,GAASR,EAA2BD,GAC3DU,gBAAiBD,GAASf,EAAYK,MAAOR,GAC7CoB,uBAAwBF,GAASf,EAAYC,QAASJ,GACtDqB,gBAAiBH,GAAST,EAAiBO,GAC3CM,iBAAkBJ,GAASH,EAAaN,GACxCc,gBAAiBC,GAAgB1B,EAA8B5P,EAAayQ,EAAiB,eAC7Fc,gBAAiBD,GAAgB1B,EAA8B5P,EAAayQ,EAAiB,kBAC7Fe,qBAAsBC,GAAwB7B,EAA8B5P,EAAayQ,OAO/F,SAASO,GAASnD,EAAeyC,GAC/B,MAAO,CACLzC,MAAOA,EACPyC,MAAOA,EACPoB,MAAOpB,EAAQzC,EAAQyC,EAAQ,MAInC,SAASgB,GACP1B,EACA5P,EACAyQ,EACAkB,GAEA,IAAMC,EAAW/L,EAAAA,IAAI+J,EAA8B,CAAC5P,EAAa2R,KAAU,GAErEE,EAAmBC,EAAOA,QAC9BrB,EAAgBxH,KAAK7G,SAAAA,GAAAA,OAAkByD,EAAAA,IAAI+J,EAA8B,CAACxN,EAAeuP,KAAU,OAGrG,OAAOX,GAASY,EAAS7S,OAAQ6S,EAAS7S,OAAS8S,EAAiB9S,QAGtE,SAAS0S,GACP7B,EACA5P,EACAyQ,GAEA,IAAMsB,EAAelM,EAAAA,IAAI+J,EAA8B,CAAC5P,EAAa,WAAa,GAC5EgS,EAAiBF,EAAOA,QAC5BrB,EAAgBxH,KAAK7G,SAAAA,GAAAA,OAAkByD,EAAAA,IAAI+J,EAA8B,CAACxN,EAAe,WAAa,OAGlG6P,EAAiB,GAmBvB,OAhBqBC,EAAAA,IAAIH,EAAcC,GAC1B9N,SAASiO,SAAAA,GACpB,IAAMC,EAAmBC,EAAAA,MAAMF,GACzBG,EAAqBhK,EAAAA,KAAK6J,GAChC,GAAIC,GAAoBE,EAAoB,CAC1C,IAAMC,EAAeH,EAAiBvH,eAAiBuH,EAAiBzH,aAClE6H,EAAiBF,EAAmBzH,eAAiByH,EAAmB3H,cAE1EyH,EAAkBrH,UAAYuH,EAAoBvH,SAE3CwH,EAAeC,IADxBP,EAAe1L,KAAK6L,OAOnBpB,GAASiB,EAAelT,OAAQgT,EAAahT,QC9ItD,IAAM0T,GAA8B,CAClCC,iBAAiB,GAGNC,GAAAA,WAOX/O,SAAAA,EAAmBgP,GAAAA,EAAAA,KAAAA,GAAqB/O,KANhC+O,aAAAA,EAMgC,KALhCC,mBAAoC,KAKJhP,KAJhCgG,OAAqB,GAIWhG,KAHhC/E,QAAoB,GAGY+E,KAFhCiP,aAAe,IAAI/O,MAGzBF,KAAK+O,QAAUhU,OAAOmU,OAAO,GAAIN,GAAgBG,G,+BAM5C3O,SAAM3E,GAEXuE,KAAKgG,OAAS,GACdhG,KAAK/E,QAAUQ,EAASR,QAAQmK,KAAK+J,SAAAA,GAAAA,OAAMA,EAAEhT,eAG7C6D,KAAKiP,aAAa5O,SAAS+O,SAAAA,GAAAA,OAASA,EAAKhP,MAAM3E,Q,sBAG1C4T,WAAYC,IAAAA,GACjBtP,EAAAA,KAAKiP,cAAavM,KAAlB1C,MAAAA,EAAAA,a,qBAGKuP,WAAAA,IAAAA,EAAAA,KACL,GAA4B,IAAxBvP,KAAK/E,QAAQC,OAKjB,IADA,IAAIsU,EAAgC,OAA5BxP,KAAKgP,mBAA8BhP,KAAKgP,mBAAqB,EAAIrP,EAAAA,GAAAA,MALpE4P,EAAAA,WAOH,IAAM/Q,EAAQwB,EAAKgG,OAAOwJ,GAE1B,IAAKC,GAAiBzP,EAAK/E,QAASuD,GAClC,iBAEFwB,EAAKiP,aAAa5O,SAAS+O,SAAAA,GAAAA,OAASA,EAAKrN,aAAavD,EAAOwB,EAAKgG,WAClEhG,EAAKgP,mBAAqBQ,EAC1BA,KARKxP,KAAKgG,OAAOwJ,IAAI,gD,sBAYlBE,SAASlR,GACdwB,KAAKgG,OAAOxH,EAAMA,OAASA,EAEvBwB,KAAK+O,QAAQF,iBACf7O,KAAKuP,c,EAjDET,GAsDb,SAASW,GAAiBxU,EAAmBuD,GAC3C,IAAKA,EACH,OAAO,EAFkCA,IAAAA,EAAAA,EAAAA,EAStBvD,GATsBuD,IAS3C,IAAK,EAAL,qBAEE,KAFS0N,EAET,YADwBlK,EAAAA,IAAIxD,EAAO,CAAC,UAAW0N,EAAQ,SAErD,OAAO,GAZgC1N,MAAAA,GAAAA,EAAAA,EAAAA,GAAAA,QAAAA,EAAAA,IAgB3C,OAAO,E,ICpFGmR,GCICC,GAAAA,WAAa7P,SAAAA,IAAAA,EAAAA,KAAAA,GAAAC,KAChBpB,MAAQ,IAAIuB,IADIH,KAEhBC,mBAAqB,IAAIC,MAFTF,KAGhBtE,OAAS,IAAIwE,M,+BAEdE,SAAM3E,GAAAA,IAAAA,EAAAA,KAEXuE,KAAKpB,MAAQ,IAAIuB,IACjBH,KAAKC,mBAAqB3B,EAAyC7C,GACnEuE,KAAKtE,OAAS,GAEdsE,KAAKC,mBAAmBI,SAASC,SAAAA,GAI/BN,EAAKpB,MAAM2B,IAAID,EAHiB,CAC9BuP,MAAO,Y,0BAMN9N,SAAavD,EAAuBuH,GAAAA,IAAAA,EAAAA,KACzC/F,KAAKC,mBAAmBI,SAASC,SAAAA,GAC/B,IAAM1B,EAAQoB,EAAKpB,MAAMoD,IAAI1B,GACzB1B,GAWV,SACEoH,EACApH,EACA0B,EACA9B,EACA9C,GAEA,IAAMuG,EAAczD,EAAMvD,QAAQqF,EAAQnE,aAAc+F,KAClD+D,EAAqBhE,EAAYzD,MACjC0H,EAAkBD,EAAqB,EACvCE,EAAkBH,EAAOE,GAAmBF,EAAOE,GAAkBjL,QAAQqF,EAAQnE,aAAc+F,KAAO,KAIhH,GAAKtD,EAAMiR,MAAX,CAkB0E,MAKnE,EALA,GAAI1J,GAAmByB,EAAa3F,EAAakE,GACtDvH,EAAMiR,MAAMzT,SAAW6F,EAAYzD,MACnCI,EAAMiR,MAAM5I,WAAZrI,OAAAA,EAAyBuH,EAAgB5G,SAAzC,EAAoD,EACpDX,EAAMiR,MAAMC,eAAiB7N,EAAYQ,cACzC7D,EAAMiR,MAAQ,UAEdjR,EAAMiR,MAAM7I,eAAZpI,OAAAA,EAA6BqD,EAAY1C,SAAzC,EAAoD,MAxBpC,CAEhB,GADqBD,EAAO2C,EAAYQ,eAEtC,OAGF7D,EAAMiR,MAAQ,CACZ1T,YAAamE,EAAQnE,YACrB0K,WAAYZ,EACZ7J,SAAU,KACV0K,aAAc,EACdG,WAAY,KACZD,eAAgB,EAChBgD,MAAO/H,EAAYvD,gBACnBoR,eAAgB,MAGlBpU,EAAOgH,KAAK9D,EAAMiR,QA/BtB,CAV2B9J,EAAWnH,EAAO0B,EAAS9B,EAAOwB,EAAKtE,a,mBAKzDuJ,WACL,OAAOjF,KAAKtE,W,EA7BHkU,GCPP,SAAUG,GAAYC,GAE1B,IA8BMC,EAAMC,EAAAA,QAAE9K,IAAI4K,GAAMG,SAAAA,GAASC,OA9BZC,EA8BwBF,EAAKG,WAAW,IAzB5C,OAAUD,EAAW,MACjBA,EAAW,MAArB,GAIQ,QAAbA,EACK,GAOQ,OAAbA,EACK,GAIQ,OAAbA,EACK,GAGFA,EA3BYA,IAAAA,KAgCrB,OAAOE,OAAOC,aAAPD,MAAAA,OAAAA,EAAuBN,KF/BhC,SAAYN,GACVA,EAAAA,OAAAA,SACAA,EAAAA,KAAAA,OAFF,CAAYA,KAAAA,GAGX,KA+BM,IGhCKA,GHgCCc,GAAUC,SAAAA,GACrB,GAAQA,EAAMC,SACPhB,GAAeiB,OAClB,MAAO,CACLD,OAAQD,EAAMC,OACdE,OAAQH,EAAMG,QAGhB,MAAM,IAAIC,MAAM,8BAITC,GAAU,SAACC,EAAiB9V,EAAgB+V,GACvD,GAAQD,EAAIL,SACLhB,GAAeiB,OAClB,OAAQI,EAA2BH,OAAOjO,MAAMqO,EAAUA,EAAW/V,GAErE,MAAM,IAAI4V,MAAM,8BAITI,GAAaF,SAAAA,GACxB,GAAQA,EAAIL,SACLhB,GAAeiB,OAClB,OAAQI,EAA2BH,OAAO3V,OAE1C,MAAM,IAAI4V,MAAM,+BG1DtB,SAAYnB,GACVA,EAAAA,OAAAA,SACAA,EAAAA,KAAAA,OAFF,CAAYA,KAAAA,GAGX,KAgJD,IClJYwB,GDkJNC,GAAaC,SAAAA,GAAAA,OACjBC,EAAOA,QAACD,EAAK,CACXE,GAAI,UACJrM,KAAM,OACN4I,KAAM,WAEL0D,MAAM,MACNC,SAEW,YAAaC,EAAkBC,GAC7C,IAAMC,EAAgBD,EAAQd,OAAOjO,MAAM+O,EAAQE,WAAYF,EAAQE,WAAaF,EAAQG,YACtFC,EAAO,IAAIC,SAASJ,GAC1B,OAAQF,GACN,KAAKjS,EAAAA,GAAAA,WAuDH,MAAO,CACLwS,WAAY,GAAZA,OAAeC,GAAUH,EAAM,GAA/BE,KAAAA,OAAuCC,GAAUH,EAAM,GAAvDE,KAAAA,OAA+DC,GAAUH,EAAM,IAC/EjF,QAASqF,GAASJ,EAAM,IACxBK,MAAOD,GAASJ,EAAM,KACtBlW,QAASwW,GAAWN,EAAM,IAC1B9W,QAAS,CAAC,EAAG,EAAG,EAAG,GAAGmK,KA3DCjJ,SAAAA,GAEvB,IAAMmW,EAAyB,EAAdnW,EACXoW,EAAWC,GAAWT,EAAM,IAAQO,GAEtCG,EAAW,OACXF,IAFeC,GAAWT,EAAM,IAAQO,GAG1CG,EAAW,QACW,IAAbF,EACTE,EAAW,MACW,IAAbF,IACTE,EAAW,SAIb,IAEMC,EAAe,IAFC,GACAvW,EAEhBwW,EAAahB,EAAQ/O,MAAM8P,EAAcA,EAHzB,IAIhBE,EAAgBxB,GAAUuB,GAC1BE,EAAUD,EAAgB7C,GAAY6C,GAAiB,GAKvDE,EAAmB,IAFC,GACA3W,EAEpB4W,EAAiBpB,EAAQ/O,MAAMkQ,EAAkBA,EAH7B,IAIpBE,EAAoB5B,GAAU2B,GAC9BE,EAAcD,EAAoBjD,GAAYiD,GAAqB,GAKnEE,EAAmB,IAFC,GACA/W,EAEpBgX,EAAiBxB,EAAQ/O,MAAMsQ,EAAkBA,EAH7B,IAIpBE,EAAoBhC,GAAU+B,GAC9BE,EAAcD,EAAoBrD,GAAYqD,GAAqB,GAEnEE,EAAuB,GAAdnX,EAcf,MAbe,CACbA,YAAaA,EACboX,KAAMpX,EAAc,EACpBqX,YAAatB,GAAUH,EAAM,IAAOuB,GACpC7V,eAAgByU,GAAUH,EAAM,IAAOuB,GACvCG,YAAavB,GAAUH,EAAM,IAAOuB,GACpCxF,KAAMoE,GAAUH,EAAM,IAAOuB,GAC7BvG,OAAQmF,GAAUH,EAAM,IAAOuB,GAC/BI,cAAejB,EACfI,QAASA,EACTI,YAAaA,EACbI,YAAaA,MAUfM,MAAOzB,GAAUH,EAAM,KACvBhW,SAAUmW,GAAUH,EAAM,MAE9B,KAAKtS,EAAAA,GAAAA,iBACH,MAAO,CACLjB,MAAOoV,GAAU7B,EAAM,GACvB5V,YAAa+V,GAAUH,EAAM,GAC7B8B,WAAY1B,GAASJ,EAAM,GAC3B+B,KAAMtB,GAAWT,EAAM,GACvBtP,cAAe4P,GAAWN,EAAM,IAChC3N,UAAW2P,GAAUhC,EAAM,IAC3BiC,UAAWD,GAAUhC,EAAM,IAC3B1N,gBAAiB0P,GAAUhC,EAAM,IACjC3H,UAAW2J,GAAUhC,EAAM,IAC3B1H,UAAW0J,GAAUhC,EAAM,IAC3BtH,QAASsJ,GAAUhC,EAAM,IACzBrH,QAASqJ,GAAUhC,EAAM,IACzBkC,QAASF,GAAUhC,EAAM,IACzB1F,QAASmG,GAAWT,EAAM,IAC1BrI,gBAAiB2I,GAAWN,EAAM,IAClCnH,iBAAkBmJ,GAAUhC,EAAM,IAClClH,iBAAkBkJ,GAAUhC,EAAM,IAClCxS,QAASwU,GAAUhC,EAAM,KAE7B,KAAKtS,EAAAA,GAAAA,kBACH,IAAMyU,EAA2C,CAC/CC,KAAMJ,GAAUhC,EAAM,IACtBjH,EAAGiJ,GAAUhC,EAAM,IACnBqC,QAASL,GAAUhC,EAAM,IACzBsC,QAASN,GAAUhC,EAAM,IACzBuC,QAASP,GAAUhC,EAAM,KAE3B,MAAO,CACLvT,MAAOoV,GAAU7B,EAAM,GACvB5V,YAAa+V,GAAUH,EAAM,GAC7B8B,WAAY1B,GAASJ,EAAM,GAC3BwC,oBAAqBrC,GAAUH,EAAM,GACrCtP,cAAe4P,GAAWN,EAAM,GAChC3N,UAAW2P,GAAUhC,EAAM,IAC3BiC,UAAWD,GAAUhC,EAAM,IAC3B1N,gBAAiB0P,GAAUhC,EAAM,IACjCxS,QAASwU,GAAUhC,EAAM,IACzByC,WAAYT,GAAUhC,EAAM,IAC5B3K,iBAAkB8K,GAAUH,EAAM,IAClC0C,kBAAmBvC,GAAUH,EAAM,IACnC5K,UAAW+K,GAAUH,EAAM,IAC3BrT,gBAAiBwT,GAAUH,EAAM,IACjCpL,mBAAoBoN,GAAUhC,EAAM,IACpC2C,gBAAiBX,GAAUhC,EAAM,IACjClI,WAAYsI,GAASJ,EAAM,IAC3B4C,aAActC,GAAWN,EAAM,IAC/B6C,eAAgB1C,GAAUH,EAAM,IAChCzN,cAAe4N,GAAUH,EAAM,IAC/B8C,sBAAuB3C,GAAUH,EAAM,IACvCmC,kBAAmBA,GAEvB,KAAKzU,EAAAA,GAAAA,YACH,MAAO,CACLjB,MAAOoV,GAAU7B,EAAM,GACvB+C,OAAQzC,GAAWN,EAAM,GACzBnT,MAAOsT,GAAUH,EAAM,GACvB1N,gBAAiB0P,GAAUhC,EAAM,GACjCgD,UAAWhB,GAAUhC,EAAM,IAC3BiD,UAAWjB,GAAUhC,EAAM,IAC3B3N,UAAW2P,GAAUhC,EAAM,IAC3BiC,UAAWD,GAAUhC,EAAM,IAC3BkD,YAAa5C,GAAWN,EAAM,IAC9BmD,gBAAiBnB,GAAUhC,EAAM,IACjCoD,QAAS3C,GAAWT,EAAM,IAC1BqD,YAAalD,GAAUH,EAAM,IAC7BsD,WAAYnD,GAAUH,EAAM,IAC5BuD,mBAAoBpD,GAAUH,EAAM,IACpCwD,YAAarD,GAAUH,EAAM,IAC7ByD,MAAOC,GAAS1D,EAAM,KAE1B,KAAKtS,EAAAA,GAAAA,cACH,MAAO,CACLjB,MAAOoV,GAAU7B,EAAM,GACvB2D,qBAAsB9B,GAAU7B,EAAM,IAE1C,KAAKtS,EAAAA,GAAAA,SACH,MAAO,CACLkW,cAAezD,GAAUH,EAAM,GAC/B6D,mBAAoBH,GAAS1D,EAAM,IAEvC,QACE,OAAO,MAIb,SAAS8D,GAAgB9D,EAAgBuB,EAAgBpY,GAEvD,OAAOoY,EAASpY,GADG6W,EAAKD,WAI1B,SAASiC,GAAUhC,EAAgBuB,GACjC,OAAKuC,GAAgB9D,EAAMuB,EAAQ,GAI5BvB,EAAK+D,WAAWxC,GAHd,KAMX,SAASM,GAAU7B,EAAgBuB,GACjC,OAAKuC,GAAgB9D,EAAMuB,EAAQ,GAI5BvB,EAAKgE,SAASzC,GAHZ,KAMX,SAASmC,GAAS1D,EAAgBuB,GAChC,OAAKuC,GAAgB9D,EAAMuB,EAAQ,GAI5BvB,EAAKiE,QAAQ1C,GAHX,KAMX,SAASd,GAAWT,EAAgBuB,GAClC,OAAKuC,GAAgB9D,EAAMuB,EAAQ,GAI5BvB,EAAKkE,UAAU3C,GAHb,KAMX,SAASjB,GAAWN,EAAgBuB,GAClC,OAAKuC,GAAgB9D,EAAMuB,EAAQ,GAI5BvB,EAAKmE,UAAU5C,GAHb,KAMX,SAASpB,GAAUH,EAAgBuB,GACjC,OAAKuC,GAAgB9D,EAAMuB,EAAQ,GAI5BvB,EAAKoE,SAAS7C,GAHZ,KAMX,SAASnB,GAASJ,EAAgBuB,GAChC,OAAKuC,GAAgB9D,EAAMuB,EAAQ,KAI1BvB,EAAKoE,SAAS7C,GAHd,MC7WX,SAAYnC,GACVA,EAAAA,KAAAA,OACAA,EAAAA,OAAAA,SAFF,CAAYA,KAAAA,GAGX,KAED,IAmBYiF,GAnBNC,GAAkB,CACtBC,gBAAgB,EAChBC,KAAMpF,GAAcqF,OAiBtB,SAAYJ,GACVA,EAAAA,IAAAA,UACAA,EAAAA,QAAAA,cAFF,CAAYA,KAAAA,GAGX,K,ICfWK,GD4BCC,GAAAA,SAAAA,G,kBAYX3W,SAAAA,EAAmB4W,EAAyCC,GAAAA,IAAAA,EAAAA,OAAAA,EAAAA,KAAAA,IAC1DpR,EAAAA,EAAAA,KAAAA,KAAMoR,IAZAC,WAAAA,EAW0E7W,EAV1EvE,cAAAA,EAU0EuE,EAT1E8W,aAAoC,KASsC9W,EAR1E+W,eAA6BC,OAAO9R,KAAK,IAU/ClF,EAAKvE,SAAWV,OAAOmU,OAAO,GAAImH,GAAiBM,GAFOC,E,iCAKrDK,WACLjX,KAAK6W,WAAAA,EACL7W,KAAK8W,aAAe,O,oBAIfI,SAAOC,EAAiBC,EAAkBC,GAC/C,GAAiB,WAAbD,EACF,MAAM,IAAItG,MAAJ,8DAAiEsG,EAAjE,OAIR,IAAMva,EAAOlC,WAAWuK,KAAK8R,OAAOM,OAAO,CAACtX,KAAK+W,eAAgBI,KAGjEnX,KAAK+W,eAAiBC,OAAO9R,KAAK,IAMlC,IAJA,IAAMqS,EAAW,IAAIvF,SAASnV,EAAKgU,QAG/B2G,EAAQ,EACLA,EAAQ3a,EAAK3B,QAElB,GAlFkB,WAkFd8b,OAAO9R,KAAKrI,EAAK+F,MAAM4U,EAAOA,EAAQ,IAAIC,WAA9C,CAMA,IAEuB,EAFjB/F,EAAU6F,EAASpB,SAASqB,GAC9BE,EAAc,EAKlB,GAJI1X,KAAK8W,eACPY,EAAW,SAAG1X,KAAK8W,aAAa9U,IAAI0P,IAAzB,EAAqC,GAE7B7U,EAAK3B,OAASsc,EAChBE,EAAc,EAAG,CAGlC1X,KAAK+W,eAAiBla,EAAK+F,MAAM4U,GACjC,MAIF,GAAIxX,KAAKvE,SAAS8a,OAASpF,GAAcwG,QAAU3X,KAAK6W,UACtD,MAIFW,GAAS,EAET,IAAMI,EAAa/a,EAAK+F,MAAM4U,GACxBK,EAAkB,IAAI7F,SAASnV,EAAKgU,OAAQ2G,GAC9CM,EAAa,EACjB,IACEA,EAAa9X,KAAK+X,gBAAgBrG,EAASkG,EAAYC,GACvD,MAAOG,GAEP,IAAKhY,KAAKvE,SAAS6a,eACjB,MAAM0B,EAERF,EAAa,EAEfN,GAASM,OAtCPN,GAAS,EAyCbH,M,2BAGMY,SAAcvG,EAAkBwG,EAA2BR,GACjE,IAAMS,EAAaD,EAActV,MAAM,EAAG8U,GACpCU,EAAapB,OAAOM,OAAO,CAACN,OAAO9R,KAAK,CAACwM,IAAWyG,IAM1D,OAJAnY,KAAKiI,KAAKmO,GAAeiC,IAAK,CAC5B3G,QAASA,EACTC,QAASyG,IAEJ,IAAIzd,WAAWyd,K,6BAGhBL,SAAgBrG,EAAkBwG,EAA2BX,GAEnE,GAAI7F,IAAYjS,EAAAA,GAAAA,cAAuB,CACrC,IAAMiY,EAAcH,EAASpB,SAAS,GAStC,OAPAnW,KAAK8W,aAAewB,GAAuBf,GAE3CvX,KAAKiY,cAAcvG,EAASwG,EAAeR,GAC3C1X,KAAKiI,KAAKmO,GAAemC,QAAS,CAChC7G,QAASA,EACTC,QAAS3R,KAAK8W,eAETY,EAGT,IACuB,EADnBA,EAAc,EACd1X,KAAK8W,eACPY,EAAW,SAAG1X,KAAK8W,aAAa9U,IAAI0P,IAAzB,EAAqC,GAIlD,IACI8G,EAA0C,KAK9C,OAJId,EAAc,IAEhBc,EAAgBC,GAAa/G,EADnB1R,KAAKiY,cAAcvG,EAASwG,EAAeR,KAGlDc,GAIG9G,IACDjS,EAAAA,GAAAA,UAECO,KAAKvE,SAAS8a,OAASpF,GAAcwG,SACvC3X,KAAK6W,WAAAA,GAKX7W,KAAKiI,KAAKmO,GAAemC,QAAS,CAChC7G,QAASA,EACTC,QAAS6G,IAEJd,GAhBEA,M,EA5HAhB,CAAkBgC,EAAAA,UAgJzBJ,GAA0Bf,SAAAA,GAG9B,IAFA,IAAMT,EAAe,IAAI3W,IACnB2X,EAAaP,EAASpB,SAAS,GAC5B3G,EAAI,EAAGA,EAAIsI,EAAYtI,GAAK,EAAG,CACtC,IAAMmJ,EAAcpB,EAASpB,SAAS3G,GAChCkI,EAAcH,EAASrB,UAAU1G,EAAI,GAC3CsH,EAAavW,IAAIoY,EAAajB,GAEhC,OAAOZ,GEyEH8B,GAAqBC,SAAAA,GACzB,IAAMxH,EAAM2F,OAAO8B,MAAM,GAEzB,OADAzH,EAAI0H,aAAaF,EAAQ,GAClBxH,GAGH2H,GAAsBH,SAAAA,GAC1B,IAAMxH,EAAM2F,OAAO8B,MAAM,GAEzB,OADAzH,EAAI4H,cAAcJ,EAAQ,GACnBxH,GCxRI6H,GAAAA,WAAenZ,SAAAA,IAAAA,EAAAA,KAAAA,GAAAC,KAClBmZ,eAAqC,GADnBnZ,KAElBoZ,mBAAqB,EAFHpZ,KAGlBqZ,kBAAmC,KAHjBrZ,KAIlBsZ,sBAAAA,EAJkBtZ,KAKlBuZ,sBAAwB,EALNvZ,KAMlBwZ,gBAA4B,G,8CAE7BC,SAAqBC,EAA0CC,GACpE,GAA+B,OAA3B3Z,KAAKqZ,kBAEPrZ,KAAKqZ,kBAAoBM,OACpB,GAAI3Z,KAAKqZ,oBAAsBM,EACpC,OAkBF,OAfID,GAEE1Z,KAAKmZ,eAAeO,EAAalb,OACnCwB,KAAKmZ,eAAeO,EAAalb,OAAQkE,KAAKgX,GAE9C1Z,KAAKmZ,eAAeO,EAAalb,OAAS,CAACkb,GAE7C1Z,KAAKoZ,qBACLpZ,KAAKuZ,wBACLvZ,KAAKsZ,sBAAAA,GACItZ,KAAKsZ,uBACdtZ,KAAKwZ,gBAAgB9W,KAAK1C,KAAKuZ,uBAC/BvZ,KAAKuZ,sBAAwB,EAC7BvZ,KAAKsZ,sBAAAA,GAEAtZ,KAAKsZ,uB,uBAGPM,WACL,OAAO5Z,KAAKmZ,iB,sBAGPU,WACL,OAAO7Z,KAAKoZ,qB,wBAGPU,WACL,OAAO9Z,KAAKwZ,oB,EA3CHN,GFkBDzC,EAAAA,QAAZA,GAAYA,GAAAA,EAAAA,KAAAA,EAAAA,GAMX,KALCsD,SAAA,WACAtD,GAAAA,IAAAA,MACAA,GAAAA,MAAAA,QACAA,GAAAA,gBAAAA,kBACAA,GAAAA,eAAAA,iBAOF,IAAMuD,GAA0B,CAC9BC,QAAQ,GAKGC,GAAAA,SAAAA,G,kBAUXna,SAAAA,EAAmBgP,GAAAA,IAAAA,EAAAA,OAAAA,EAAAA,KAAAA,IACjBvJ,EAAAA,EAAAA,KAAAA,OAVMQ,OAAqB,GASyBhG,EAR9Cma,gBAAmC,IAAIjB,GAQOlZ,EAP9CvE,SAAiC,KAOauE,EAN9Coa,QAA8B,KAMgBpa,EAL9Cqa,iBAAkC,KAKYra,EAJ9Csa,kBAAAA,EAI8Cta,EAH9Cua,mBAAqB5a,EAAAA,GAAAA,MAAe,EAGUK,EAF9C+O,aAAAA,EAIN/O,EAAK+O,QAAUhU,OAAOmU,OAAO,GAAI8K,GAAyBjL,GAFzCA,E,uCAKZyL,SAAc9I,EAAkBC,GACrC,OAAQD,GACN,KAAKjS,EAAAA,GAAAA,WACHO,KAAKya,iBAAiB9I,GACtB,MACF,KAAKlS,EAAAA,GAAAA,kBAGHO,KAAK0a,uBAAuB/I,GAC5B3R,KAAK2a,mBAAmBjJ,EAASC,GACjC,MACF,KAAKlS,EAAAA,GAAAA,iBACHO,KAAK2a,mBAAmBjJ,EAASC,GACjC,MACF,KAAKlS,EAAAA,GAAAA,YACHO,KAAK4a,kBAAkBjJ,GACvB,MACF,KAAKlS,EAAAA,GAAAA,cACHO,KAAK6a,oBAAoBlJ,GACzB,MACF,KAAKlS,EAAAA,GAAAA,SACHO,KAAK8a,eAAenJ,M,mBAMnBoJ,WACL/a,KAAKgG,OAAS,GACdhG,KAAKvE,SAAW,KAChBuE,KAAKoa,QAAU,KACfpa,KAAKqa,iBAAmB,KACxBra,KAAKsa,kBAAAA,EACLta,KAAKua,mBAAqB5a,EAAAA,GAAAA,MAAe,I,kCAGpCqb,WAAoB,MACzB,OAAO,OAAP,EAAOhb,KAAKqa,kBAAZ,EAAgC1a,EAAAA,GAAAA,MAAe,I,mCAG1Csb,WACL,OAA8B,OAA1Bjb,KAAKqa,iBACA,EAEFa,KAAKC,IAAI,EAAGnb,KAAKqa,iBAAmB1a,EAAAA,GAAAA,kB,4BAGtCyb,WAKL,IAAMrV,EAAY/F,KAAK4Z,YACjByB,EAAuC,OAA1Brb,KAAKqa,iBAA4Bra,KAAKqa,iBAAmB1a,EAAAA,GAAAA,MAE5E,OAAOuQ,EAACoL,QAACtZ,IAAI+D,EADM/F,KAAKoa,QAAUiB,EAAaA,EAAa,IACrB,O,yBAGlCE,WACL,OAAOvb,KAAKsa,iBAAmBta,KAAKvE,SAAW,O,wBAG1C+f,WACL,OAAOxb,KAAKoa,U,uBAGPR,WACL,OAAO5Z,KAAKgG,S,+BAGPyV,WACL,MAAO,CACLzV,OAAQhG,KAAKma,gBAAgBP,YAC7B5P,MAAOhK,KAAKma,gBAAgBN,WAC5B6B,QAAS1b,KAAKma,gBAAgBL,gB,sBAI3B6B,SAASC,GACd,OAAO5b,KAAKgG,OAAO4V,IAAQ,O,4BAGrBd,SAAenJ,GAES,OAA1B3R,KAAKqa,kBAA6Bra,KAAKqa,mBAAqBra,KAAKua,oBACnEva,KAAK6b,gBAAgB7b,KAAKqa,kBAI5Bra,KAAKoa,QAAUzI,EACf3R,KAAKiI,KAAKwO,EAAAA,GAAAA,IAAoBzW,KAAKoa,W,8BAG7BK,SAAiB9I,GACvB3R,KAAKvE,SAAWkW,EAEhB3R,KAAKvE,SAASR,QADE0W,EAAQ1W,QACQgB,QAAQiQ,SAAAA,GAAAA,OAA2B,IAAhBA,EAAO4B,QAItD6D,EAAQM,YAAc6J,EAAMR,QAACS,IAAIpK,EAAQM,WAAY,UACvDjS,KAAKgc,sB,oCAIDtB,SAAuB/I,GAC7B,IAAI3R,KAAKsa,iBAAT,CAKA,GAAI3I,EAAQnT,OAAUmB,EAAAA,GAAAA,MAAc,CAClC,IAAMxD,EAAcwV,EAAQxV,YACtB8f,EAAiB/L,EAAAA,QAAEnL,MAAM/E,KAAKvE,SAAUR,QAAS,eAEvD,OAAQ0W,EAAQ4C,qBACd,KAAK,EACH0H,EAAe9f,GAAcqX,YAAc,GAC3C,MACF,KAAK,GACHyI,EAAe9f,GAAcqX,YAAc,IAI7C7B,EAAQnT,MAASmB,EAAAA,GAAAA,OACnBK,KAAKgc,uB,gCAIDrB,SAAmBjJ,EAAkBC,GAE3C,IAAMuK,EAAWxK,IAAYjS,EAAAA,GAAAA,iBAA2B,MAAQ,OAC1D4C,EAAQsP,EAAQkC,WAAa,YAAc,UAC3C5N,EAAqB0L,EAAQnT,MAEnC,GADAwB,KAAKqa,iBAAmBpU,EACP,QAAbiW,IAAuBvK,EAAQkC,WAAY,CAC7C,IAAM6F,EAAe1Z,KAAKgG,OAAOC,GACXjG,KAAKma,gBAAgBV,qBAAqBC,EAAc/H,EAAQxV,cAGpF6D,KAAKiI,KAAKwO,EAAAA,GAAAA,eAA+BiD,GAG7CxJ,EAAAA,QAAE3P,IAAIP,KAAKgG,OAAQ,CAACC,EAAoB5D,EAAOsP,EAAQxV,YAAc+f,GAAWvK,GAChFzB,EAAAA,QAAE3P,IAAIP,KAAKgG,OAAQ,CAACC,EAAoB,SAAUA,GAIlD,IAAMxK,EAAWuE,KAAKub,eAClB9f,GAAcA,EAASwW,aAAc6J,EAAAA,QAAOK,IAAI1gB,EAASwW,WAAY,SAKvE/B,EAAAA,QAAE3P,IAAIP,KAAKgG,OAAQ,CAACC,EAAoB,2BAJxCjG,KAAKiI,KAAKwO,EAAAA,GAAAA,MAAsBzW,KAAKgG,OAAOC,IAE5CjG,KAAK6b,gBAAgB5V,EAAqB,M,+BAMtC2U,SAAkBjJ,GAAuB,QACzC1L,EAAqB0L,EAAQnT,MAC7B4d,EAAK,OAAGC,EAAAA,OAAAA,EAAAA,KAAKrW,OAAOC,SAAAA,EAAZ,EAAiCmW,OAApC,EAA6C,GACxDA,EAAM1Z,KAAKiP,GAGXzB,EAAAA,QAAE3P,IAAIP,KAAKgG,OAAQ,CAACC,EAAoB,SAAUmW,K,iCAG5CvB,SAAoBlJ,GAC1B,IAAM+D,EAAuB/D,EAAQ+D,qBAC/BzP,EAAqB0L,EAAQnT,MAOnC,GANA0R,EAAAA,QAAE3P,IAAIP,KAAKgG,OAAQ,CAACC,EAAoB,0BAExCjG,KAAKiI,KAAKwO,EAAAA,GAAAA,MAAsBzW,KAAKgG,OAAOC,IAGnBjG,KAAKvE,SAAUM,WAAa2D,EAAAA,GAAAA,QAC7BgW,GAAwB/V,EAAAA,GAAAA,MAAc,CAE5D,GAAIK,KAAK+O,QAAQkL,QAAUvE,EAAuBzP,EArNrB,EAsN3B,MAAM,IAAI6K,MAAJ,4DAAoF7K,IAE5FjG,KAAK6b,gBAAgBnG,QAGrB1V,KAAK6b,gBAAgB5V,EA3NQ,K,6BAmOzB4V,SAAgBD,GACtB,KAAO5b,KAAKua,mBAAqBqB,GAAK,CACpC,IAAMU,EAAkBtc,KAAKua,mBAAqB,EAC5C/b,EAAQwB,KAAK2b,SAASW,GAG5B,GAAItc,KAAK+O,QAAQkL,OAAjB,WACuBja,KAAKvE,SAAUR,SADtC,IACE,IAAK,EAAL,qBAA6C,KAAlCiR,EAAkC,QACrCqQ,EAAkB/d,EAAMvD,QAAQiR,EAAO/P,aAG7C,KAAI6D,KAAKvE,SAAUR,QAAQC,OAAS,IAAMqhB,EAA1C,CAIA,IAAQ/S,EAAc+S,EAAhB/S,IAAOtH,EAASqa,EAAhBra,KACN,IAAKsH,IAAQtH,EAEX,MAAM,IAAI4O,MAAJ,mCACwBwL,EADxB,eAC8CV,EAD9C,qBADYpS,EAAM,MAAQ,OAC1B,oCACmG0C,EAAO/P,gBAbtH,+BAoBA6D,KAAKiI,KAAKwO,EAAAA,GAAAA,gBAAgCjY,GAC1CwB,KAAKua,mBAAqB+B,K,+BAItBN,WACDhc,KAAKsa,mBACRta,KAAKsa,kBAAAA,EACLta,KAAKiI,KAAKwO,EAAAA,GAAAA,SAAyBzW,KAAKvE,e,EAjPjCye,CAAkBhS,EAAAA,cApBIsU,EAAAA,GAAAA,WGajCzc,SAAAA,EAAmB2Q,EAA0CkG,GAAAA,IAAAA,EAAAA,KAAAA,EAAAA,KAAAA,GAAkB5W,KAZvE0Q,WAAAA,EAYuE,KAXvE9V,SAAgC,KAWuCoF,KAVvEyc,WAA+B,KAUwCzc,KATvE0c,YAAAA,EASuE,KARvEC,aAA8B,KAQyC3c,KAPvE4c,gBAAmC,IAAI9c,GAOgCE,KANvE6c,mBAAyC,IAAI1U,GAM0BnI,KALvE8c,cAA+B,IAAIxX,GAKoCtF,KAJvE+c,cAA+B,IAAInN,GAIoC5P,KAHvEgd,cAA+B,IAAI9T,GAGoClJ,KAFrEid,mBAAAA,EAGRjd,KAAK0Q,MC5BgBA,SAAAA,GACvB,GAAqB,iBAAVA,EACT,MAAO,CACLC,OAAQhB,GAAeuN,KACvBC,SAAUzM,GAEd,GAAIA,aAAiB0M,YACnB,MAAO,CACLzM,OAAQhB,GAAeiB,OACvBC,OAAQ,IAAIlW,WAAW+V,IAE3B,GAAIA,aAAiB/V,WACnB,MAAO,CACLgW,OAAQhB,GAAeiB,OACvBC,OAAQH,GAEZ,MAAM,IAAII,MAAM,oDAhBOJ,CD4BCA,GAGtB1Q,KAAKid,cAAgB,IAAInO,GAAM8H,GAC/B5W,KAAKid,cAAc5N,SACjBrP,KAAK4c,gBACL5c,KAAK8c,cACL9c,KAAK6c,mBACL7c,KAAKgd,cACLhd,KAAK+c,eAEP/c,KAAK0c,OAAS,IAAIxC,GAClBla,KAAK0c,OAAOW,GAAG5G,EAAAA,GAAAA,UAA0Bhb,SAAAA,GACvCuE,EAAKid,cAAc7c,MAAM3E,MAG3BuE,KAAK0c,OAAOW,GAAG5G,EAAAA,GAAAA,iBAAiCjY,SAAAA,GAC9CwB,EAAKid,cAAcvN,SAASlR,MH/BC,kCGmCzB8e,WAAwB,WAAfC,EAAe,wDAC9B,GAAiC,OAA7Bvd,KAAK0c,OAAOlB,aAAhB,CAGA,IAAMgC,ELfJ,SAAsB9M,GAC1B,IAAM+M,EH0BqB/M,SAAAA,GAE3B,GADYD,GAAOC,GACPC,SACLhB,GAAeiB,OAClB,OAAOF,EAAMG,QAAU,IAAIlW,WAE3B,MAAM,IAAImW,MAAM,6BANOJ,CG1BIA,GAEzBgN,EAAuCD,EAalC,KAAO,IAAInN,WAAW,GACxB,EAEF,GAbP,MAAO,CACLmN,UAAWA,EACXE,gBAAiBD,EACjBE,cAaJ,SAA0B/M,EAAoBI,GAC5C,IAAM4M,EAAYhN,EAAO3V,OACzB,GAAiB,IAAb+V,EACF,OAAO4M,EAET,IAAMC,EAAcjN,EAAOjO,MAAMqO,EAAW,EAAGA,GACzC8M,EAAgBD,EAAY,IAAO,GAAOA,EAAY,IAAO,GAAOA,EAAY,IAAO,EAAKA,EAAY,GAC9G,OAAIC,EAAe,EAEVA,EAKFF,EAAY5M,EAdrB,CAlB2CwM,EAAWC,GAMlDM,aA6BJ,SACEnN,EACAI,GAIA,IAAM+M,EAEF,GAEJ,GAAiB,IAAb/M,EAKF,OAJA+M,EAAa,IAAQ,IACrBA,EAAa,IAAQ,EACrBA,EAAa,IAAQ,GACrBA,EAAa,IAAQ,EACdA,EAGT,IAAMC,EAAmBpN,EAAOjO,MAAMqO,EAAUA,EAAW,GAC3D,GAAIgN,EAAiB,KAAOxe,EAAAA,GAAAA,cAC1B,MAAO,GAET,IAAMye,EAAgBD,EAAiB,GACtCD,EAAa,IAAgBE,EAG9B,IADA,IAAMC,EAAuBtN,EAAOjO,MAAMqO,EAAW,EAAGA,EAAWiN,EAAgB,GAC1E1O,EAAI,EAAGA,EAAI0O,EAAgB,EAAG1O,GAAK,EAIzCwO,EAHeG,EAAqB3O,IAGH2O,EAAqB3O,EAAI,IAAO,EAAK2O,EAAqB3O,EAAI,GAGlG,OAAOwO,EAjCT,CAlCwCP,EAAWC,IAL7C,CKe0B1d,KAAK0Q,OACjC1Q,KAAK2c,aL8DH,SACJyB,EACAC,GAQA,IAP0B,IAA1BC,EAA0B,4DAEpBb,EAAYW,EAAQX,UAEtBd,EAA4B,OAAb2B,GAAqBA,EAAW,EAAIA,EAAWF,EAAQT,gBACpEY,EAAgBH,EAAQT,gBAAkBS,EAAQR,cAEjDjB,EAAe4B,GAAe,CACnC,IAAM5F,EAAc8E,EAAUd,GACxB6B,EAAgBJ,EAAQJ,aAAarF,GAA0B,EACrE,QAAI,IAAA6F,EAEF,OAAO7B,EAET,GAAI6B,EAAeD,EAAgB5B,EACjC,OAAOA,EAMT,GADmB0B,EAAc1F,EADVF,GAAaE,EADvB8E,EAAU7a,MAAM+Z,EAAcA,EAAe6B,KAIxD,MAGF7B,GAAgB6B,EAGlB,OAAO7B,EA/BH,CK7DAa,GACA,SAAC9L,EAASC,GAAV,QACOA,IAKL3R,EAAK0c,OAAOlC,cAAc9I,EAASC,GAC5B4L,GAA8C,OAA9Bvd,EAAK0c,OAAOnB,iBAErCvb,KAAK2c,iBHnDwB,yBG2D1BpB,WAGL,OADAvb,KAAKsd,UAAAA,GACEtd,KAAK0c,OAAOnB,gBH9DY,4BGiE1BH,WAEL,OADApb,KAAKsd,WACEtd,KAAK0c,OAAOtB,mBHnEY,wBGsE1BI,WAEL,OADAxb,KAAKsd,WACEtd,KAAK0c,OAAOlB,eHxEY,uBG2E1B5B,WAEL,OADA5Z,KAAKsd,WACEtd,KAAK0c,OAAO9C,cH7EY,+BGgF1B6B,WAEL,OADAzb,KAAKsd,WACEtd,KAAK0c,OAAOjB,sBHlFY,sBGqF1BjgB,WACL,GAAIwE,KAAKyc,WACP,OAAOzc,KAAKyc,WAGdzc,KAAKsd,WAEL,IAAM7hB,EAAWuE,KAAK0c,OAAOnB,cAC7B,GAAiB,OAAb9f,EACF,OAAO,KAITuE,KAAKid,cAAc1N,UACnB,IAAM5T,EAASqE,KAAKgd,cAAc/X,QAC5BvJ,EAASsE,KAAK+c,cAAc9X,QAC5BmD,EAAcpI,KAAK6c,mBAAmB5X,QACtCwG,EAAqBzL,KAAK0c,OAAOzB,wBACjCwD,EAAUjT,GAAqB,CAAE/P,SAAAA,EAAUE,OAAAA,EAAQyM,YAAAA,EAAaqD,mBAAAA,IAEhElQ,EAAQ,CACZT,UAAWkF,KAAK0c,OAAO1B,uBACvBvP,mBAAAA,EACA/P,OAAAA,EACA0M,YAAAA,EACA3C,OAAQzF,KAAK8c,cAAc7X,QAC3ByZ,aAAc1e,KAAK4c,gBAAgB3X,QACnCwZ,QAAAA,EACAE,aAA2C,OAA7B3e,KAAK0c,OAAOlB,aAC1B/f,SAAAA,EACAE,OAAAA,GAWF,OARiC,OAA7BqE,KAAK0c,OAAOlB,eAKdxb,KAAKyc,WAAalhB,GAGbA,IH9HwB,yBGiI1BV,WACL,OAAImF,KAAKpF,WAGToF,KAAKpF,SEpHH,SAAsB8V,GAC1B,IAAMM,EAAMP,GAAOC,GACbiN,EA/BR,SAA4B3M,GAG1B,OAFeD,GAAQC,EAAK,EAAG,GAEpB,KAAO,IAAIV,WAAW,GACxB,EAGF,GAPT,CA+B6CU,GACrC4M,EAtBR,SAA0B5M,EAAiBC,GACzC,IAAM2N,EAAW1N,GAAUF,GAC3B,GAAiB,IAAbC,EACF,OAAO2N,EAGT,IAAM/N,EAASE,GAAQC,EAAK,EAAGC,EAAW,GAEpC4N,EAAchO,EAAO,IAAO,GAAOA,EAAO,IAAO,GAAOA,EAAO,IAAO,EAAKA,EAAO,GACxF,OAAIgO,EAAa,EAERA,EAKFD,EAAW3N,EAhBpB,CAsByCD,EAAK2M,GACtCmB,EAAmBnB,EAAkBC,EAAgB,GACrDmB,EAAiB7N,GAAUF,GAAO8N,EAAmB,EAE3D,GAAIC,GAAkB,EAEpB,OAAO,KAET,IAAMlO,EAASE,GAAQC,EAAK+N,EAAgBD,GAE5C,IAEE,OADiBE,EAAAA,OAAOnO,GAExB,MAAOoO,GACP,OAAO,MAjBL,CFoH0Bjf,KAAK0Q,QAFxB1Q,KAAKpF,WHnIiB,yBGyI1BskB,WAAW,MAChB,OAAIlf,KAAK0Q,MAAMC,SAAWhB,GAAeuN,KAChC,YAGTiC,EAAOnf,KAAK0Q,MAAMyM,UAAAA,EAAY,SH9IC,EAAAX,GCkBN9D,EAAAA,U","sources":["lib/worker.js","../../marahslp/src/melee/types.ts","../../marahslp/src/melee/characters.ts","../../marahslp/src/melee/moves.ts","../../marahslp/src/melee/stages.ts","../../marahslp/src/stats/common.ts","../../marahslp/src/stats/actions.ts","../../marahslp/src/stats/combos.ts","../../marahslp/src/types.ts","../../marahslp/src/stats/inputs.ts","../../marahslp/src/stats/conversions.ts","../../marahslp/src/stats/overall.ts","../../marahslp/src/stats/stats.ts","../../marahslp/src/reading/browserReading.ts","../../marahslp/src/stats/stocks.ts","../../marahslp/src/reading/fullwidth.ts","../../marahslp/src/reading/slpReader.ts","../../marahslp/src/utils/slpStream.ts","../../marahslp/src/utils/slpParser.ts","../../marahslp/src/utils/slpFile.ts","../../marahslp/src/utils/rollbackCounter.ts","../../marahslp/src/SlippiGame.ts","../../marahslp/src/reading/index.ts","../../marahslp/src/reading/metadata.ts"],"sourcesContent":["import { SlippiGame } from \"@slippi/slippi-js\";\n\ndeclare var FileReaderSync: any;\ndeclare var self: any;\n\nconst invalidMetadata = metadata => {\n  if (metadata.lastFrame < 60*40) return true;\n  if (Object.keys(metadata.players).length !== 2) return true;\n  if (!metadata.players[0]?.names?.netplay) return true;\n  if (!metadata.players[0]?.names?.code)    return true;\n  if (!metadata.players[1]?.names?.netplay) return true;\n  if (!metadata.players[1]?.names?.code)    return true;\n  // TODO ICs, filter only 2022?\n  return false;\n};\n\nconst invalidStats = ({ settings, stocks, inputs }) => {\n  // TODO que esté TODA la info que usamos, revisar stats\n  try {\n    if (settings.is_teams) return true;\n    if (settings.stageId > 32) return true;\n    if (![2, 8].includes(settings.gameMode)) return true;\n    // Check if both players had 2+ stocks at the end\n    const p0_deaths = stocks.filter(s => s.playerIndex === 0 && s.endFrame).length;\n    const p1_deaths = stocks.filter(s => s.playerIndex === 1 && s.endFrame).length;\n    if (p0_deaths <= 2 && p1_deaths <= 2) return true;\n\n    const player_0_airborne = inputs[0].airborne;\n    const player_1_airborne = inputs[1].airborne;\n    if (!player_0_airborne && !player_1_airborne) return true;\n\n    return false;\n  } catch (e) {\n    return true;\n  }\n};\n\n\nconst reader = new FileReaderSync();\nconst processGame = file => {\n  const result = reader.readAsArrayBuffer(file);\n  const game = new SlippiGame(new Uint8Array(result));\n\n  const metadata = game.getMetadata();\n  if (invalidMetadata(metadata)) return null;\n  const stats = game.getStats();\n  if (invalidStats(stats)) return null;\n\n  return {\n    metadata,\n    stats,\n  };\n};\n\nself.onmessage = async ({ data }) => {\n  const file = data.file;\n  const result = processGame(file);\n  self.postMessage(result);\n};\n","export enum Character {\n  CAPTAIN_FALCON = 0,\n  DONKEY_KONG = 1,\n  FOX = 2,\n  GAME_AND_WATCH = 3,\n  KIRBY = 4,\n  BOWSER = 5,\n  LINK = 6,\n  LUIGI = 7,\n  MARIO = 8,\n  MARTH = 9,\n  MEWTWO = 10,\n  NESS = 11,\n  PEACH = 12,\n  PIKACHU = 13,\n  ICE_CLIMBERS = 14,\n  JIGGLYPUFF = 15,\n  SAMUS = 16,\n  YOSHI = 17,\n  ZELDA = 18,\n  SHEIK = 19,\n  FALCO = 20,\n  YOUNG_LINK = 21,\n  DR_MARIO = 22,\n  ROY = 23,\n  PICHU = 24,\n  GANONDORF = 25,\n  MASTER_HAND = 26,\n  WIREFRAME_MALE = 27,\n  WIREFRAME_FEMALE = 28,\n  GIGA_BOWSER = 29,\n  CRAZY_HAND = 30,\n  SANDBAG = 31,\n  POPO = 32,\n}\n\nexport enum Stage {\n  FOUNTAIN_OF_DREAMS = 2,\n  POKEMON_STADIUM = 3,\n  PEACHS_CASTLE = 4,\n  KONGO_JUNGLE = 5,\n  BRINSTAR = 6,\n  CORNERIA = 7,\n  YOSHIS_STORY = 8,\n  ONETT = 9,\n  MUTE_CITY = 10,\n  RAINBOW_CRUISE = 11,\n  JUNGLE_JAPES = 12,\n  GREAT_BAY = 13,\n  HYRULE_TEMPLE = 14,\n  BRINSTAR_DEPTHS = 15,\n  YOSHIS_ISLAND = 16,\n  GREEN_GREENS = 17,\n  FOURSIDE = 18,\n  MUSHROOM_KINGDOM = 19,\n  MUSHROOM_KINGDOM_2 = 20,\n  VENOM = 22,\n  POKE_FLOATS = 23,\n  BIG_BLUE = 24,\n  ICICLE_MOUNTAIN = 25,\n  ICETOP = 26,\n  FLAT_ZONE = 27,\n  DREAMLAND = 28,\n  YOSHIS_ISLAND_N64 = 29,\n  KONGO_JUNGLE_N64 = 30,\n  BATTLEFIELD = 31,\n  FINAL_DESTINATION = 32,\n  TARGET_TEST_MARIO = 33,\n  TARGET_TEST_CAPTAIN_FALCON = 34,\n  TARGET_TEST_YOUNG_LINK = 35,\n  TARGET_TEST_DONKEY_KONG = 36,\n  TARGET_TEST_DR_MARIO = 37,\n  TARGET_TEST_FALCO = 38,\n  TARGET_TEST_FOX = 39,\n  TARGET_TEST_ICE_CLIMBERS = 40,\n  TARGET_TEST_KIRBY = 41,\n  TARGET_TEST_BOWSER = 42,\n  TARGET_TEST_LINK = 43,\n  TARGET_TEST_LUIGI = 44,\n  TARGET_TEST_MARTH = 45,\n  TARGET_TEST_MEWTWO = 46,\n  TARGET_TEST_NESS = 47,\n  TARGET_TEST_PEACH = 48,\n  TARGET_TEST_PICHU = 49,\n  TARGET_TEST_PIKACHU = 50,\n  TARGET_TEST_JIGGLYPUFF = 51,\n  TARGET_TEST_SAMUS = 52,\n  TARGET_TEST_SHEIK = 53,\n  TARGET_TEST_YOSHI = 54,\n  TARGET_TEST_ZELDA = 55,\n  TARGET_TEST_GAME_AND_WATCH = 56,\n  TARGET_TEST_ROY = 57,\n  TARGET_TEST_GANONDORF = 58,\n  HOME_RUN_CONTEST = 84,\n}\n","import { Character } from \"./types\";\n\nexport type CharacterColor = string;\nconst DEFAULT_COLOR: CharacterColor = \"Default\";\n\nexport interface CharacterInfo {\n  id: number;\n  name: string;\n  shortName: string;\n  colors: CharacterColor[];\n}\n\nexport const UnknownCharacter: CharacterInfo = {\n  id: -1,\n  name: \"Unknown Character\",\n  shortName: \"Unknown\",\n  colors: [DEFAULT_COLOR],\n};\n\nconst externalCharacters: CharacterInfo[] = [\n  {\n    id: Character.CAPTAIN_FALCON,\n    name: \"Captain Falcon\",\n    shortName: \"Falcon\",\n    colors: [DEFAULT_COLOR, \"Black\", \"Red\", \"White\", \"Green\", \"Blue\"],\n  },\n  {\n    id: Character.DONKEY_KONG,\n    name: \"Donkey Kong\",\n    shortName: \"DK\",\n    colors: [DEFAULT_COLOR, \"Black\", \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.FOX,\n    name: \"Fox\",\n    shortName: \"Fox\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.GAME_AND_WATCH,\n    name: \"Mr. Game & Watch\",\n    shortName: \"G&W\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.KIRBY,\n    name: \"Kirby\",\n    shortName: \"Kirby\",\n    colors: [DEFAULT_COLOR, \"Yellow\", \"Blue\", \"Red\", \"Green\", \"White\"],\n  },\n  {\n    id: Character.BOWSER,\n    name: \"Bowser\",\n    shortName: \"Bowser\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Black\"],\n  },\n  {\n    id: Character.LINK,\n    name: \"Link\",\n    shortName: \"Link\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Black\", \"White\"],\n  },\n  {\n    id: Character.LUIGI,\n    name: \"Luigi\",\n    shortName: \"Luigi\",\n    colors: [DEFAULT_COLOR, \"White\", \"Blue\", \"Red\"],\n  },\n  {\n    id: Character.MARIO,\n    name: \"Mario\",\n    shortName: \"Mario\",\n    colors: [DEFAULT_COLOR, \"Yellow\", \"Black\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.MARTH,\n    name: \"Marth\",\n    shortName: \"Marth\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Green\", \"Black\", \"White\"],\n  },\n  {\n    id: Character.MEWTWO,\n    name: \"Mewtwo\",\n    shortName: \"Mewtwo\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.NESS,\n    name: \"Ness\",\n    shortName: \"Ness\",\n    colors: [DEFAULT_COLOR, \"Yellow\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.PEACH,\n    name: \"Peach\",\n    shortName: \"Peach\",\n    colors: [DEFAULT_COLOR, \"Daisy\", \"White\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.PIKACHU,\n    name: \"Pikachu\",\n    shortName: \"Pikachu\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Party Hat\", \"Cowboy Hat\"],\n  },\n  {\n    id: Character.ICE_CLIMBERS,\n    name: \"Ice Climbers\",\n    shortName: \"ICs\",\n    colors: [DEFAULT_COLOR, \"Green\", \"Orange\", \"Red\"],\n  },\n  {\n    id: Character.JIGGLYPUFF,\n    name: \"Jigglypuff\",\n    shortName: \"Puff\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Headband\", \"Crown\"],\n  },\n  {\n    id: Character.SAMUS,\n    name: \"Samus\",\n    shortName: \"Samus\",\n    colors: [DEFAULT_COLOR, \"Pink\", \"Black\", \"Green\", \"Purple\"],\n  },\n  {\n    id: Character.YOSHI,\n    name: \"Yoshi\",\n    shortName: \"Yoshi\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Yellow\", \"Pink\", \"Cyan\"],\n  },\n  {\n    id: Character.ZELDA,\n    name: \"Zelda\",\n    shortName: \"Zelda\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"White\"],\n  },\n  {\n    id: Character.SHEIK,\n    name: \"Sheik\",\n    shortName: \"Sheik\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"White\"],\n  },\n  {\n    id: Character.FALCO,\n    name: \"Falco\",\n    shortName: \"Falco\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.YOUNG_LINK,\n    name: \"Young Link\",\n    shortName: \"YLink\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"White\", \"Black\"],\n  },\n  {\n    id: Character.DR_MARIO,\n    name: \"Dr. Mario\",\n    shortName: \"Doc\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"Black\"],\n  },\n  {\n    id: Character.ROY,\n    name: \"Roy\",\n    shortName: \"Roy\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"Yellow\"],\n  },\n  {\n    id: Character.PICHU,\n    name: \"Pichu\",\n    shortName: \"Pichu\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.GANONDORF,\n    name: \"Ganondorf\",\n    shortName: \"Ganon\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"Purple\"],\n  },\n];\n\nexport function getAllCharacters(): CharacterInfo[] {\n  return externalCharacters;\n}\n\nexport function getCharacterInfo(externalCharacterId: number): CharacterInfo {\n  const charInfo = externalCharacters[externalCharacterId];\n  if (charInfo) {\n    return charInfo;\n  }\n  return UnknownCharacter;\n}\n\nexport function getCharacterShortName(externalCharacterId: number): string {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.shortName;\n}\n\nexport function getCharacterName(externalCharacterId: number): string {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.name;\n}\n\n// Return a human-readable color from a characterCode.\nexport function getCharacterColorName(externalCharacterId: number, characterColor: number): CharacterColor {\n  const character = getCharacterInfo(externalCharacterId);\n  const color = character.colors[characterColor];\n  if (color) {\n    return color;\n  }\n  return DEFAULT_COLOR;\n}\n","export interface Move {\n  id: number;\n  name: string;\n  shortName: string;\n}\n\nexport const UnknownMove: Move = {\n  id: -1,\n  name: \"Unknown Move\",\n  shortName: \"unknown\",\n};\n\nconst moves: { [id: number]: Move } = {\n  1: {\n    // This includes all thrown items, zair, luigi's taunt, samus bombs, etc\n    id: 1,\n    name: \"Miscellaneous\",\n    shortName: \"misc\",\n  },\n  2: {\n    id: 2,\n    name: \"Jab\",\n    shortName: \"jab\",\n  },\n  3: {\n    id: 3,\n    name: \"Jab\",\n    shortName: \"jab\",\n  },\n  4: {\n    id: 4,\n    name: \"Jab\",\n    shortName: \"jab\",\n  },\n  5: {\n    id: 5,\n    name: \"Rapid Jabs\",\n    shortName: \"rapid-jabs\",\n  },\n  6: {\n    id: 6,\n    name: \"Dash Attack\",\n    shortName: \"dash\",\n  },\n  7: {\n    id: 7,\n    name: \"Forward Tilt\",\n    shortName: \"ftilt\",\n  },\n  8: {\n    id: 8,\n    name: \"Up Tilt\",\n    shortName: \"utilt\",\n  },\n  9: {\n    id: 9,\n    name: \"Down Tilt\",\n    shortName: \"dtilt\",\n  },\n  10: {\n    id: 10,\n    name: \"Forward Smash\",\n    shortName: \"fsmash\",\n  },\n  11: {\n    id: 11,\n    name: \"Up Smash\",\n    shortName: \"usmash\",\n  },\n  12: {\n    id: 12,\n    name: \"Down Smash\",\n    shortName: \"dsmash\",\n  },\n  13: {\n    id: 13,\n    name: \"Neutral Air\",\n    shortName: \"nair\",\n  },\n  14: {\n    id: 14,\n    name: \"Forward Air\",\n    shortName: \"fair\",\n  },\n  15: {\n    id: 15,\n    name: \"Back Air\",\n    shortName: \"bair\",\n  },\n  16: {\n    id: 16,\n    name: \"Up Air\",\n    shortName: \"uair\",\n  },\n  17: {\n    id: 17,\n    name: \"Down Air\",\n    shortName: \"dair\",\n  },\n  18: {\n    id: 18,\n    name: \"Neutral B\",\n    shortName: \"neutral-b\",\n  },\n  19: {\n    id: 19,\n    name: \"Side B\",\n    shortName: \"side-b\",\n  },\n  20: {\n    id: 20,\n    name: \"Up B\",\n    shortName: \"up-b\",\n  },\n  21: {\n    id: 21,\n    name: \"Down B\",\n    shortName: \"down-b\",\n  },\n  50: {\n    id: 50,\n    name: \"Getup Attack\",\n    shortName: \"getup\",\n  },\n  51: {\n    id: 51,\n    name: \"Getup Attack (Slow)\",\n    shortName: \"getup-slow\",\n  },\n  52: {\n    id: 52,\n    name: \"Grab Pummel\",\n    shortName: \"pummel\",\n  },\n  53: {\n    id: 53,\n    name: \"Forward Throw\",\n    shortName: \"fthrow\",\n  },\n  54: {\n    id: 54,\n    name: \"Back Throw\",\n    shortName: \"bthrow\",\n  },\n  55: {\n    id: 55,\n    name: \"Up Throw\",\n    shortName: \"uthrow\",\n  },\n  56: {\n    id: 56,\n    name: \"Down Throw\",\n    shortName: \"dthrow\",\n  },\n  61: {\n    id: 61,\n    name: \"Edge Attack (Slow)\",\n    shortName: \"edge-slow\",\n  },\n  62: {\n    id: 62,\n    name: \"Edge Attack\",\n    shortName: \"edge\",\n  },\n};\n\nexport function getMoveInfo(moveId: number): Move {\n  const m = moves[moveId];\n  if (!m) {\n    return UnknownMove;\n  }\n  return m;\n}\n\nexport function getMoveShortName(moveId: number): string {\n  const move = getMoveInfo(moveId);\n  return move.shortName;\n}\n\nexport function getMoveName(moveId: number): string {\n  const move = getMoveInfo(moveId);\n  return move.name;\n}\n","import { Stage } from \"./types\";\n\nexport interface StageInfo {\n  id: number;\n  name: string;\n}\n\nexport const UnknownStage: StageInfo = {\n  id: -1,\n  name: \"Unknown Stage\",\n};\n\nconst stages: { [id: number]: StageInfo } = {\n  [Stage.FOUNTAIN_OF_DREAMS]: {\n    id: Stage.FOUNTAIN_OF_DREAMS,\n    name: \"Fountain of Dreams\",\n  },\n  [Stage.POKEMON_STADIUM]: {\n    id: Stage.POKEMON_STADIUM,\n    name: \"Pokémon Stadium\",\n  },\n  [Stage.PEACHS_CASTLE]: {\n    id: Stage.PEACHS_CASTLE,\n    name: \"Princess Peach's Castle\",\n  },\n  [Stage.KONGO_JUNGLE]: {\n    id: Stage.KONGO_JUNGLE,\n    name: \"Kongo Jungle\",\n  },\n  [Stage.BRINSTAR]: {\n    id: Stage.BRINSTAR,\n    name: \"Brinstar\",\n  },\n  [Stage.CORNERIA]: {\n    id: Stage.CORNERIA,\n    name: \"Corneria\",\n  },\n  [Stage.YOSHIS_STORY]: {\n    id: Stage.YOSHIS_STORY,\n    name: \"Yoshi's Story\",\n  },\n  [Stage.ONETT]: {\n    id: Stage.ONETT,\n    name: \"Onett\",\n  },\n  [Stage.MUTE_CITY]: {\n    id: Stage.MUTE_CITY,\n    name: \"Mute City\",\n  },\n  [Stage.RAINBOW_CRUISE]: {\n    id: Stage.RAINBOW_CRUISE,\n    name: \"Rainbow Cruise\",\n  },\n  [Stage.JUNGLE_JAPES]: {\n    id: Stage.JUNGLE_JAPES,\n    name: \"Jungle Japes\",\n  },\n  [Stage.GREAT_BAY]: {\n    id: Stage.GREAT_BAY,\n    name: \"Great Bay\",\n  },\n  [Stage.HYRULE_TEMPLE]: {\n    id: Stage.HYRULE_TEMPLE,\n    name: \"Hyrule Temple\",\n  },\n  [Stage.BRINSTAR_DEPTHS]: {\n    id: Stage.BRINSTAR_DEPTHS,\n    name: \"Brinstar Depths\",\n  },\n  [Stage.YOSHIS_ISLAND]: {\n    id: Stage.YOSHIS_ISLAND,\n    name: \"Yoshi's Island\",\n  },\n  [Stage.GREEN_GREENS]: {\n    id: Stage.GREEN_GREENS,\n    name: \"Green Greens\",\n  },\n  [Stage.FOURSIDE]: {\n    id: Stage.FOURSIDE,\n    name: \"Fourside\",\n  },\n  [Stage.MUSHROOM_KINGDOM]: {\n    id: Stage.MUSHROOM_KINGDOM,\n    name: \"Mushroom Kingdom I\",\n  },\n  [Stage.MUSHROOM_KINGDOM_2]: {\n    id: Stage.MUSHROOM_KINGDOM_2,\n    name: \"Mushroom Kingdom II\",\n  },\n  [Stage.VENOM]: {\n    id: Stage.VENOM,\n    name: \"Venom\",\n  },\n  [Stage.POKE_FLOATS]: {\n    id: Stage.POKE_FLOATS,\n    name: \"Poké Floats\",\n  },\n  [Stage.BIG_BLUE]: {\n    id: Stage.BIG_BLUE,\n    name: \"Big Blue\",\n  },\n  [Stage.ICICLE_MOUNTAIN]: {\n    id: Stage.ICICLE_MOUNTAIN,\n    name: \"Icicle Mountain\",\n  },\n  [Stage.ICETOP]: {\n    id: Stage.ICETOP,\n    name: \"Icetop\",\n  },\n  [Stage.FLAT_ZONE]: {\n    id: Stage.FLAT_ZONE,\n    name: \"Flat Zone\",\n  },\n  [Stage.DREAMLAND]: {\n    id: Stage.DREAMLAND,\n    name: \"Dream Land N64\",\n  },\n  [Stage.YOSHIS_ISLAND_N64]: {\n    id: Stage.YOSHIS_ISLAND_N64,\n    name: \"Yoshi's Island N64\",\n  },\n  [Stage.KONGO_JUNGLE_N64]: {\n    id: Stage.KONGO_JUNGLE_N64,\n    name: \"Kongo Jungle N64\",\n  },\n  [Stage.BATTLEFIELD]: {\n    id: Stage.BATTLEFIELD,\n    name: \"Battlefield\",\n  },\n  [Stage.FINAL_DESTINATION]: {\n    id: Stage.FINAL_DESTINATION,\n    name: \"Final Destination\",\n  },\n  [Stage.TARGET_TEST_MARIO]: {\n    id: Stage.TARGET_TEST_MARIO,\n    name: \"Target Test (Mario)\",\n  },\n  [Stage.TARGET_TEST_CAPTAIN_FALCON]: {\n    id: Stage.TARGET_TEST_CAPTAIN_FALCON,\n    name: \"Target Test (Captain Falcon)\",\n  },\n  [Stage.TARGET_TEST_YOUNG_LINK]: {\n    id: Stage.TARGET_TEST_YOUNG_LINK,\n    name: \"Target Test (Young Link)\",\n  },\n  [Stage.TARGET_TEST_DONKEY_KONG]: {\n    id: Stage.TARGET_TEST_DONKEY_KONG,\n    name: \"Target Test (Donkey Kong)\",\n  },\n  [Stage.TARGET_TEST_DR_MARIO]: {\n    id: Stage.TARGET_TEST_DR_MARIO,\n    name: \"Target Test (Dr. Mario)\",\n  },\n  [Stage.TARGET_TEST_FALCO]: {\n    id: Stage.TARGET_TEST_FALCO,\n    name: \"Target Test (Falco)\",\n  },\n  [Stage.TARGET_TEST_FOX]: {\n    id: Stage.TARGET_TEST_FOX,\n    name: \"Target Test (Fox)\",\n  },\n  [Stage.TARGET_TEST_ICE_CLIMBERS]: {\n    id: Stage.TARGET_TEST_ICE_CLIMBERS,\n    name: \"Target Test (Ice Climbers)\",\n  },\n  [Stage.TARGET_TEST_KIRBY]: {\n    id: Stage.TARGET_TEST_KIRBY,\n    name: \"Target Test (Kirby)\",\n  },\n  [Stage.TARGET_TEST_BOWSER]: {\n    id: Stage.TARGET_TEST_BOWSER,\n    name: \"Target Test (Bowser)\",\n  },\n  [Stage.TARGET_TEST_LINK]: {\n    id: Stage.TARGET_TEST_LINK,\n    name: \"Target Test (Link)\",\n  },\n  [Stage.TARGET_TEST_LUIGI]: {\n    id: Stage.TARGET_TEST_LUIGI,\n    name: \"Target Test (Luigi)\",\n  },\n  [Stage.TARGET_TEST_MARTH]: {\n    id: Stage.TARGET_TEST_MARTH,\n    name: \"Target Test (Marth)\",\n  },\n  [Stage.TARGET_TEST_MEWTWO]: {\n    id: Stage.TARGET_TEST_MEWTWO,\n    name: \"Target Test (Mewtwo)\",\n  },\n  [Stage.TARGET_TEST_NESS]: {\n    id: Stage.TARGET_TEST_NESS,\n    name: \"Target Test (Ness)\",\n  },\n  [Stage.TARGET_TEST_PEACH]: {\n    id: Stage.TARGET_TEST_PEACH,\n    name: \"Target Test (Peach)\",\n  },\n  [Stage.TARGET_TEST_PICHU]: {\n    id: Stage.TARGET_TEST_PICHU,\n    name: \"Target Test (Pichu)\",\n  },\n  [Stage.TARGET_TEST_PIKACHU]: {\n    id: Stage.TARGET_TEST_PIKACHU,\n    name: \"Target Test (Pikachu)\",\n  },\n  [Stage.TARGET_TEST_JIGGLYPUFF]: {\n    id: Stage.TARGET_TEST_JIGGLYPUFF,\n    name: \"Target Test (Jigglypuff)\",\n  },\n  [Stage.TARGET_TEST_SAMUS]: {\n    id: Stage.TARGET_TEST_SAMUS,\n    name: \"Target Test (Samus)\",\n  },\n  [Stage.TARGET_TEST_SHEIK]: {\n    id: Stage.TARGET_TEST_SHEIK,\n    name: \"Target Test (Sheik)\",\n  },\n  [Stage.TARGET_TEST_YOSHI]: {\n    id: Stage.TARGET_TEST_YOSHI,\n    name: \"Target Test (Yoshi)\",\n  },\n  [Stage.TARGET_TEST_ZELDA]: {\n    id: Stage.TARGET_TEST_ZELDA,\n    name: \"Target Test (Zelda)\",\n  },\n  [Stage.TARGET_TEST_GAME_AND_WATCH]: {\n    id: Stage.TARGET_TEST_GAME_AND_WATCH,\n    name: \"Target Test (Mr. Game & Watch)\",\n  },\n  [Stage.TARGET_TEST_ROY]: {\n    id: Stage.TARGET_TEST_ROY,\n    name: \"Target Test (Roy)\",\n  },\n  [Stage.TARGET_TEST_GANONDORF]: {\n    id: Stage.TARGET_TEST_GANONDORF,\n    name: \"Target Test (Ganondorf)\",\n  },\n  [Stage.HOME_RUN_CONTEST]: {\n    id: Stage.HOME_RUN_CONTEST,\n    name: \"Home-Run Contest\",\n  },\n};\n\nexport function getStageInfo(stageId: number): StageInfo {\n  const s = stages[stageId];\n  if (!s) {\n    return UnknownStage;\n  }\n  return s;\n}\n\nexport function getStageName(stageId: number): string {\n  const stage = getStageInfo(stageId);\n  return stage.name;\n}\n","import type { GameStartType, PostFrameUpdateType } from \"../types\";\n\nexport interface StatsType {\n  gameComplete: boolean;\n  lastFrame: number;\n  playableFrameCount: number;\n  stocks: StockType[];\n  conversions: ConversionType[];\n  combos: ComboType[];\n  actionCounts: ActionCountsType[];\n  overall: OverallType[];\n}\n\nexport interface RatioType {\n  count: number;\n  total: number;\n  ratio: number | null;\n}\n\nexport interface PlayerIndexedType {\n  playerIndex: number;\n  opponentIndex: number;\n}\n\nexport interface DurationType {\n  startFrame: number;\n  endFrame?: number | null;\n}\n\nexport interface DamageType {\n  startPercent: number;\n  currentPercent: number;\n  endPercent?: number | null;\n}\n\nexport interface StockType extends DurationType, DamageType {\n  playerIndex: number;\n  count: number;\n  deathAnimation?: number | null;\n}\n\nexport interface MoveLandedType {\n  playerIndex: number;\n  frame: number;\n  moveId: number;\n  hitCount: number;\n  damage: number;\n}\n\nexport interface ComboType extends DurationType, DamageType {\n  playerIndex: number;\n  moves: MoveLandedType[];\n  didKill: boolean;\n  lastHitBy: number | null;\n}\n\nexport interface ConversionType extends ComboType {\n  openingType: string;\n}\n\nexport interface ActionCountsType {\n  playerIndex: number;\n  wavedashCount: number;\n  wavelandCount: number;\n  airDodgeCount: number;\n  dashDanceCount: number;\n  spotDodgeCount: number;\n  ledgegrabCount: number;\n  rollCount: number;\n  lCancelCount: {\n    success: number;\n    fail: number;\n  };\n  grabCount: {\n    success: number;\n    fail: number;\n  };\n  throwCount: {\n    up: number;\n    forward: number;\n    back: number;\n    down: number;\n  };\n  groundTechCount: {\n    // tech away/in are in reference to the opponents position and not the stage\n    away: number;\n    in: number;\n    neutral: number;\n    fail: number;\n  };\n  wallTechCount: {\n    success: number;\n    fail: number;\n  };\n}\n\nexport interface InputCountsType {\n  buttons: number;\n  triggers: number;\n  joystick: number;\n  cstick: number;\n  total: number;\n}\n\nexport interface OverallType {\n  playerIndex: number;\n  inputCounts: InputCountsType;\n  conversionCount: number;\n  totalDamage: number;\n  killCount: number;\n  successfulConversions: RatioType;\n  inputsPerMinute: RatioType;\n  digitalInputsPerMinute: RatioType;\n  openingsPerKill: RatioType;\n  damagePerOpening: RatioType;\n  neutralWinRatio: RatioType;\n  counterHitRatio: RatioType;\n  beneficialTradeRatio: RatioType;\n}\n\nexport enum State {\n  // Animation ID ranges\n  DAMAGE_START = 0x4b,\n  DAMAGE_END = 0x5b,\n  CAPTURE_START = 0xdf,\n  CAPTURE_END = 0xe8,\n  GUARD_START = 0xb2,\n  GUARD_END = 0xb6,\n  GROUNDED_CONTROL_START = 0xe,\n  GROUNDED_CONTROL_END = 0x18,\n  SQUAT_START = 0x27,\n  SQUAT_END = 0x29,\n  DOWN_START = 0xb7,\n  DOWN_END = 0xc6,\n  TECH_START = 0xc7,\n  TECH_END = 0xcc,\n  DYING_START = 0x0,\n  DYING_END = 0xa,\n  CONTROLLED_JUMP_START = 0x18,\n  CONTROLLED_JUMP_END = 0x22,\n  GROUND_ATTACK_START = 0x2c,\n  GROUND_ATTACK_END = 0x40,\n  AERIAL_ATTACK_START = 0x41,\n  AERIAL_ATTACK_END = 0x4a,\n\n  // Animation ID specific\n  ROLL_FORWARD = 0xe9,\n  ROLL_BACKWARD = 0xea,\n  SPOT_DODGE = 0xeb,\n  AIR_DODGE = 0xec,\n  ACTION_WAIT = 0xe,\n  ACTION_DASH = 0x14,\n  ACTION_KNEE_BEND = 0x18,\n  GUARD_ON = 0xb2,\n  TECH_MISS_UP = 0xb7,\n  TECH_MISS_DOWN = 0xbf,\n  NEUTRAL_TECH = 0xc7,\n  FORWARD_TECH = 0xc8,\n  BACKWARD_TECH = 0xc9,\n  WALL_TECH = 0xca,\n  MISSED_WALL_TECH = 0xf7,\n  DASH = 0x14,\n  TURN = 0x12,\n  LANDING_FALL_SPECIAL = 0x2b,\n  JUMP_FORWARD = 0x19,\n  JUMP_BACKWARD = 0x1a,\n  FALL_FORWARD = 0x1e,\n  FALL_BACKWARD = 0x1f,\n  GRAB = 0xd4,\n  GRAB_WAIT = 0xd8,\n  PUMMEL = 0xd9,\n  CLIFF_CATCH = 0xfc,\n  THROW_UP = 0xdd,\n  THROW_FORWARD = 0xdb,\n  THROW_DOWN = 0xde,\n  THROW_BACK = 0xdc,\n  DAMAGE_FALL = 0x26,\n\n  // Command Grabs\n  BARREL_WAIT = 0x125,\n  COMMAND_GRAB_RANGE1_START = 0x10a,\n  COMMAND_GRAB_RANGE1_END = 0x130,\n\n  COMMAND_GRAB_RANGE2_START = 0x147,\n  COMMAND_GRAB_RANGE2_END = 0x152,\n}\n\nexport const Timers = {\n  PUNISH_RESET_FRAMES: 45,\n  RECOVERY_RESET_FRAMES: 45,\n  COMBO_STRING_RESET_FRAMES: 45,\n};\n\nexport function getSinglesPlayerPermutationsFromSettings(settings: GameStartType): PlayerIndexedType[] {\n  if (!settings || settings.players.length !== 2) {\n    // Only return opponent indices for singles\n    return [];\n  }\n\n  return [\n    {\n      playerIndex: settings.players[0]!.playerIndex,\n      opponentIndex: settings.players[1]!.playerIndex,\n    },\n    {\n      playerIndex: settings.players[1]!.playerIndex,\n      opponentIndex: settings.players[0]!.playerIndex,\n    },\n  ];\n}\n\nexport function didLoseStock(frame: PostFrameUpdateType, prevFrame: PostFrameUpdateType): boolean {\n  if (!frame || !prevFrame) {\n    return false;\n  }\n\n  return prevFrame.stocksRemaining! - frame.stocksRemaining! > 0;\n}\n\nexport function isInControl(state: number): boolean {\n  const ground = state >= State.GROUNDED_CONTROL_START && state <= State.GROUNDED_CONTROL_END;\n  const squat = state >= State.SQUAT_START && state <= State.SQUAT_END;\n  const groundAttack = state > State.GROUND_ATTACK_START && state <= State.GROUND_ATTACK_END;\n  const isGrab = state === State.GRAB;\n  // TODO: Add grounded b moves?\n  return ground || squat || groundAttack || isGrab;\n}\n\nexport function isTeching(state: number): boolean {\n  return state >= State.TECH_START && state <= State.TECH_END;\n}\n\nexport function isDown(state: number): boolean {\n  return state >= State.DOWN_START && state <= State.DOWN_END;\n}\n\nexport function isDamaged(state: number): boolean {\n  return (state >= State.DAMAGE_START && state <= State.DAMAGE_END) || state === State.DAMAGE_FALL;\n}\n\nexport function isGrabbed(state: number): boolean {\n  return state >= State.CAPTURE_START && state <= State.CAPTURE_END;\n}\n\n// TODO: Find better implementation of 3 seperate ranges\nexport function isCommandGrabbed(state: number): boolean {\n  return (\n    ((state >= State.COMMAND_GRAB_RANGE1_START && state <= State.COMMAND_GRAB_RANGE1_END) ||\n      (state >= State.COMMAND_GRAB_RANGE2_START && state <= State.COMMAND_GRAB_RANGE2_END)) &&\n    state !== State.BARREL_WAIT\n  );\n}\n\nexport function isDead(state: number): boolean {\n  return state >= State.DYING_START && state <= State.DYING_END;\n}\n\nexport function calcDamageTaken(frame: PostFrameUpdateType, prevFrame: PostFrameUpdateType): number {\n  const percent = frame.percent ?? 0;\n  const prevPercent = prevFrame.percent ?? 0;\n\n  return percent - prevPercent;\n}\n","import { get, isEqual, keyBy, last, set, size } from \"lodash\";\n\nimport type { FrameEntryType, GameStartType } from \"../types\";\nimport type { ActionCountsType, PlayerIndexedType } from \"./common\";\nimport { getSinglesPlayerPermutationsFromSettings, State } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\n// Frame pattern that indicates a dash dance turn was executed\nconst dashDanceAnimations = [State.DASH, State.TURN, State.DASH];\n\ninterface PlayerActionState {\n  playerCounts: ActionCountsType;\n  animations: number[];\n}\n\nexport class ActionsComputer implements StatComputer<ActionCountsType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, PlayerActionState>();\n\n  public setup(settings: GameStartType): void {\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach((indices) => {\n      const playerCounts: ActionCountsType = {\n        playerIndex: indices.playerIndex,\n        wavedashCount: 0,\n        wavelandCount: 0,\n        airDodgeCount: 0,\n        dashDanceCount: 0,\n        spotDodgeCount: 0,\n        ledgegrabCount: 0,\n        rollCount: 0,\n        lCancelCount: {\n          success: 0,\n          fail: 0,\n        },\n        grabCount: {\n          success: 0,\n          fail: 0,\n        },\n        throwCount: {\n          up: 0,\n          forward: 0,\n          back: 0,\n          down: 0,\n        },\n        groundTechCount: {\n          // tech away/in are in reference to the opponents position and not the stage\n          away: 0,\n          in: 0,\n          neutral: 0,\n          fail: 0,\n        },\n        wallTechCount: {\n          success: 0,\n          fail: 0,\n        },\n      };\n      const playerState: PlayerActionState = {\n        playerCounts: playerCounts,\n        animations: [],\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleActionCompute(state, indices, frame);\n      }\n    });\n  }\n\n  public fetch(): ActionCountsType[] {\n    return Array.from(this.state.values()).map((val) => val.playerCounts);\n  }\n}\n\nfunction didMissGroundTech(animation: State): boolean {\n  return animation === State.TECH_MISS_DOWN || animation === State.TECH_MISS_UP;\n}\n\nfunction isRolling(animation: State): boolean {\n  return animation === State.ROLL_BACKWARD || animation === State.ROLL_FORWARD;\n}\n\nfunction didStartRoll(currentAnimation: number, previousAnimation: number): boolean {\n  const isCurrentlyRolling = isRolling(currentAnimation);\n  const wasPreviouslyRolling = isRolling(previousAnimation);\n\n  return isCurrentlyRolling && !wasPreviouslyRolling;\n}\n\nfunction isSpotDodging(animation: State): boolean {\n  return animation === State.SPOT_DODGE;\n}\n\nfunction didStartGrabSuccess(currentAnimation: State, previousAnimation: State): boolean {\n  return previousAnimation === State.GRAB && currentAnimation <= State.GRAB_WAIT && currentAnimation > State.GRAB;\n}\nfunction didStartGrabFail(currentAnimation: State, previousAnimation: State): boolean {\n  return previousAnimation === State.GRAB && (currentAnimation > State.GRAB_WAIT || currentAnimation < State.GRAB);\n}\n\nfunction didStartSpotDodge(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyDodging = isSpotDodging(currentAnimation);\n  const wasPreviouslyDodging = isSpotDodging(previousAnimation);\n\n  return isCurrentlyDodging && !wasPreviouslyDodging;\n}\n\nfunction isAirDodging(animation: State): boolean {\n  return animation === State.AIR_DODGE;\n}\n\nfunction didStartAirDodge(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyDodging = isAirDodging(currentAnimation);\n  const wasPreviouslyDodging = isAirDodging(previousAnimation);\n\n  return isCurrentlyDodging && !wasPreviouslyDodging;\n}\n\nfunction isGrabbingLedge(animation: State): boolean {\n  return animation === State.CLIFF_CATCH;\n}\n\nfunction isAerialAttack(animation: State): boolean {\n  return animation >= State.AERIAL_ATTACK_START && animation <= State.AERIAL_ATTACK_END;\n}\n\nfunction didStartLedgegrab(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyGrabbingLedge = isGrabbingLedge(currentAnimation);\n  const wasPreviouslyGrabbingLedge = isGrabbingLedge(previousAnimation);\n\n  return isCurrentlyGrabbingLedge && !wasPreviouslyGrabbingLedge;\n}\n\nfunction handleActionCompute(state: PlayerActionState, indices: PlayerIndexedType, frame: FrameEntryType): void {\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n  const incrementCount = (field: string, condition: boolean): void => {\n    if (!condition) {\n      return;\n    }\n\n    const current: number = get(state.playerCounts, field, 0);\n    set(state.playerCounts, field, current + 1);\n  };\n\n  // Manage animation state\n  const currentAnimation = playerFrame.actionStateId!;\n  state.animations.push(currentAnimation);\n\n  // Grab last 3 frames\n  const last3Frames = state.animations.slice(-3);\n  const prevAnimation = last3Frames[last3Frames.length - 2] as number;\n  const newAnimation = currentAnimation !== prevAnimation;\n\n  // Increment counts based on conditions\n  const didDashDance = isEqual(last3Frames, dashDanceAnimations);\n  incrementCount(\"dashDanceCount\", didDashDance);\n\n  const didRoll = didStartRoll(currentAnimation, prevAnimation);\n  incrementCount(\"rollCount\", didRoll);\n\n  const didSpotDodge = didStartSpotDodge(currentAnimation, prevAnimation);\n  incrementCount(\"spotDodgeCount\", didSpotDodge);\n\n  const didAirDodge = didStartAirDodge(currentAnimation, prevAnimation);\n  incrementCount(\"airDodgeCount\", didAirDodge);\n\n  const didGrabLedge = didStartLedgegrab(currentAnimation, prevAnimation);\n  incrementCount(\"ledgegrabCount\", didGrabLedge);\n\n  const didGrabSucceed = didStartGrabSuccess(currentAnimation, prevAnimation);\n  incrementCount(\"grabCount.success\", didGrabSucceed);\n  const didGrabFail = didStartGrabFail(currentAnimation, prevAnimation);\n  incrementCount(\"grabCount.fail\", didGrabFail);\n\n  incrementCount(\"throwCount.up\", currentAnimation === State.THROW_UP && newAnimation);\n  incrementCount(\"throwCount.forward\", currentAnimation === State.THROW_FORWARD && newAnimation);\n  incrementCount(\"throwCount.down\", currentAnimation === State.THROW_DOWN && newAnimation);\n  incrementCount(\"throwCount.back\", currentAnimation === State.THROW_BACK && newAnimation);\n\n  if (newAnimation) {\n    const didMissTech = didMissGroundTech(currentAnimation);\n    incrementCount(\"groundTechCount.fail\", didMissTech);\n    let opponentDir = 1;\n    let facingOpponent = false;\n\n    if (playerFrame.positionX! > opponentFrame.positionX!) {\n      opponentDir = -1;\n    }\n    if (playerFrame.facingDirection == opponentDir) {\n      facingOpponent = true;\n    }\n\n    incrementCount(\"groundTechCount.in\", currentAnimation === State.FORWARD_TECH && facingOpponent);\n    incrementCount(\"groundTechCount.in\", currentAnimation === State.BACKWARD_TECH && !facingOpponent);\n    incrementCount(\"groundTechCount.neutral\", currentAnimation === State.NEUTRAL_TECH);\n    incrementCount(\"groundTechCount.away\", currentAnimation === State.BACKWARD_TECH && facingOpponent);\n    incrementCount(\"groundTechCount.away\", currentAnimation === State.FORWARD_TECH && !facingOpponent);\n\n    incrementCount(\"wallTechCount.success\", currentAnimation === State.WALL_TECH);\n    incrementCount(\"wallTechCount.fail\", currentAnimation === State.MISSED_WALL_TECH);\n  }\n\n  if (isAerialAttack(currentAnimation)) {\n    incrementCount(\"lCancelCount.success\", playerFrame.lCancelStatus === 1);\n    incrementCount(\"lCancelCount.fail\", playerFrame.lCancelStatus === 2);\n  }\n\n  // Handles wavedash detection (and waveland)\n  handleActionWavedash(state.playerCounts, state.animations);\n}\n\nfunction handleActionWavedash(counts: ActionCountsType, animations: State[]): void {\n  const currentAnimation = last(animations);\n  const prevAnimation = animations[animations.length - 2] as number;\n\n  const isSpecialLanding = currentAnimation === State.LANDING_FALL_SPECIAL;\n  const isAcceptablePrevious = isWavedashInitiationAnimation(prevAnimation);\n  const isPossibleWavedash = isSpecialLanding && isAcceptablePrevious;\n\n  if (!isPossibleWavedash) {\n    return;\n  }\n\n  // Here we special landed, it might be a wavedash, let's check\n  // We grab the last 8 frames here because that should be enough time to execute a\n  // wavedash. This number could be tweaked if we find false negatives\n  const recentFrames = animations.slice(-8);\n  const recentAnimations = keyBy(recentFrames, (animation) => animation);\n\n  if (size(recentAnimations) === 2 && recentAnimations[State.AIR_DODGE]) {\n    // If the only other animation is air dodge, this might be really late to the point\n    // where it was actually an air dodge. Air dodge animation is really long\n    return;\n  }\n\n  if (recentAnimations[State.AIR_DODGE]) {\n    // If one of the recent animations was an air dodge, let's remove that from the\n    // air dodge counter, we don't want to count air dodges used to wavedash/land\n    counts.airDodgeCount -= 1;\n  }\n\n  if (recentAnimations[State.ACTION_KNEE_BEND]) {\n    // If a jump was started recently, we will consider this a wavedash\n    counts.wavedashCount += 1;\n  } else {\n    // If there was no jump recently, this is a waveland\n    counts.wavelandCount += 1;\n  }\n}\n\nfunction isWavedashInitiationAnimation(animation: State): boolean {\n  if (animation === State.AIR_DODGE) {\n    return true;\n  }\n\n  const isAboveMin = animation >= State.CONTROLLED_JUMP_START;\n  const isBelowMax = animation <= State.CONTROLLED_JUMP_END;\n  return isAboveMin && isBelowMax;\n}\n","import { EventEmitter } from \"events\";\nimport { last } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ComboType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isDead,\n  isDown,\n  isGrabbed,\n  isTeching,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nexport enum ComboEvent {\n  COMBO_START = \"COMBO_START\",\n  COMBO_EXTEND = \"COMBO_EXTEND\",\n  COMBO_END = \"COMBO_END\",\n}\n\ninterface ComboState {\n  combo: ComboType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n  event: ComboEvent | null;\n}\n\nexport class ComboComputer extends EventEmitter implements StatComputer<ComboType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, ComboState>();\n  private combos = new Array<ComboType>();\n  private settings: GameStartType | null = null;\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.state = new Map();\n    this.combos = [];\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: ComboState = {\n        combo: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n        event: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleComboCompute(allFrames, state, indices, frame, this.combos);\n        // Emit an event for the new combo\n        if (state.event !== null) {\n          this.emit(state.event, {\n            combo: last(this.combos),\n            settings: this.settings,\n          });\n          state.event = null;\n        }\n      }\n    });\n  }\n\n  public fetch(): ComboType[] {\n    return this.combos;\n  }\n}\n\nfunction handleComboCompute(\n  frames: FramesType,\n  state: ComboState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  combos: ComboType[],\n): void {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a combo or count the moves for the existing combo\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    let comboStarted = false;\n    if (!state.combo) {\n      state.combo = {\n        playerIndex: indices.opponentIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        lastHitBy: indices.playerIndex,\n      };\n\n      combos.push(state.combo);\n\n      // Track whether this is a new combo or not\n      comboStarted = true;\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.combo.moves.push(state.move);\n\n        // Make sure we don't overwrite the START event\n        if (!comboStarted) {\n          state.event = ComboEvent.COMBO_EXTEND;\n        }\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n\n    if (comboStarted) {\n      state.event = ComboEvent.COMBO_START;\n    }\n  }\n\n  if (!state.combo) {\n    // The rest of the function handles combo termination logic, so if we don't\n    // have a combo started, there is no need to continue\n    return;\n  }\n\n  const opntIsTeching = isTeching(oppActionStateId);\n  const opntIsDowned = isDown(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n  const opntIsDying = isDead(oppActionStateId);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.combo.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed || opntIsTeching || opntIsDowned || opntIsDying) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  } else {\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.combo.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - combo resets on time\n  if (state.resetCounter > Timers.COMBO_STRING_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If combo should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.combo.endFrame = playerFrame.frame;\n    state.combo.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n    state.event = ComboEvent.COMBO_END;\n\n    state.combo = null;\n    state.move = null;\n  }\n}\n","export enum Command {\n  MESSAGE_SIZES = 0x35,\n  GAME_START = 0x36,\n  PRE_FRAME_UPDATE = 0x37,\n  POST_FRAME_UPDATE = 0x38,\n  GAME_END = 0x39,\n  ITEM_UPDATE = 0x3b,\n  FRAME_BOOKEND = 0x3c,\n}\n\nexport interface PlayerType {\n  playerIndex: number;\n  port: number;\n  characterId: number | null;\n  characterColor: number | null;\n  startStocks: number | null;\n  type: number | null;\n  teamId: number | null;\n  controllerFix: string | null;\n  nametag: string | null;\n  displayName: string;\n  connectCode: string;\n}\n\nexport enum GameMode {\n  VS = 0x02,\n  ONLINE = 0x08,\n}\n\nexport interface GameStartType {\n  slpVersion: string | null;\n  isTeams: boolean | null;\n  isPAL: boolean | null;\n  stageId: number | null;\n  players: PlayerType[];\n  scene: number | null;\n  gameMode: GameMode | null;\n}\n\nexport interface PreFrameUpdateType {\n  frame: number | null;\n  playerIndex: number | null;\n  isFollower: boolean | null;\n  seed: number | null;\n  actionStateId: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  facingDirection: number | null;\n  joystickX: number | null;\n  joystickY: number | null;\n  cStickX: number | null;\n  cStickY: number | null;\n  trigger: number | null;\n  buttons: number | null;\n  physicalButtons: number | null;\n  physicalLTrigger: number | null;\n  physicalRTrigger: number | null;\n  percent: number | null;\n}\n\nexport interface PostFrameUpdateType {\n  frame: number | null;\n  playerIndex: number | null;\n  isFollower: boolean | null;\n  internalCharacterId: number | null;\n  actionStateId: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  facingDirection: number | null;\n  percent: number | null;\n  shieldSize: number | null;\n  lastAttackLanded: number | null;\n  currentComboCount: number | null;\n  lastHitBy: number | null;\n  stocksRemaining: number | null;\n  actionStateCounter: number | null;\n  miscActionState: number | null;\n  isAirborne: boolean | null;\n  lastGroundId: number | null;\n  jumpsRemaining: number | null;\n  lCancelStatus: number | null;\n  hurtboxCollisionState: number | null;\n  selfInducedSpeeds: SelfInducedSpeedsType | null;\n}\n\nexport interface SelfInducedSpeedsType {\n  airX: number | null;\n  y: number | null;\n  attackX: number | null;\n  attackY: number | null;\n  groundX: number | null;\n}\n\nexport interface ItemUpdateType {\n  frame: number | null;\n  typeId: number | null;\n  state: number | null;\n  facingDirection: number | null;\n  velocityX: number | null;\n  velocityY: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  damageTaken: number | null;\n  expirationTimer: number | null;\n  spawnId: number | null;\n  missileType: number | null;\n  turnipFace: number | null;\n  chargeShotLaunched: number | null;\n  chargePower: number | null;\n  owner: number | null;\n}\n\nexport interface FrameBookendType {\n  frame: number | null;\n  latestFinalizedFrame: number | null;\n}\n\nexport interface GameEndType {\n  gameEndMethod: number | null;\n  lrasInitiatorIndex: number | null;\n}\n\nexport interface MetadataType {\n  startAt?: string | null;\n  playedOn?: string | null;\n  lastFrame?: number | null;\n  players?: {\n    [playerIndex: number]: {\n      characters: {\n        [internalCharacterId: number]: number;\n      };\n      names?: {\n        netplay?: string | null;\n        code?: string | null;\n      };\n    };\n  } | null;\n  consoleNick?: string | null;\n}\n\nexport type EventPayloadTypes =\n  | GameStartType\n  | PreFrameUpdateType\n  | PostFrameUpdateType\n  | ItemUpdateType\n  | FrameBookendType\n  | GameEndType;\n\nexport type EventCallbackFunc = (command: Command, payload?: EventPayloadTypes | null) => boolean;\n\nexport interface FrameEntryType {\n  frame: number;\n  players: {\n    [playerIndex: number]: {\n      pre: PreFrameUpdateType;\n      post: PostFrameUpdateType;\n    } | null;\n  };\n  followers: {\n    [playerIndex: number]: {\n      pre: PreFrameUpdateType;\n      post: PostFrameUpdateType;\n    } | null;\n  };\n  items?: ItemUpdateType[];\n}\n\nexport enum Frames {\n  FIRST = -123,\n  FIRST_PLAYABLE = -39,\n}\n\nexport interface FramesType {\n  [frameIndex: number]: FrameEntryType;\n}\n\nexport interface RollbackFramesType {\n  [frameIndex: number]: FrameEntryType[];\n}\n\nexport interface RollbackFrames {\n  frames: RollbackFramesType;\n  count: number;\n  lengths: number[];\n}\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\nimport type { PlayerIndexedType } from \"./common\";\nimport { getSinglesPlayerPermutationsFromSettings } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nenum JoystickRegion {\n  DZ = 0,\n  NE = 1,\n  SE = 2,\n  SW = 3,\n  NW = 4,\n  N = 5,\n  E = 6,\n  S = 7,\n  W = 8,\n}\n\nexport interface PlayerInput {\n  playerIndex: number;\n  opponentIndex: number;\n  inputCount: number;\n  joystickInputCount: number;\n  cstickInputCount: number;\n  buttonInputCount: number;\n  triggerInputCount: number;\n  pressing_start?: boolean;\n  airborne?: boolean;\n}\n\nexport class InputComputer implements StatComputer<PlayerInput[]> {\n  private state = new Map<PlayerIndexedType, PlayerInput>();\n  private playerPermutations = new Array<PlayerIndexedType>();\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerInput = {\n        playerIndex: indices.playerIndex,\n        opponentIndex: indices.opponentIndex,\n        inputCount: 0,\n        joystickInputCount: 0,\n        cstickInputCount: 0,\n        buttonInputCount: 0,\n        triggerInputCount: 0,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleInputCompute(allFrames, state, indices, frame);\n      }\n    });\n  }\n\n  public fetch(): PlayerInput[] {\n    return Array.from(this.state.values());\n  }\n}\n\nfunction handleInputCompute(\n  frames: FramesType,\n  state: PlayerInput,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n): void {\n  const playerFrame = frame.players[indices.playerIndex]!.pre;\n  const currentFrameNumber = playerFrame.frame!;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber]!.players[indices.playerIndex]!.pre : null;\n\n  if (currentFrameNumber < Frames.FIRST_PLAYABLE || !prevPlayerFrame) {\n    // Don't count inputs until the game actually starts\n    return;\n  }\n\n  // First count the number of buttons that go from 0 to 1\n  // Increment action count by amount of button presses\n  const invertedPreviousButtons = ~prevPlayerFrame.physicalButtons!;\n  const currentButtons = playerFrame.physicalButtons!;\n  const pressing_start = currentButtons & 0x1000;\n  state.pressing_start = pressing_start ? true : false;\n  const postplayerFrame = frame.players[indices.playerIndex]!.post;\n  state.airborne = postplayerFrame.isAirborne ? true : false;\n  const buttonChanges = invertedPreviousButtons & currentButtons & 0xfff;\n  const newInputsPressed = countSetBits(buttonChanges);\n  state.inputCount += newInputsPressed;\n  state.buttonInputCount += newInputsPressed;\n\n  // Increment action count when sticks change from one region to another.\n  // Don't increment when stick returns to deadzone\n  const prevAnalogRegion = getJoystickRegion(prevPlayerFrame.joystickX!, prevPlayerFrame.joystickY!);\n  const currentAnalogRegion = getJoystickRegion(playerFrame.joystickX!, playerFrame.joystickY!);\n  if (prevAnalogRegion !== currentAnalogRegion && currentAnalogRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.joystickInputCount += 1;\n  }\n\n  // Do the same for c-stick\n  const prevCstickRegion = getJoystickRegion(prevPlayerFrame.cStickX!, prevPlayerFrame.cStickY!);\n  const currentCstickRegion = getJoystickRegion(playerFrame.cStickX!, playerFrame.cStickY!);\n  if (prevCstickRegion !== currentCstickRegion && currentCstickRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.cstickInputCount += 1;\n  }\n\n  // Increment action on analog trigger... I'm not sure when. This needs revision\n  // Currently will update input count when the button gets pressed past 0.3\n  // Changes from hard shield to light shield should probably count as inputs but\n  // are not counted here\n  if (prevPlayerFrame.physicalLTrigger! < 0.3 && playerFrame.physicalLTrigger! >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n  if (prevPlayerFrame.physicalRTrigger! < 0.3 && playerFrame.physicalRTrigger! >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n}\n\nfunction countSetBits(x: number): number {\n  // This function solves the Hamming Weight problem. Effectively it counts the number of\n  // bits in the input that are set to 1\n  // This implementation is supposedly very efficient when most bits are zero.\n  // Found: https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation\n  let bits = x;\n\n  let count;\n  for (count = 0; bits; count += 1) {\n    bits &= bits - 1;\n  }\n  return count;\n}\n\nfunction getJoystickRegion(x: number, y: number): JoystickRegion {\n  let region = JoystickRegion.DZ;\n\n  if (x >= 0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NE;\n  } else if (x >= 0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SE;\n  } else if (x <= -0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SW;\n  } else if (x <= -0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NW;\n  } else if (y >= 0.2875) {\n    region = JoystickRegion.N;\n  } else if (x >= 0.2875) {\n    region = JoystickRegion.E;\n  } else if (y <= -0.2875) {\n    region = JoystickRegion.S;\n  } else if (x <= -0.2875) {\n    region = JoystickRegion.W;\n  }\n\n  return region;\n}\n","import { EventEmitter } from \"events\";\nimport { filter, get, groupBy, last, orderBy } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ConversionType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isGrabbed,\n  isInControl,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ninterface PlayerConversionState {\n  conversion: ConversionType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n}\n\ninterface MetadataType {\n  lastEndFrameByOppIdx: {\n    [oppIdx: number]: number;\n  };\n}\n\nexport class ConversionComputer extends EventEmitter implements StatComputer<ConversionType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private conversions = new Array<ConversionType>();\n  private state = new Map<PlayerIndexedType, PlayerConversionState>();\n  private metadata: MetadataType;\n  private settings: GameStartType | null = null;\n\n  public constructor() {\n    super();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n  }\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.conversions = [];\n    this.state = new Map();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n    this.settings = settings;\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerConversionState = {\n        conversion: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        const terminated = handleConversionCompute(allFrames, state, indices, frame, this.conversions);\n        if (terminated) {\n          this.emit(\"CONVERSION\", {\n            combo: last(this.conversions),\n            settings: this.settings,\n          });\n        }\n      }\n    });\n  }\n\n  public fetch(): ConversionType[] {\n    this._populateConversionTypes();\n    return this.conversions;\n  }\n\n  private _populateConversionTypes(): void {\n    // Post-processing step: set the openingTypes\n    const conversionsToHandle = filter(this.conversions, (conversion) => {\n      return conversion.openingType === \"unknown\";\n    });\n\n    // Group new conversions by startTime and sort\n    const groupedConversions = groupBy(conversionsToHandle, \"startFrame\");\n    const sortedConversions = orderBy(groupedConversions, (conversions) => get(conversions, [0, \"startFrame\"]));\n\n    // Set the opening types on the conversions we need to handle\n    sortedConversions.forEach((conversions) => {\n      const isTrade = conversions.length >= 2;\n      conversions.forEach((conversion) => {\n        // Set end frame for this conversion\n        this.metadata.lastEndFrameByOppIdx[conversion.playerIndex] = conversion.endFrame!;\n\n        if (isTrade) {\n          // If trade, just short-circuit\n          conversion.openingType = \"trade\";\n          return;\n        }\n\n        // If not trade, check the opponent endFrame\n        const lastMove = last(conversion.moves);\n        const oppEndFrame =\n          this.metadata.lastEndFrameByOppIdx[lastMove ? lastMove.playerIndex : conversion.playerIndex];\n        const isCounterAttack = oppEndFrame && oppEndFrame > conversion.startFrame;\n        conversion.openingType = isCounterAttack ? \"counter-attack\" : \"neutral-win\";\n      });\n    });\n  }\n}\n\nfunction handleConversionCompute(\n  frames: FramesType,\n  state: PlayerConversionState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  conversions: ConversionType[],\n): boolean {\n  const currentFrameNumber = frame.frame;\n  const playerFrame: PostFrameUpdateType = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a conversion or\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    if (!state.conversion) {\n      state.conversion = {\n        playerIndex: indices.opponentIndex,\n        lastHitBy: indices.playerIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        openingType: \"unknown\", // Will be updated later\n      };\n\n      conversions.push(state.conversion);\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.conversion.moves.push(state.move);\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n  }\n\n  if (!state.conversion) {\n    // The rest of the function handles conversion termination logic, so if we don't\n    // have a conversion started, there is no need to continue\n    return false;\n  }\n\n  const opntInControl = isInControl(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.conversion.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  }\n\n  const shouldStartResetCounter = state.resetCounter === 0 && opntInControl;\n  const shouldContinueResetCounter = state.resetCounter > 0;\n  if (shouldStartResetCounter || shouldContinueResetCounter) {\n    // This will increment the reset timer under the following conditions:\n    // 1) if we were punishing opponent but they have now entered an actionable state\n    // 2) if counter has already started counting meaning opponent has entered actionable state\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.conversion.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - conversion resets on time\n  if (state.resetCounter > Timers.PUNISH_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If conversion should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.conversion.endFrame = playerFrame.frame;\n    state.conversion.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n\n    state.conversion = null;\n    state.move = null;\n  }\n\n  return shouldTerminate;\n}\n","import { first, flatten, get, groupBy, keyBy, last, mapValues, zip } from \"lodash\";\n\nimport type { GameStartType } from \"../types\";\nimport type { ConversionType, InputCountsType, OverallType, RatioType } from \"./common\";\nimport type { PlayerInput } from \"./inputs\";\n\ninterface ConversionsByPlayerByOpening {\n  [playerIndex: string]: {\n    [openingType: string]: ConversionType[];\n  };\n}\n\nexport function generateOverallStats({\n  settings,\n  inputs,\n  conversions,\n  playableFrameCount,\n}: {\n  settings: GameStartType;\n  inputs: PlayerInput[];\n  conversions: ConversionType[];\n  playableFrameCount: number;\n}): OverallType[] {\n  const inputsByPlayer = keyBy(inputs, \"playerIndex\");\n  const originalConversions = conversions;\n  const conversionsByPlayer = groupBy(conversions, (conv) => conv.moves[0]?.playerIndex);\n  const conversionsByPlayerByOpening: ConversionsByPlayerByOpening = mapValues(conversionsByPlayer, (conversions) =>\n    groupBy(conversions, \"openingType\"),\n  );\n\n  const gameMinutes = playableFrameCount / 3600;\n\n  const overall = settings.players.map((player) => {\n    const playerIndex = player.playerIndex;\n\n    const playerInputs = get(inputsByPlayer, playerIndex) || {};\n    const inputCounts: InputCountsType = {\n      buttons: get(playerInputs, \"buttonInputCount\"),\n      triggers: get(playerInputs, \"triggerInputCount\"),\n      cstick: get(playerInputs, \"cstickInputCount\"),\n      joystick: get(playerInputs, \"joystickInputCount\"),\n      total: get(playerInputs, \"inputCount\"),\n    };\n    // const conversions = get(conversionsByPlayer, playerIndex) || [];\n    // const successfulConversions = conversions.filter((conversion) => conversion.moves.length > 1);\n    let conversionCount = 0;\n    let successfulConversionCount = 0;\n\n    const opponentIndices = settings.players\n      .filter((opp) => {\n        // We want players which aren't ourselves\n        if (opp.playerIndex === playerIndex) {\n          return false;\n        }\n\n        // Make sure they're not on our team either\n        return !settings.isTeams || opp.teamId !== player.teamId;\n      })\n      .map((opp) => opp.playerIndex);\n\n    let totalDamage = 0;\n    let killCount = 0;\n\n    // These are the conversions that we did on our opponents\n    originalConversions\n      // Filter down to conversions of our opponent\n      .filter((conversion) => conversion.playerIndex !== playerIndex)\n      .forEach((conversion) => {\n        conversionCount++;\n\n        // We killed the opponent\n        if (conversion.didKill && conversion.lastHitBy === playerIndex) {\n          killCount += 1;\n        }\n        if (conversion.moves.length > 1 && conversion.moves[0]!.playerIndex === playerIndex) {\n          successfulConversionCount++;\n        }\n        conversion.moves.forEach((move) => {\n          if (move.playerIndex === playerIndex) {\n            totalDamage += move.damage;\n          }\n        });\n      });\n\n    return {\n      playerIndex: playerIndex,\n      inputCounts: inputCounts,\n      conversionCount: conversionCount,\n      totalDamage: totalDamage,\n      killCount: killCount,\n\n      successfulConversions: getRatio(successfulConversionCount, conversionCount),\n      inputsPerMinute: getRatio(inputCounts.total, gameMinutes),\n      digitalInputsPerMinute: getRatio(inputCounts.buttons, gameMinutes),\n      openingsPerKill: getRatio(conversionCount, killCount),\n      damagePerOpening: getRatio(totalDamage, conversionCount),\n      neutralWinRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"neutral-win\"),\n      counterHitRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"counter-attack\"),\n      beneficialTradeRatio: getBeneficialTradeRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices),\n    };\n  });\n\n  return overall;\n}\n\nfunction getRatio(count: number, total: number): RatioType {\n  return {\n    count: count,\n    total: total,\n    ratio: total ? count / total : null,\n  };\n}\n\nfunction getOpeningRatio(\n  conversionsByPlayerByOpening: ConversionsByPlayerByOpening,\n  playerIndex: number,\n  opponentIndices: number[],\n  type: string,\n): RatioType {\n  const openings = get(conversionsByPlayerByOpening, [playerIndex, type]) || [];\n\n  const opponentOpenings = flatten(\n    opponentIndices.map((opponentIndex) => get(conversionsByPlayerByOpening, [opponentIndex, type]) || []),\n  );\n\n  return getRatio(openings.length, openings.length + opponentOpenings.length);\n}\n\nfunction getBeneficialTradeRatio(\n  conversionsByPlayerByOpening: ConversionsByPlayerByOpening,\n  playerIndex: number,\n  opponentIndices: number[],\n): RatioType {\n  const playerTrades = get(conversionsByPlayerByOpening, [playerIndex, \"trade\"]) || [];\n  const opponentTrades = flatten(\n    opponentIndices.map((opponentIndex) => get(conversionsByPlayerByOpening, [opponentIndex, \"trade\"]) || []),\n  );\n\n  const benefitsPlayer = [];\n\n  // Figure out which punishes benefited this player\n  const zippedTrades = zip(playerTrades, opponentTrades);\n  zippedTrades.forEach((conversionPair) => {\n    const playerConversion = first(conversionPair);\n    const opponentConversion = last(conversionPair);\n    if (playerConversion && opponentConversion) {\n      const playerDamage = playerConversion.currentPercent - playerConversion.startPercent;\n      const opponentDamage = opponentConversion.currentPercent - opponentConversion.startPercent;\n\n      if (playerConversion!.didKill && !opponentConversion!.didKill) {\n        benefitsPlayer.push(playerConversion);\n      } else if (playerDamage > opponentDamage) {\n        benefitsPlayer.push(playerConversion);\n      }\n    }\n  });\n\n  return getRatio(benefitsPlayer.length, playerTrades.length);\n}\n","import { get } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\n\nexport interface StatComputer<T> {\n  setup(settings: GameStartType): void;\n  processFrame(newFrame: FrameEntryType, allFrames: FramesType): void;\n  fetch(): T;\n}\n\nexport interface StatOptions {\n  processOnTheFly: boolean;\n}\n\nconst defaultOptions: StatOptions = {\n  processOnTheFly: false,\n};\n\nexport class Stats {\n  private options: StatOptions;\n  private lastProcessedFrame: number | null = null;\n  private frames: FramesType = {};\n  private players: number[] = [];\n  private allComputers = new Array<StatComputer<unknown>>();\n\n  public constructor(options?: StatOptions) {\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n\n  /**\n   * Should reset the frames to their default values.\n   */\n  public setup(settings: GameStartType): void {\n    // Reset the frames since it's a new game\n    this.frames = {};\n    this.players = settings.players.map((v) => v.playerIndex);\n\n    // Forward the settings on to the individual stat computer\n    this.allComputers.forEach((comp) => comp.setup(settings));\n  }\n\n  public register(...computer: StatComputer<unknown>[]): void {\n    this.allComputers.push(...computer);\n  }\n\n  public process(): void {\n    if (this.players.length === 0) {\n      return;\n    }\n\n    let i = this.lastProcessedFrame !== null ? this.lastProcessedFrame + 1 : Frames.FIRST;\n    while (this.frames[i]) {\n      const frame = this.frames[i];\n      // Don't attempt to compute stats on frames that have not been fully received\n      if (!isCompletedFrame(this.players, frame)) {\n        return;\n      }\n      this.allComputers.forEach((comp) => comp.processFrame(frame, this.frames));\n      this.lastProcessedFrame = i;\n      i++;\n    }\n  }\n\n  public addFrame(frame: FrameEntryType): void {\n    this.frames[frame.frame] = frame;\n\n    if (this.options.processOnTheFly) {\n      this.process();\n    }\n  }\n}\n\nfunction isCompletedFrame(players: number[], frame?: FrameEntryType): frame is FrameEntryType {\n  if (!frame) {\n    return false;\n  }\n\n  // This function checks whether we have successfully received an entire frame.\n  // It is not perfect because it does not wait for follower frames. Fortunately,\n  // follower frames are not used for any stat calculations so this doesn't matter\n  // for our purposes.\n  for (const player of players) {\n    const playerPostFrame = get(frame, [\"players\", player, \"post\"]);\n    if (!playerPostFrame) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","export interface SlpReadInput {\n  source: SlpInputSource;\n  filePath?: string;\n  buffer?: Uint8Array;\n}\nexport enum SlpInputSource {\n  BUFFER = \"buffer\",\n  FILE = \"file\",\n}\n\nexport interface SlpFileType {\n  ref: SlpRefType;\n  full_data: Uint8Array;\n  rawDataPosition: number;\n  rawDataLength: number;\n  metadataPosition: number;\n  metadataLength: number;\n  messageSizes: {\n    [command: number]: number;\n  };\n}\n\nexport interface SlpFileSourceRef {\n  source: SlpInputSource;\n  fileDescriptor: number;\n}\n\nexport interface SlpBufferSourceRef {\n  source: SlpInputSource;\n  buffer: Uint8Array;\n}\n\nexport interface SlpBufferSourceRef {\n  source: SlpInputSource;\n  buffer: Uint8Array;\n}\n\nexport type SlpRefType = SlpFileSourceRef | SlpBufferSourceRef;\n\nexport const getRef = (input: SlpReadInput): SlpRefType => {\n  switch (input.source) {\n    case SlpInputSource.BUFFER:\n      return {\n        source: input.source,\n        buffer: input.buffer,\n      } as SlpBufferSourceRef;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n};\n\nexport const readRef = (ref: SlpRefType, length: number, position: number): Uint8Array => {\n  switch (ref.source) {\n    case SlpInputSource.BUFFER:\n      return (ref as SlpBufferSourceRef).buffer.slice(position, position + length);\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n};\n\nexport const getLenRef = (ref: SlpRefType): number => {\n  switch (ref.source) {\n    case SlpInputSource.BUFFER:\n      return (ref as SlpBufferSourceRef).buffer.length;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n};\n\nexport const readFullData = (input: SlpReadInput): Uint8Array => {\n  const ref = getRef(input);\n  switch (ref.source) {\n    case SlpInputSource.BUFFER:\n      return input.buffer || new Uint8Array();\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n};\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport type { PlayerIndexedType, StockType } from \"./common\";\nimport { didLoseStock, getSinglesPlayerPermutationsFromSettings, isDead } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ninterface StockState {\n  stock?: StockType | null;\n}\n\nexport class StockComputer implements StatComputer<StockType[]> {\n  private state = new Map<PlayerIndexedType, StockState>();\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private stocks = new Array<StockType>();\n\n  public setup(settings: GameStartType): void {\n    // Reset state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.stocks = [];\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: StockState = {\n        stock: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleStockCompute(allFrames, state, indices, frame, this.stocks);\n      }\n    });\n  }\n\n  public fetch(): StockType[] {\n    return this.stocks;\n  }\n}\n\nfunction handleStockCompute(\n  frames: FramesType,\n  state: StockState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  stocks: StockType[],\n): void {\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const currentFrameNumber = playerFrame.frame!;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber]!.players[indices.playerIndex]!.post : null;\n\n  // If there is currently no active stock, wait until the player is no longer spawning.\n  // Once the player is no longer spawning, start the stock\n  if (!state.stock) {\n    const isPlayerDead = isDead(playerFrame.actionStateId!);\n    if (isPlayerDead) {\n      return;\n    }\n\n    state.stock = {\n      playerIndex: indices.playerIndex,\n      startFrame: currentFrameNumber,\n      endFrame: null,\n      startPercent: 0,\n      endPercent: null,\n      currentPercent: 0,\n      count: playerFrame.stocksRemaining!,\n      deathAnimation: null,\n    };\n\n    stocks.push(state.stock);\n  } else if (prevPlayerFrame && didLoseStock(playerFrame, prevPlayerFrame)) {\n    state.stock.endFrame = playerFrame.frame;\n    state.stock.endPercent = prevPlayerFrame.percent ?? 0;\n    state.stock.deathAnimation = playerFrame.actionStateId;\n    state.stock = null;\n  } else {\n    state.stock.currentPercent = playerFrame.percent ?? 0;\n  }\n}\n","import _ from \"lodash\";\n\nexport function toHalfwidth(str: string): string {\n  // Converts a fullwidth character to halfwidth\n  const convertChar = (charCode: number): number => {\n    /**\n     * Standard full width encodings\n     * https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)\n     */\n    if (charCode > 0xff00 && charCode < 0xff5f) {\n      return 0x0020 + (charCode - 0xff00);\n    }\n\n    // space:\n    if (charCode === 0x3000) {\n      return 0x0020;\n    }\n\n    /**\n     * Exceptions found in Melee/Japanese keyboards\n     */\n    // single quote: '\n    if (charCode === 0x2019) {\n      return 0x0027;\n    }\n\n    // double quote: \"\n    if (charCode === 0x201d) {\n      return 0x0022;\n    }\n\n    return charCode;\n  };\n\n  const ret = _.map(str, (char) => convertChar(char.charCodeAt(0)));\n\n  return String.fromCharCode(...ret);\n}\n","import { convert } from \"encoding-japanese\";\n\nimport type { EventCallbackFunc, EventPayloadTypes, PlayerType, SelfInducedSpeedsType } from \"../types\";\nimport { Command } from \"../types\";\nimport { toHalfwidth } from \"./fullwidth\";\nimport { readFullData } from \"./browserReading\";\n\nexport enum SlpInputSource {\n  BUFFER = \"buffer\",\n  FILE = \"file\",\n}\n\nexport interface SlpReadInput {\n  source: SlpInputSource;\n  filePath?: string;\n  buffer?: Uint8Array;\n}\n\nexport type SlpRefType = SlpFileSourceRef | SlpBufferSourceRef;\n\nexport interface SlpFileType {\n  full_data: Uint8Array;\n  rawDataPosition: number;\n  rawDataLength: number;\n  messageSizes: {\n    [command: number]: number;\n  };\n}\n\nexport interface SlpFileSourceRef {\n  source: SlpInputSource;\n  fileDescriptor: number;\n}\n\nexport interface SlpBufferSourceRef {\n  source: SlpInputSource;\n  buffer: Uint8Array;\n}\n\n/**\n * Opens a file at path\n */\nexport function openSlpFile(input: SlpReadInput): SlpFileType {\n  const full_data = readFullData(input);\n\n  const raw_data_position = getRawDataPosition(full_data);\n  const raw_data_length = getRawDataLength(full_data, raw_data_position);\n  const message_sizes = getMessageSizes(full_data, raw_data_position);\n  return {\n    full_data: full_data,\n    rawDataPosition: raw_data_position,\n    rawDataLength: raw_data_length,\n    messageSizes: message_sizes,\n  };\n}\n\n// This function gets the position where the raw data starts\nfunction getRawDataPosition(buffer: Uint8Array): number {\n  if (buffer[0] !== \"{\".charCodeAt(0)) {\n    return 0; // return error?\n  }\n  return 15;\n}\n\nfunction getRawDataLength(buffer: Uint8Array, position: number): number {\n  const file_size = buffer.length;\n  if (position === 0) {\n    return file_size;\n  }\n  const length_info = buffer.slice(position - 4, position);\n  const raw_data_len = (length_info[0]! << 24) | (length_info[1]! << 16) | (length_info[2]! << 8) | length_info[3]!;\n  if (raw_data_len > 0) {\n    // If this method manages to read a number, it's probably trustworthy\n    return raw_data_len;\n  }\n  // If the above does not return a valid data length,\n  // return a file size based on file length. This enables\n  // some support for severed files\n  return file_size - position;\n}\n\nfunction getMessageSizes(\n  buffer: Uint8Array,\n  position: number,\n): {\n  [command: number]: number;\n} {\n  const messageSizes: {\n    [command: number]: number;\n  } = {};\n  // Support old file format\n  if (position === 0) {\n    messageSizes[0x36] = 0x140;\n    messageSizes[0x37] = 0x6;\n    messageSizes[0x38] = 0x46;\n    messageSizes[0x39] = 0x1;\n    return messageSizes;\n  }\n\n  const message_metadata = buffer.slice(position, position + 2);\n  if (message_metadata[0] !== Command.MESSAGE_SIZES) {\n    return {};\n  }\n  const payloadLength = message_metadata[1] as number;\n  (messageSizes[0x35] as any) = payloadLength;\n\n  const message_sizes_buffer = buffer.slice(position + 2, position + payloadLength + 1);\n  for (let i = 0; i < payloadLength - 1; i += 3) {\n    const command = message_sizes_buffer[i] as number;\n\n    // Get size of command\n    (messageSizes[command] as any) = (message_sizes_buffer[i + 1]! << 8) | message_sizes_buffer[i + 2]!;\n  }\n\n  return messageSizes;\n}\n\n/**\n * Iterates through slp events and parses payloads\n */\nexport function iterateEvents(\n  slpFile: SlpFileType,\n  getShouldStop: EventCallbackFunc,\n  startPos: number | null = null,\n): number {\n  const full_data = slpFile.full_data;\n\n  let readPosition = startPos !== null && startPos > 0 ? startPos : slpFile.rawDataPosition;\n  const stopReadingAt = slpFile.rawDataPosition + slpFile.rawDataLength;\n\n  while (readPosition < stopReadingAt) {\n    const commandByte = full_data[readPosition] as number;\n    const message_size = (slpFile.messageSizes[commandByte] as number) + 1;\n    if (message_size === undefined) {\n      // If we don't have an entry for this command, return false to indicate failed read\n      return readPosition;\n    }\n    if (message_size > stopReadingAt - readPosition) {\n      return readPosition;\n    }\n\n    const data = full_data.slice(readPosition, readPosition + message_size);\n    const parsed_payload = parseMessage(commandByte, data);\n    const shouldStop = getShouldStop(commandByte, parsed_payload);\n    if (shouldStop) {\n      break;\n    }\n\n    readPosition += message_size;\n  }\n\n  return readPosition;\n}\n\nconst decodeBuf = (buf: Uint8Array): string | undefined =>\n  convert(buf, {\n    to: \"UNICODE\",\n    from: \"SJIS\",\n    type: \"string\",\n  })\n    .split(\"\\0\")\n    .shift();\n\nexport function parseMessage(command: Command, payload: Uint8Array): EventPayloadTypes | null {\n  const sliced_buffer = payload.buffer.slice(payload.byteOffset, payload.byteOffset + payload.byteLength);\n  const view = new DataView(sliced_buffer);\n  switch (command) {\n    case Command.GAME_START:\n      const getPlayerObject = (playerIndex: number): PlayerType => {\n        // Controller Fix stuff\n        const cfOffset = playerIndex * 0x8;\n        const dashback = readUint32(view, 0x141 + cfOffset);\n        const shieldDrop = readUint32(view, 0x145 + cfOffset);\n        let cfOption = \"None\";\n        if (dashback !== shieldDrop) {\n          cfOption = \"Mixed\";\n        } else if (dashback === 1) {\n          cfOption = \"UCF\";\n        } else if (dashback === 2) {\n          cfOption = \"Dween\";\n        }\n\n        // Nametag stuff\n        const nametagLength = 0x10;\n        const nametagOffset = playerIndex * nametagLength;\n        const nametagStart = 0x161 + nametagOffset;\n        const nametagBuf = payload.slice(nametagStart, nametagStart + nametagLength);\n        const nameTagString = decodeBuf(nametagBuf);\n        const nametag = nameTagString ? toHalfwidth(nameTagString) : \"\";\n\n        // Display name\n        const displayNameLength = 0x1f;\n        const displayNameOffset = playerIndex * displayNameLength;\n        const displayNameStart = 0x1a5 + displayNameOffset;\n        const displayNameBuf = payload.slice(displayNameStart, displayNameStart + displayNameLength);\n        const displayNameString = decodeBuf(displayNameBuf);\n        const displayName = displayNameString ? toHalfwidth(displayNameString) : \"\";\n\n        // Connect code\n        const connectCodeLength = 0xa;\n        const connectCodeOffset = playerIndex * connectCodeLength;\n        const connectCodeStart = 0x221 + connectCodeOffset;\n        const connectCodeBuf = payload.slice(connectCodeStart, connectCodeStart + connectCodeLength);\n        const connectCodeString = decodeBuf(connectCodeBuf);\n        const connectCode = connectCodeString ? toHalfwidth(connectCodeString) : \"\";\n\n        const offset = playerIndex * 0x24;\n        const result = {\n          playerIndex: playerIndex,\n          port: playerIndex + 1,\n          characterId: readUint8(view, 0x65 + offset),\n          characterColor: readUint8(view, 0x68 + offset),\n          startStocks: readUint8(view, 0x67 + offset),\n          type: readUint8(view, 0x66 + offset),\n          teamId: readUint8(view, 0x6e + offset),\n          controllerFix: cfOption,\n          nametag: nametag,\n          displayName: displayName,\n          connectCode: connectCode,\n        };\n        return result;\n      };\n      return {\n        slpVersion: `${readUint8(view, 0x1)}.${readUint8(view, 0x2)}.${readUint8(view, 0x3)}`,\n        isTeams: readBool(view, 0xd),\n        isPAL: readBool(view, 0x1a1),\n        stageId: readUint16(view, 0x13),\n        players: [0, 1, 2, 3].map(getPlayerObject),\n        scene: readUint8(view, 0x1a3),\n        gameMode: readUint8(view, 0x1a4),\n      };\n    case Command.PRE_FRAME_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        seed: readUint32(view, 0x7),\n        actionStateId: readUint16(view, 0xb),\n        positionX: readFloat(view, 0xd),\n        positionY: readFloat(view, 0x11),\n        facingDirection: readFloat(view, 0x15),\n        joystickX: readFloat(view, 0x19),\n        joystickY: readFloat(view, 0x1d),\n        cStickX: readFloat(view, 0x21),\n        cStickY: readFloat(view, 0x25),\n        trigger: readFloat(view, 0x29),\n        buttons: readUint32(view, 0x2d),\n        physicalButtons: readUint16(view, 0x31),\n        physicalLTrigger: readFloat(view, 0x33),\n        physicalRTrigger: readFloat(view, 0x37),\n        percent: readFloat(view, 0x3c),\n      };\n    case Command.POST_FRAME_UPDATE:\n      const selfInducedSpeeds: SelfInducedSpeedsType = {\n        airX: readFloat(view, 0x35),\n        y: readFloat(view, 0x39),\n        attackX: readFloat(view, 0x3d),\n        attackY: readFloat(view, 0x41),\n        groundX: readFloat(view, 0x45),\n      };\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        internalCharacterId: readUint8(view, 0x7),\n        actionStateId: readUint16(view, 0x8),\n        positionX: readFloat(view, 0xa),\n        positionY: readFloat(view, 0xe),\n        facingDirection: readFloat(view, 0x12),\n        percent: readFloat(view, 0x16),\n        shieldSize: readFloat(view, 0x1a),\n        lastAttackLanded: readUint8(view, 0x1e),\n        currentComboCount: readUint8(view, 0x1f),\n        lastHitBy: readUint8(view, 0x20),\n        stocksRemaining: readUint8(view, 0x21),\n        actionStateCounter: readFloat(view, 0x22),\n        miscActionState: readFloat(view, 0x2b),\n        isAirborne: readBool(view, 0x2f),\n        lastGroundId: readUint16(view, 0x30),\n        jumpsRemaining: readUint8(view, 0x32),\n        lCancelStatus: readUint8(view, 0x33),\n        hurtboxCollisionState: readUint8(view, 0x34),\n        selfInducedSpeeds: selfInducedSpeeds,\n      };\n    case Command.ITEM_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        typeId: readUint16(view, 0x5),\n        state: readUint8(view, 0x7),\n        facingDirection: readFloat(view, 0x8),\n        velocityX: readFloat(view, 0xc),\n        velocityY: readFloat(view, 0x10),\n        positionX: readFloat(view, 0x14),\n        positionY: readFloat(view, 0x18),\n        damageTaken: readUint16(view, 0x1c),\n        expirationTimer: readFloat(view, 0x1e),\n        spawnId: readUint32(view, 0x22),\n        missileType: readUint8(view, 0x26),\n        turnipFace: readUint8(view, 0x27),\n        chargeShotLaunched: readUint8(view, 0x28),\n        chargePower: readUint8(view, 0x29),\n        owner: readInt8(view, 0x2a),\n      };\n    case Command.FRAME_BOOKEND:\n      return {\n        frame: readInt32(view, 0x1),\n        latestFinalizedFrame: readInt32(view, 0x5),\n      };\n    case Command.GAME_END:\n      return {\n        gameEndMethod: readUint8(view, 0x1),\n        lrasInitiatorIndex: readInt8(view, 0x2),\n      };\n    default:\n      return null;\n  }\n}\n\nfunction canReadFromView(view: DataView, offset: number, length: number): boolean {\n  const viewLength = view.byteLength;\n  return offset + length <= viewLength;\n}\n\nfunction readFloat(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getFloat32(offset);\n}\n\nfunction readInt32(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getInt32(offset);\n}\n\nfunction readInt8(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getInt8(offset);\n}\n\nfunction readUint32(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getUint32(offset);\n}\n\nfunction readUint16(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 2)) {\n    return null;\n  }\n\n  return view.getUint16(offset);\n}\n\nfunction readUint8(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getUint8(offset);\n}\n\nfunction readBool(view: DataView, offset: number): boolean | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return !!view.getUint8(offset);\n}\n","import type { WritableOptions } from \"stream\";\nimport { Writable } from \"stream\";\nimport type { EventPayloadTypes } from \"../types\";\nimport { Command } from \"../types\";\nimport { parseMessage } from \"../reading/slpReader\";\n\nconst NETWORK_MESSAGE = \"HELO\\0\";\n\nexport enum SlpStreamMode {\n  AUTO = \"AUTO\", // Always reading data, but errors on invalid command\n  MANUAL = \"MANUAL\", // Stops parsing inputs after a valid game end command, requires manual restarting\n}\n\nconst defaultSettings = {\n  suppressErrors: false,\n  mode: SlpStreamMode.AUTO,\n};\n\nexport type SlpStreamSettings = typeof defaultSettings;\n\nexport type MessageSizes = Map<Command, number>;\n\nexport interface SlpCommandEventPayload {\n  command: Command;\n  payload: EventPayloadTypes | MessageSizes;\n}\n\nexport interface SlpRawEventPayload {\n  command: Command;\n  payload: Buffer;\n}\n\nexport enum SlpStreamEvent {\n  RAW = \"slp-raw\",\n  COMMAND = \"slp-command\",\n}\n\n/**\n * SlpStream is a writable stream of Slippi data. It passes the data being written in\n * and emits an event based on what kind of Slippi messages were processed.\n *\n * SlpStream emits two events: \"slp-raw\" and \"slp-command\". The \"slp-raw\" event emits the raw buffer\n * bytes whenever it processes each command. You can manually parse this or write it to a\n * file. The \"slp-command\" event returns the parsed payload which you can access the attributes.\n *\n * @class SlpStream\n * @extends {Writable}\n */\nexport class SlpStream extends Writable {\n  private gameEnded = false; // True only if in manual mode and the game has completed\n  private settings: SlpStreamSettings;\n  private payloadSizes: MessageSizes | null = null;\n  private previousBuffer: Uint8Array = Buffer.from([]);\n\n  /**\n   *Creates an instance of SlpStream.\n   * @param {Partial<SlpStreamSettings>} [slpOptions]\n   * @param {WritableOptions} [opts]\n   * @memberof SlpStream\n   */\n  public constructor(slpOptions?: Partial<SlpStreamSettings>, opts?: WritableOptions) {\n    super(opts);\n    this.settings = Object.assign({}, defaultSettings, slpOptions);\n  }\n\n  public restart(): void {\n    this.gameEnded = false;\n    this.payloadSizes = null;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public _write(newData: Buffer, encoding: string, callback: (error?: Error | null, data?: any) => void): void {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    }\n\n    // Join the current data with the old data\n    const data = Uint8Array.from(Buffer.concat([this.previousBuffer, newData]));\n\n    // Clear previous data\n    this.previousBuffer = Buffer.from([]);\n\n    const dataView = new DataView(data.buffer);\n\n    // Iterate through the data\n    let index = 0;\n    while (index < data.length) {\n      // We want to filter out the network messages\n      if (Buffer.from(data.slice(index, index + 5)).toString() === NETWORK_MESSAGE) {\n        index += 5;\n        continue;\n      }\n\n      // Make sure we have enough data to read a full payload\n      const command = dataView.getUint8(index);\n      let payloadSize = 0;\n      if (this.payloadSizes) {\n        payloadSize = this.payloadSizes.get(command) ?? 0;\n      }\n      const remainingLen = data.length - index;\n      if (remainingLen < payloadSize + 1) {\n        // If remaining length is not long enough for full payload, save the remaining\n        // data until we receive more data. The data has been split up.\n        this.previousBuffer = data.slice(index);\n        break;\n      }\n\n      // Only process if the game is still going\n      if (this.settings.mode === SlpStreamMode.MANUAL && this.gameEnded) {\n        break;\n      }\n\n      // Increment by one for the command byte\n      index += 1;\n\n      const payloadPtr = data.slice(index);\n      const payloadDataView = new DataView(data.buffer, index);\n      let payloadLen = 0;\n      try {\n        payloadLen = this._processCommand(command, payloadPtr, payloadDataView);\n      } catch (err) {\n        // Only throw the error if we're not suppressing the errors\n        if (!this.settings.suppressErrors) {\n          throw err;\n        }\n        payloadLen = 0;\n      }\n      index += payloadLen;\n    }\n\n    callback();\n  }\n\n  private _writeCommand(command: Command, entirePayload: Uint8Array, payloadSize: number): Uint8Array {\n    const payloadBuf = entirePayload.slice(0, payloadSize);\n    const bufToWrite = Buffer.concat([Buffer.from([command]), payloadBuf]);\n    // Forward the raw buffer onwards\n    this.emit(SlpStreamEvent.RAW, {\n      command: command,\n      payload: bufToWrite,\n    } as SlpRawEventPayload);\n    return new Uint8Array(bufToWrite);\n  }\n\n  private _processCommand(command: Command, entirePayload: Uint8Array, dataView: DataView): number {\n    // Handle the message size command\n    if (command === Command.MESSAGE_SIZES) {\n      const payloadSize = dataView.getUint8(0);\n      // Set the payload sizes\n      this.payloadSizes = processReceiveCommands(dataView);\n      // Emit the raw command event\n      this._writeCommand(command, entirePayload, payloadSize);\n      this.emit(SlpStreamEvent.COMMAND, {\n        command: command,\n        payload: this.payloadSizes,\n      } as SlpCommandEventPayload);\n      return payloadSize;\n    }\n\n    let payloadSize = 0;\n    if (this.payloadSizes) {\n      payloadSize = this.payloadSizes.get(command) ?? 0;\n    }\n\n    // Fetch the payload and parse it\n    let payload: Uint8Array;\n    let parsedPayload: EventPayloadTypes | null = null;\n    if (payloadSize > 0) {\n      payload = this._writeCommand(command, entirePayload, payloadSize);\n      parsedPayload = parseMessage(command, payload);\n    }\n    if (!parsedPayload) {\n      return payloadSize;\n    }\n\n    switch (command) {\n      case Command.GAME_END:\n        // Stop parsing data until we manually restart the stream\n        if (this.settings.mode === SlpStreamMode.MANUAL) {\n          this.gameEnded = true;\n        }\n        break;\n    }\n\n    this.emit(SlpStreamEvent.COMMAND, {\n      command: command,\n      payload: parsedPayload,\n    } as SlpCommandEventPayload);\n    return payloadSize;\n  }\n}\n\nconst processReceiveCommands = (dataView: DataView): MessageSizes => {\n  const payloadSizes = new Map<Command, number>();\n  const payloadLen = dataView.getUint8(0);\n  for (let i = 1; i < payloadLen; i += 3) {\n    const commandByte = dataView.getUint8(i);\n    const payloadSize = dataView.getUint16(i + 1);\n    payloadSizes.set(commandByte, payloadSize);\n  }\n  return payloadSizes;\n};\n","import { EventEmitter } from \"events\";\nimport _ from \"lodash\";\nimport semver from \"semver\";\n\nimport type {\n  FrameBookendType,\n  FrameEntryType,\n  FramesType,\n  GameEndType,\n  GameStartType,\n  ItemUpdateType,\n  PostFrameUpdateType,\n  PreFrameUpdateType,\n  RollbackFrames,\n} from \"../types\";\nimport { Command, Frames, GameMode } from \"../types\";\nimport { RollbackCounter } from \"./rollbackCounter\";\n\nexport const MAX_ROLLBACK_FRAMES = 7;\n\nexport enum SlpParserEvent {\n  SETTINGS = \"settings\",\n  END = \"end\",\n  FRAME = \"frame\", // Emitted for every frame\n  FINALIZED_FRAME = \"finalized-frame\", // Emitted for only finalized frames\n  ROLLBACK_FRAME = \"rollback-frame\", // Emitted if a frame is being replaced\n}\n\n// If strict mode is on, we will do strict validation checking\n// which could throw errors on invalid data.\n// Default to false though since probably only real time applications\n// would care about valid data.\nconst defaultSlpParserOptions = {\n  strict: false,\n};\n\nexport type SlpParserOptions = typeof defaultSlpParserOptions;\n\nexport class SlpParser extends EventEmitter {\n  private frames: FramesType = {};\n  private rollbackCounter: RollbackCounter = new RollbackCounter();\n  private settings: GameStartType | null = null;\n  private gameEnd: GameEndType | null = null;\n  private latestFrameIndex: number | null = null;\n  private settingsComplete = false;\n  private lastFinalizedFrame = Frames.FIRST - 1;\n  private options: SlpParserOptions;\n\n  public constructor(options?: Partial<SlpParserOptions>) {\n    super();\n    this.options = Object.assign({}, defaultSlpParserOptions, options);\n  }\n\n  public handleCommand(command: Command, payload: any): void {\n    switch (command) {\n      case Command.GAME_START:\n        this._handleGameStart(payload as GameStartType);\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // We need to handle the post frame update first since that\n        // will finalize the settings object, before we fire the frame update\n        this._handlePostFrameUpdate(payload as PostFrameUpdateType);\n        this._handleFrameUpdate(command, payload as PostFrameUpdateType);\n        break;\n      case Command.PRE_FRAME_UPDATE:\n        this._handleFrameUpdate(command, payload as PreFrameUpdateType);\n        break;\n      case Command.ITEM_UPDATE:\n        this._handleItemUpdate(payload as ItemUpdateType);\n        break;\n      case Command.FRAME_BOOKEND:\n        this._handleFrameBookend(payload as FrameBookendType);\n        break;\n      case Command.GAME_END:\n        this._handleGameEnd(payload as GameEndType);\n        break;\n    }\n  }\n\n  // Resets the parser state to their default values.\n  public reset(): void {\n    this.frames = {};\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = Frames.FIRST - 1;\n  }\n\n  public getLatestFrameNumber(): number {\n    return this.latestFrameIndex ?? Frames.FIRST - 1;\n  }\n\n  public getPlayableFrameCount(): number {\n    if (this.latestFrameIndex === null) {\n      return 0;\n    }\n    return Math.max(0, this.latestFrameIndex - Frames.FIRST_PLAYABLE);\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    // return this.playerFrames[this.latestFrameIndex];\n\n    // TODO: Modify this to check if we actually have all the latest frame data and return that\n    // TODO: If we do. For now I'm just going to take a shortcut\n    const allFrames = this.getFrames();\n    const frameIndex = this.latestFrameIndex !== null ? this.latestFrameIndex : Frames.FIRST;\n    const indexToUse = this.gameEnd ? frameIndex : frameIndex - 1;\n    return _.get(allFrames, indexToUse) || null;\n  }\n\n  public getSettings(): GameStartType | null {\n    return this.settingsComplete ? this.settings : null;\n  }\n\n  public getGameEnd(): GameEndType | null {\n    return this.gameEnd;\n  }\n\n  public getFrames(): FramesType {\n    return this.frames;\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    return {\n      frames: this.rollbackCounter.getFrames(),\n      count: this.rollbackCounter.getCount(),\n      lengths: this.rollbackCounter.getLengths(),\n    };\n  }\n\n  public getFrame(num: number): FrameEntryType | null {\n    return this.frames[num] || null;\n  }\n\n  private _handleGameEnd(payload: GameEndType): void {\n    // Finalize remaining frames if necessary\n    if (this.latestFrameIndex !== null && this.latestFrameIndex !== this.lastFinalizedFrame) {\n      this._finalizeFrames(this.latestFrameIndex);\n    }\n\n    payload = payload as GameEndType;\n    this.gameEnd = payload;\n    this.emit(SlpParserEvent.END, this.gameEnd);\n  }\n\n  private _handleGameStart(payload: GameStartType): void {\n    this.settings = payload;\n    const players = payload.players;\n    this.settings.players = players.filter((player) => player.type !== 3);\n\n    // Check to see if the file was created after the sheik fix so we know\n    // we don't have to process the first frame of the game for the full settings\n    if (payload.slpVersion && semver.gte(payload.slpVersion, \"1.6.0\")) {\n      this._completeSettings();\n    }\n  }\n\n  private _handlePostFrameUpdate(payload: PostFrameUpdateType): void {\n    if (this.settingsComplete) {\n      return;\n    }\n\n    // Finish calculating settings\n    if (payload.frame! <= Frames.FIRST) {\n      const playerIndex = payload.playerIndex!;\n      const playersByIndex = _.keyBy(this.settings!.players, \"playerIndex\");\n\n      switch (payload.internalCharacterId) {\n        case 0x7:\n          playersByIndex[playerIndex]!.characterId = 0x13; // Sheik\n          break;\n        case 0x13:\n          playersByIndex[playerIndex]!.characterId = 0x12; // Zelda\n          break;\n      }\n    }\n    if (payload.frame! > Frames.FIRST) {\n      this._completeSettings();\n    }\n  }\n\n  private _handleFrameUpdate(command: Command, payload: PreFrameUpdateType | PostFrameUpdateType): void {\n    payload = payload as PostFrameUpdateType;\n    const location = command === Command.PRE_FRAME_UPDATE ? \"pre\" : \"post\";\n    const field = payload.isFollower ? \"followers\" : \"players\";\n    const currentFrameNumber = payload.frame!;\n    this.latestFrameIndex = currentFrameNumber;\n    if (location === \"pre\" && !payload.isFollower) {\n      const currentFrame = this.frames[currentFrameNumber];\n      const wasRolledback = this.rollbackCounter.checkIfRollbackFrame(currentFrame, payload.playerIndex!);\n      if (wasRolledback) {\n        // frame is about to be overwritten\n        this.emit(SlpParserEvent.ROLLBACK_FRAME, currentFrame);\n      }\n    }\n    _.set(this.frames, [currentFrameNumber, field, payload.playerIndex!, location], payload);\n    _.set(this.frames, [currentFrameNumber, \"frame\"], currentFrameNumber);\n\n    // If file is from before frame bookending, add frame to stats computer here. Does a little\n    // more processing than necessary, but it works\n    const settings = this.getSettings();\n    if (settings && (!settings.slpVersion || semver.lte(settings.slpVersion, \"2.2.0\"))) {\n      this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n      // Finalize the previous frame since no bookending exists\n      this._finalizeFrames(currentFrameNumber - 1);\n    } else {\n      _.set(this.frames, [currentFrameNumber, \"isTransferComplete\"], false);\n    }\n  }\n\n  private _handleItemUpdate(payload: ItemUpdateType): void {\n    const currentFrameNumber = payload.frame!;\n    const items = this.frames[currentFrameNumber]?.items ?? [];\n    items.push(payload);\n\n    // Set items with newest\n    _.set(this.frames, [currentFrameNumber, \"items\"], items);\n  }\n\n  private _handleFrameBookend(payload: FrameBookendType): void {\n    const latestFinalizedFrame = payload.latestFinalizedFrame!;\n    const currentFrameNumber = payload.frame!;\n    _.set(this.frames, [currentFrameNumber, \"isTransferComplete\"], true);\n    // Fire off a normal frame event\n    this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n\n    // Finalize frames if necessary\n    const validLatestFrame = this.settings!.gameMode === GameMode.ONLINE;\n    if (validLatestFrame && latestFinalizedFrame >= Frames.FIRST) {\n      // Ensure valid latestFinalizedFrame\n      if (this.options.strict && latestFinalizedFrame < currentFrameNumber - MAX_ROLLBACK_FRAMES) {\n        throw new Error(`latestFinalizedFrame should be within ${MAX_ROLLBACK_FRAMES} frames of ${currentFrameNumber}`);\n      }\n      this._finalizeFrames(latestFinalizedFrame);\n    } else {\n      // Since we don't have a valid finalized frame, just finalize the frame based on MAX_ROLLBACK_FRAMES\n      this._finalizeFrames(currentFrameNumber - MAX_ROLLBACK_FRAMES);\n    }\n  }\n\n  /**\n   * Fires off the FINALIZED_FRAME event for frames up until a certain number\n   * @param num The frame to finalize until\n   */\n  private _finalizeFrames(num: number): void {\n    while (this.lastFinalizedFrame < num) {\n      const frameToFinalize = this.lastFinalizedFrame + 1;\n      const frame = this.getFrame(frameToFinalize)!;\n\n      // Check that we have all the pre and post frame data for all players if we're in strict mode\n      if (this.options.strict) {\n        for (const player of this.settings!.players) {\n          const playerFrameInfo = frame.players[player.playerIndex];\n          // Allow player frame info to be empty in non 1v1 games since\n          // players which have been defeated will have no frame info.\n          if (this.settings!.players.length > 2 && !playerFrameInfo) {\n            continue;\n          }\n\n          const { pre, post } = playerFrameInfo!;\n          if (!pre || !post) {\n            const preOrPost = pre ? \"pre\" : \"post\";\n            throw new Error(\n              `Could not finalize frame ${frameToFinalize} of ${num}: missing ${preOrPost}-frame update for player ${player.playerIndex}`,\n            );\n          }\n        }\n      }\n\n      // Our frame is complete so finalize the frame\n      this.emit(SlpParserEvent.FINALIZED_FRAME, frame);\n      this.lastFinalizedFrame = frameToFinalize;\n    }\n  }\n\n  private _completeSettings(): void {\n    if (!this.settingsComplete) {\n      this.settingsComplete = true;\n      this.emit(SlpParserEvent.SETTINGS, this.settings);\n    }\n  }\n}\n","import { forEach } from \"lodash\";\nimport type { Moment } from \"moment\";\nimport moment from \"moment\";\nimport { Writable } from \"stream\";\n\nimport type { GameStartType, PostFrameUpdateType } from \"../types\";\nimport { Command } from \"../types\";\nimport type { SlpCommandEventPayload } from \"./slpStream\";\nimport { SlpStream, SlpStreamEvent, SlpStreamMode } from \"./slpStream\";\n\nconst DEFAULT_NICKNAME = \"unknown\";\n\nexport interface SlpFileMetadata {\n  startTime: Moment;\n  lastFrame: number;\n  players: {\n    [playerIndex: number]: {\n      characterUsage: {\n        [internalCharacterId: number]: number;\n      };\n      names: {\n        netplay: string;\n        code: string;\n      };\n    };\n  };\n  consoleNickname?: string;\n}\n\n/**\n * SlpFile is a class that wraps a Writable stream. It handles the writing of the binary\n * header and footer, and also handles the overwriting of the raw data length.\n *\n * @class SlpFile\n * @extends {Writable}\n */\nexport class SlpFile extends Writable {\n  private filePath: string;\n  private metadata: SlpFileMetadata;\n  private slpStream: SlpStream;\n  private usesExternalStream = false;\n\n  /**\n   * Creates an instance of SlpFile.\n   * @param {string} filePath The file location to write to.\n   * @param {any} [opts] Options for writing.\n   * @memberof SlpFile\n   */\n  public constructor(filePath: string, slpStream?: SlpStream, opts?: any) {\n    super(opts);\n    this.filePath = filePath;\n    this.metadata = {\n      consoleNickname: DEFAULT_NICKNAME,\n      startTime: moment(),\n      lastFrame: -124,\n      players: {},\n    };\n    this.usesExternalStream = Boolean(slpStream);\n\n    // Create a new SlpStream if one wasn't already provided\n    // This SLP stream represents a single game not multiple, so use manual mode\n    this.slpStream = slpStream ? slpStream : new SlpStream({ mode: SlpStreamMode.MANUAL });\n\n    this._setupListeners();\n  }\n\n  /**\n   * Get the current file path being written to.\n   *\n   * @returns {string} The location of the current file path\n   * @memberof SlpFile\n   */\n  public path(): string {\n    return this.filePath;\n  }\n\n  /**\n   * Sets the metadata of the Slippi file, such as consoleNickname, lastFrame, and players.\n   * @param metadata The metadata to be written\n   */\n  public setMetadata(metadata: Partial<SlpFileMetadata>): void {\n    this.metadata = Object.assign({}, this.metadata, metadata);\n  }\n\n  public _write(chunk: Uint8Array, encoding: string, callback: (error?: Error | null) => void): void {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    }\n    // Parse the data manually if it's an internal stream\n    if (!this.usesExternalStream) {\n      this.slpStream.write(chunk);\n    }\n\n    // Keep track of the bytes we've written\n    callback();\n  }\n\n  /**\n   * Here we define what to do on each command. We need to populate the metadata field\n   * so we keep track of the latest frame, as well as the number of frames each character has\n   * been used.\n   *\n   * @param data The parsed data from a SlpStream\n   */\n  private _onCommand(data: SlpCommandEventPayload): void {\n    const { command, payload } = data;\n    switch (command) {\n      case Command.GAME_START:\n        const { players } = payload as GameStartType;\n        forEach(players, (player, i) => {\n          if (player.type === 3) {\n            return;\n          }\n\n          this.metadata.players[i] = {\n            characterUsage: {},\n            names: {\n              netplay: player.displayName,\n              code: player.connectCode,\n            },\n          };\n        });\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // Here we need to update some metadata fields\n        const { frame, playerIndex, isFollower, internalCharacterId } = payload as PostFrameUpdateType;\n        if (isFollower) {\n          // No need to do this for follower\n          break;\n        }\n\n        // Update frame index\n        this.metadata.lastFrame = frame!;\n\n        // Update character usage\n        const prevPlayer = this.metadata.players[playerIndex!];\n        const characterUsage = prevPlayer!.characterUsage;\n        const curCharFrames = characterUsage[internalCharacterId!] || 0;\n        const player = {\n          ...prevPlayer,\n          characterUsage: {\n            ...characterUsage,\n            [internalCharacterId!]: curCharFrames + 1,\n          },\n        };\n        (this.metadata.players as any)[playerIndex!] = player;\n        break;\n    }\n  }\n\n  private _setupListeners(): void {\n    const streamListener = (data: SlpCommandEventPayload): void => {\n      this._onCommand(data);\n    };\n    this.slpStream.on(SlpStreamEvent.COMMAND, streamListener);\n\n    this.on(\"finish\", () => {\n      // Update file with bytes written\n      // Unsubscribe from the stream\n      this.slpStream.removeListener(SlpStreamEvent.COMMAND, streamListener);\n      // Terminate the internal stream\n      if (!this.usesExternalStream) {\n        this.slpStream.end();\n      }\n    });\n  }\n\n  public _final(): void {\n    let footer = Buffer.concat([Buffer.from(\"U\"), Buffer.from([8]), Buffer.from(\"metadata{\")]);\n\n    // Write game start time\n    const startTimeStr = this.metadata.startTime.toISOString();\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([7]),\n      Buffer.from(\"startAtSU\"),\n      Buffer.from([startTimeStr.length]),\n      Buffer.from(startTimeStr),\n    ]);\n\n    // Write last frame index\n    // TODO: Get last frame\n    const lastFrame = this.metadata.lastFrame;\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([9]),\n      Buffer.from(\"lastFramel\"),\n      createInt32Buffer(lastFrame),\n    ]);\n\n    // write the Console Nickname\n    const consoleNick = this.metadata.consoleNickname || DEFAULT_NICKNAME;\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([11]),\n      Buffer.from(\"consoleNickSU\"),\n      Buffer.from([consoleNick.length]),\n      Buffer.from(consoleNick),\n    ]);\n\n    // Start writting player specific data\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([7]), Buffer.from(\"players{\")]);\n    const players = this.metadata.players;\n    forEach(players, (player, index) => {\n      // Start player obj with index being the player index\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([index.length]), Buffer.from(`${index}{`)]);\n\n      // Start characters key for this player\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([10]), Buffer.from(\"characters{\")]);\n\n      // Write character usage\n      forEach(player.characterUsage, (usage, internalId) => {\n        // Write this character\n        footer = Buffer.concat([\n          footer,\n          Buffer.from(\"U\"),\n          Buffer.from([internalId.length]),\n          Buffer.from(`${internalId}l`),\n          createUInt32Buffer(usage),\n        ]);\n      });\n\n      // Close characters\n      footer = Buffer.concat([footer, Buffer.from(\"}\")]);\n\n      // Start names key for this player\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([5]), Buffer.from(\"names{\")]);\n\n      // Write display name\n      footer = Buffer.concat([\n        footer,\n        Buffer.from(\"U\"),\n        Buffer.from([7]),\n        Buffer.from(\"netplaySU\"),\n        Buffer.from([player.names.netplay.length]),\n        Buffer.from(`${player.names.netplay}`),\n      ]);\n\n      // Write connect code\n      footer = Buffer.concat([\n        footer,\n        Buffer.from(\"U\"),\n        Buffer.from([4]),\n        Buffer.from(\"codeSU\"),\n        Buffer.from([player.names.code.length]),\n        Buffer.from(`${player.names.code}`),\n      ]);\n\n      // Close names and player\n      footer = Buffer.concat([footer, Buffer.from(\"}}\")]);\n    });\n\n    // Close players\n    footer = Buffer.concat([footer, Buffer.from(\"}\")]);\n\n    // Write played on\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([8]),\n      Buffer.from(\"playedOnSU\"),\n      Buffer.from([7]),\n      Buffer.from(\"network\"),\n    ]);\n\n    // Close metadata and file\n    footer = Buffer.concat([footer, Buffer.from(\"}}\")]);\n  }\n}\n\nconst createInt32Buffer = (number: number): Buffer => {\n  const buf = Buffer.alloc(4);\n  buf.writeInt32BE(number, 0);\n  return buf;\n};\n\nconst createUInt32Buffer = (number: number): Buffer => {\n  const buf = Buffer.alloc(4);\n  buf.writeUInt32BE(number, 0);\n  return buf;\n};\n","import type { FrameEntryType, RollbackFramesType } from \"../types\";\n\nexport class RollbackCounter {\n  private rollbackFrames: RollbackFramesType = {};\n  private rollbackFrameCount = 0;\n  private rollbackPlayerIdx: number | null = null; // for keeping track of rollbacks by following a single player\n  private lastFrameWasRollback = false;\n  private currentRollbackLength = 0;\n  private rollbackLengths: number[] = [];\n\n  public checkIfRollbackFrame(currentFrame: FrameEntryType | undefined, playerIdx: number) {\n    if (this.rollbackPlayerIdx === null) {\n      // we only want to follow a single player to avoid double counting. So we use whoever is on first.\n      this.rollbackPlayerIdx = playerIdx;\n    } else if (this.rollbackPlayerIdx !== playerIdx) {\n      return;\n    }\n\n    if (currentFrame) {\n      // frame already exists for currentFrameNumber so we must be rolling back\n      if (this.rollbackFrames[currentFrame.frame]) {\n        this.rollbackFrames[currentFrame.frame]!.push(currentFrame);\n      } else {\n        this.rollbackFrames[currentFrame.frame] = [currentFrame];\n      }\n      this.rollbackFrameCount++;\n      this.currentRollbackLength++;\n      this.lastFrameWasRollback = true;\n    } else if (this.lastFrameWasRollback) {\n      this.rollbackLengths.push(this.currentRollbackLength);\n      this.currentRollbackLength = 0;\n      this.lastFrameWasRollback = false;\n    }\n    return this.lastFrameWasRollback;\n  }\n\n  public getFrames() {\n    return this.rollbackFrames;\n  }\n\n  public getCount() {\n    return this.rollbackFrameCount;\n  }\n\n  public getLengths() {\n    return this.rollbackLengths;\n  }\n}\n","import type { StatOptions, StatsType } from \"./stats\";\nimport {\n  ActionsComputer,\n  ComboComputer,\n  ConversionComputer,\n  generateOverallStats,\n  InputComputer,\n  Stats,\n  StockComputer,\n} from \"./stats\";\nimport type { FrameEntryType, FramesType, GameEndType, GameStartType, MetadataType, RollbackFrames } from \"./types\";\nimport { SlpParser, SlpParserEvent } from \"./utils/slpParser\";\nimport { getInput, getMetadata, iterateEvents, openSlpFile, SlpInputSource } from \"./reading\";\nimport type { SlpReadInput } from \"./reading/slpReader\";\n\n/**\n * Slippi Game class that wraps a file\n */\nexport class SlippiGame {\n  private input: SlpReadInput;\n  private metadata: MetadataType | null = null;\n  private finalStats: StatsType | null = null;\n  private parser: SlpParser;\n  private readPosition: number | null = null;\n  private actionsComputer: ActionsComputer = new ActionsComputer();\n  private conversionComputer: ConversionComputer = new ConversionComputer();\n  private comboComputer: ComboComputer = new ComboComputer();\n  private stockComputer: StockComputer = new StockComputer();\n  private inputComputer: InputComputer = new InputComputer();\n  protected statsComputer: Stats;\n\n  public constructor(input: string | ArrayBuffer | Uint8Array, opts?: StatOptions) {\n    this.input = getInput(input);\n\n    // Set up stats calculation\n    this.statsComputer = new Stats(opts);\n    this.statsComputer.register(\n      this.actionsComputer,\n      this.comboComputer,\n      this.conversionComputer,\n      this.inputComputer,\n      this.stockComputer,\n    );\n    this.parser = new SlpParser();\n    this.parser.on(SlpParserEvent.SETTINGS, (settings) => {\n      this.statsComputer.setup(settings);\n    });\n    // Use finalized frames for stats computation\n    this.parser.on(SlpParserEvent.FINALIZED_FRAME, (frame: FrameEntryType) => {\n      this.statsComputer.addFrame(frame);\n    });\n  }\n\n  private _process(settingsOnly = false): void {\n    if (this.parser.getGameEnd() !== null) {\n      return;\n    }\n    const slpfile = openSlpFile(this.input);\n    this.readPosition = iterateEvents(\n      slpfile,\n      (command, payload) => {\n        if (!payload) {\n          // If payload is falsy, keep iterating. The parser probably just doesn't know\n          // about this command yet\n          return false;\n        }\n        this.parser.handleCommand(command, payload);\n        return settingsOnly && this.parser.getSettings() !== null;\n      },\n      this.readPosition,\n    );\n  }\n\n  /**\n   * Gets the game settings, these are the settings that describe the starting state of\n   * the game such as characters, stage, etc.\n   */\n  public getSettings(): GameStartType | null {\n    // Settings is only complete after post-frame update\n    this._process(true);\n    return this.parser.getSettings();\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    this._process();\n    return this.parser.getLatestFrame();\n  }\n\n  public getGameEnd(): GameEndType | null {\n    this._process();\n    return this.parser.getGameEnd();\n  }\n\n  public getFrames(): FramesType {\n    this._process();\n    return this.parser.getFrames();\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    this._process();\n    return this.parser.getRollbackFrames();\n  }\n\n  public getStats(): StatsType | null {\n    if (this.finalStats) {\n      return this.finalStats;\n    }\n\n    this._process();\n\n    const settings = this.parser.getSettings();\n    if (settings === null) {\n      return null;\n    }\n\n    // Finish processing if we're not up to date\n    this.statsComputer.process();\n    const inputs = this.inputComputer.fetch();\n    const stocks = this.stockComputer.fetch();\n    const conversions = this.conversionComputer.fetch();\n    const playableFrameCount = this.parser.getPlayableFrameCount();\n    const overall = generateOverallStats({ settings, inputs, conversions, playableFrameCount });\n\n    const stats = {\n      lastFrame: this.parser.getLatestFrameNumber(),\n      playableFrameCount,\n      stocks,\n      conversions,\n      combos: this.comboComputer.fetch(),\n      actionCounts: this.actionsComputer.fetch(),\n      overall,\n      gameComplete: this.parser.getGameEnd() !== null,\n      settings,\n      inputs,\n    };\n\n    if (this.parser.getGameEnd() !== null) {\n      // If the game is complete, store a cached version of stats because it should not\n      // change anymore. Ideally the statsCompuer.process and fetch functions would simply do no\n      // work in this case instead but currently the conversions fetch function,\n      // generateOverallStats, and maybe more are doing work on every call.\n      this.finalStats = stats;\n    }\n\n    return stats;\n  }\n\n  public getMetadata(): MetadataType | null {\n    if (this.metadata) {\n      return this.metadata;\n    }\n    this.metadata = getMetadata(this.input);\n    return this.metadata;\n  }\n\n  public getFilePath(): string | null {\n    if (this.input.source !== SlpInputSource.FILE) {\n      return null;\n    }\n\n    return this.input.filePath ?? null;\n  }\n}\n","import { SlpInputSource } from \"../reading/slpReader\";\nexport * from \"./metadata\";\nexport * from \"./slpReader\";\n\nexport const getInput = (input: string | ArrayBuffer | Uint8Array) => {\n  if (typeof input === \"string\")\n    return {\n      source: SlpInputSource.FILE,\n      filePath: input,\n    };\n  if (input instanceof ArrayBuffer)\n    return {\n      source: SlpInputSource.BUFFER,\n      buffer: new Uint8Array(input),\n    };\n  if (input instanceof Uint8Array)\n    return {\n      source: SlpInputSource.BUFFER,\n      buffer: input,\n    };\n  throw new Error(\"Cannot create SlippiGame with input of that type\");\n};\n","import { decode } from \"@shelacek/ubjson\";\nimport { getRef, readRef, getLenRef } from \"./browserReading\";\nimport type { MetadataType } from \"../types\";\nimport type { SlpRefType, SlpReadInput } from \"./browserReading\";\n\n// This function gets the position where the raw data starts\nfunction getRawDataPosition(ref: SlpRefType): number {\n  const buffer = readRef(ref, 1, 0);\n\n  if (buffer[0] !== \"{\".charCodeAt(0)) {\n    return 0; // return error?\n  }\n\n  return 15;\n}\n\nfunction getRawDataLength(ref: SlpRefType, position: number): number {\n  const fileSize = getLenRef(ref);\n  if (position === 0) {\n    return fileSize;\n  }\n\n  const buffer = readRef(ref, 4, position - 4);\n\n  const rawDataLen = (buffer[0]! << 24) | (buffer[1]! << 16) | (buffer[2]! << 8) | buffer[3]!;\n  if (rawDataLen > 0) {\n    // If this method manages to read a number, it's probably trustworthy\n    return rawDataLen;\n  }\n\n  // If the above does not return a valid data length, return a file size\n  // based on file length. This enables some support for severed files\n  return fileSize - position;\n}\n\nexport function getMetadata(input: SlpReadInput): MetadataType | null {\n  const ref = getRef(input);\n  const rawDataPosition = getRawDataPosition(ref);\n  const rawDataLength = getRawDataLength(ref, rawDataPosition);\n  const metadataPosition = rawDataPosition + rawDataLength + 10; // remove metadata string\n  const metadataLength = getLenRef(ref) - metadataPosition - 1;\n\n  if (metadataLength <= 0) {\n    // This will happen on a severed incomplete file\n    return null;\n  }\n  const buffer = readRef(ref, metadataLength, metadataPosition);\n\n  try {\n    const metadata = decode(buffer);\n    return metadata;\n  } catch (ex) {\n    return null;\n  }\n}\n"],"names":["reader","FileReaderSync","processGame","file","result","readAsArrayBuffer","game","SlippiGame","Uint8Array","metadata","getMetadata","lastFrame","Object","keys","players","length","names","netplay","code","invalidMetadata","stats","getStats","settings","stocks","inputs","is_teams","stageId","includes","gameMode","p0_deaths","filter","s","playerIndex","endFrame","p1_deaths","player_0_airborne","airborne","player_1_airborne","e","invalidStats","self","onmessage","data","postMessage","Character","Stage","UnknownCharacter","id","name","shortName","colors","externalCharacters","getCharacterInfo","externalCharacterId","characterColor","UnknownMove","moves","getMoveInfo","moveId","UnknownStage","stages","getStageInfo","State","Timers","PUNISH_RESET_FRAMES","RECOVERY_RESET_FRAMES","COMBO_STRING_RESET_FRAMES","getSinglesPlayerPermutationsFromSettings","opponentIndex","frame","prevFrame","stocksRemaining","isInControl","state","ground","squat","groundAttack","isGrab","isTeching","isDown","isDamaged","isGrabbed","isCommandGrabbed","isDead","percent","ComboEvent","Command","GameMode","Frames","JoystickRegion","dashDanceAnimations","ActionsComputer","constructor","this","playerPermutations","Array","Map","setup","forEach","indices","set","playerCounts","wavedashCount","wavelandCount","airDodgeCount","dashDanceCount","spotDodgeCount","ledgegrabCount","rollCount","lCancelCount","success","fail","grabCount","throwCount","up","forward","back","down","groundTechCount","away","in","neutral","wallTechCount","animations","processFrame","get","playerFrame","post","opponentFrame","incrementCount","field","condition","current","currentAnimation","actionStateId","push","last3Frames","slice","prevAnimation","newAnimation","isEqual","didRoll","previousAnimation","isCurrentlyRolling","isRolling","wasPreviouslyRolling","didSpotDodge","isCurrentlyDodging","isSpotDodging","wasPreviouslyDodging","didAirDodge","isAirDodging","didGrabLedge","isCurrentlyGrabbingLedge","isGrabbingLedge","wasPreviouslyGrabbingLedge","didGrabSucceed","animation","didGrabFail","opponentDir","facingOpponent","positionX","facingDirection","lCancelStatus","counts","isSpecialLanding","last","isAcceptablePrevious","isAboveMin","isBelowMax","recentFrames","recentAnimations","keyBy","size","fetch","from","values","map","val","ComboComputer","args","super","combos","combo","move","resetCounter","lastHitAnimation","event","allFrames","frames","currentFrameNumber","prevFrameNumber","prevPlayerFrame","prevOpponentFrame","oppActionStateId","opntIsDamaged","opntIsGrabbed","opntIsCommandGrabbed","opntDamageTaken","calcDamageTaken","actionStateCounter","comboStarted","startFrame","startPercent","_prevOpponentFrame$pe","currentPercent","endPercent","didKill","lastHitBy","lastAttackLanded","hitCount","damage","COMBO_EXTEND","COMBO_START","opntIsTeching","opntIsDowned","opntDidLoseStock","didLoseStock","opntIsDying","shouldTerminate","_prevOpponentFrame$pe2","COMBO_END","emit","EventEmitter","ConversionComputer","conversions","lastEndFrameByOppIdx","conversion","terminated","openingType","opntInControl","_populateConversionTypes","conversionsToHandle","groupedConversions","groupBy","orderBy","isTrade","lastMove","oppEndFrame","InputComputer","inputCount","joystickInputCount","cstickInputCount","buttonInputCount","triggerInputCount","pre","invertedPreviousButtons","physicalButtons","currentButtons","pressing_start","isAirborne","newInputsPressed","x","count","bits","prevAnalogRegion","getJoystickRegion","joystickX","joystickY","currentAnalogRegion","DZ","prevCstickRegion","cStickX","cStickY","currentCstickRegion","physicalLTrigger","physicalRTrigger","y","region","NE","SE","SW","NW","N","E","S","W","generateOverallStats","playableFrameCount","inputsByPlayer","originalConversions","conversionsByPlayer","conv","_conv$moves$","conversionsByPlayerByOpening","mapValues","gameMinutes","player","playerInputs","inputCounts","buttons","triggers","cstick","joystick","total","conversionCount","successfulConversionCount","opponentIndices","opp","isTeams","teamId","totalDamage","killCount","successfulConversions","getRatio","inputsPerMinute","digitalInputsPerMinute","openingsPerKill","damagePerOpening","neutralWinRatio","getOpeningRatio","counterHitRatio","beneficialTradeRatio","getBeneficialTradeRatio","ratio","type","openings","opponentOpenings","flatten","playerTrades","opponentTrades","benefitsPlayer","zip","conversionPair","playerConversion","first","opponentConversion","playerDamage","opponentDamage","defaultOptions","processOnTheFly","Stats","options","lastProcessedFrame","allComputers","assign","v","comp","register","computer","process","i","isCompletedFrame","addFrame","SlpInputSource","StockComputer","stock","deathAnimation","toHalfwidth","str","ret","_","char","convertChar","charCode","charCodeAt","String","fromCharCode","getRef","input","source","BUFFER","buffer","Error","readRef","ref","position","getLenRef","SlpStreamMode","decodeBuf","buf","convert","to","split","shift","command","payload","sliced_buffer","byteOffset","byteLength","view","DataView","slpVersion","readUint8","readBool","isPAL","readUint16","cfOffset","dashback","readUint32","cfOption","nametagStart","nametagBuf","nameTagString","nametag","displayNameStart","displayNameBuf","displayNameString","displayName","connectCodeStart","connectCodeBuf","connectCodeString","connectCode","offset","port","characterId","startStocks","controllerFix","scene","readInt32","isFollower","seed","readFloat","positionY","trigger","selfInducedSpeeds","airX","attackX","attackY","groundX","internalCharacterId","shieldSize","currentComboCount","miscActionState","lastGroundId","jumpsRemaining","hurtboxCollisionState","typeId","velocityX","velocityY","damageTaken","expirationTimer","spawnId","missileType","turnipFace","chargeShotLaunched","chargePower","owner","readInt8","latestFinalizedFrame","gameEndMethod","lrasInitiatorIndex","canReadFromView","getFloat32","getInt32","getInt8","getUint32","getUint16","getUint8","SlpStreamEvent","defaultSettings","suppressErrors","mode","AUTO","SlpParserEvent","SlpStream","slpOptions","opts","gameEnded","payloadSizes","previousBuffer","Buffer","restart","_write","newData","encoding","callback","concat","dataView","index","toString","payloadSize","MANUAL","payloadPtr","payloadDataView","payloadLen","_processCommand","err","_writeCommand","entirePayload","payloadBuf","bufToWrite","RAW","processReceiveCommands","COMMAND","parsedPayload","parseMessage","Writable","commandByte","createInt32Buffer","number","alloc","writeInt32BE","createUInt32Buffer","writeUInt32BE","RollbackCounter","rollbackFrames","rollbackFrameCount","rollbackPlayerIdx","lastFrameWasRollback","currentRollbackLength","rollbackLengths","checkIfRollbackFrame","currentFrame","playerIdx","getFrames","getCount","getLengths","SETTINGS","defaultSlpParserOptions","strict","SlpParser","rollbackCounter","gameEnd","latestFrameIndex","settingsComplete","lastFinalizedFrame","handleCommand","_handleGameStart","_handlePostFrameUpdate","_handleFrameUpdate","_handleItemUpdate","_handleFrameBookend","_handleGameEnd","reset","getLatestFrameNumber","getPlayableFrameCount","Math","max","getLatestFrame","frameIndex","default","getSettings","getGameEnd","getRollbackFrames","lengths","getFrame","num","_finalizeFrames","semver","gte","_completeSettings","playersByIndex","location","lte","items","_this$frames$currentF","frameToFinalize","playerFrameInfo","exports","finalStats","parser","readPosition","actionsComputer","conversionComputer","comboComputer","stockComputer","inputComputer","statsComputer","FILE","filePath","ArrayBuffer","on","_process","settingsOnly","slpfile","full_data","raw_data_position","rawDataPosition","rawDataLength","file_size","length_info","raw_data_len","messageSizes","message_metadata","payloadLength","message_sizes_buffer","slpFile","getShouldStop","startPos","stopReadingAt","message_size","overall","actionCounts","gameComplete","fileSize","rawDataLen","metadataPosition","metadataLength","decode","ex","getFilePath","_this$input$filePath"],"sourceRoot":""}