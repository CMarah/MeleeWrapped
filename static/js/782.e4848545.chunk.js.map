{"version":3,"file":"static/js/782.e4848545.chunk.js","mappings":"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","sources":["../../marahslp/src/stats/common.ts","../../marahslp/src/stats/actions.ts","../../marahslp/src/stats/combos.ts","../../marahslp/src/types.ts","../../marahslp/src/stats/inputs.ts","../../marahslp/src/stats/conversions.ts","../../marahslp/src/stats/overall.ts","../../marahslp/src/stats/stats.ts","../../marahslp/src/stats/stocks.ts","../../marahslp/src/utils/rollbackCounter.ts","../../marahslp/src/utils/slpParser.ts","../../marahslp/src/utils/slpReader.ts","../../marahslp/src/utils/fullwidth.ts","../../marahslp/src/SlippiGame.ts","lib/worker.js"],"sourcesContent":["import type { GameStartType, PostFrameUpdateType } from \"../types\";\n\nexport interface StatsType {\n  gameComplete: boolean;\n  lastFrame: number;\n  playableFrameCount: number;\n  stocks: StockType[];\n  conversions: ConversionType[];\n  combos: ComboType[];\n  actionCounts: ActionCountsType[];\n  overall: OverallType[];\n}\n\nexport interface RatioType {\n  count: number;\n  total: number;\n  ratio: number | null;\n}\n\nexport interface PlayerIndexedType {\n  playerIndex: number;\n  opponentIndex: number;\n}\n\nexport interface DurationType {\n  startFrame: number;\n  endFrame?: number | null;\n}\n\nexport interface DamageType {\n  startPercent: number;\n  currentPercent: number;\n  endPercent?: number | null;\n}\n\nexport interface StockType extends DurationType, DamageType {\n  playerIndex: number;\n  count: number;\n  deathAnimation?: number | null;\n}\n\nexport interface MoveLandedType {\n  playerIndex: number;\n  frame: number;\n  moveId: number;\n  hitCount: number;\n  damage: number;\n}\n\nexport interface ComboType extends DurationType, DamageType {\n  playerIndex: number;\n  moves: MoveLandedType[];\n  didKill: boolean;\n  lastHitBy: number | null;\n}\n\nexport interface ConversionType extends ComboType {\n  openingType: string;\n}\n\nexport interface ActionCountsType {\n  playerIndex: number;\n  wavedashCount: number;\n  wavelandCount: number;\n  airDodgeCount: number;\n  dashDanceCount: number;\n  spotDodgeCount: number;\n  ledgegrabCount: number;\n  rollCount: number;\n  lCancelCount: {\n    success: number;\n    fail: number;\n  };\n  grabCount: {\n    success: number;\n    fail: number;\n  };\n  throwCount: {\n    up: number;\n    forward: number;\n    back: number;\n    down: number;\n  };\n  groundTechCount: {\n    // tech away/in are in reference to the opponents position and not the stage\n    away: number;\n    in: number;\n    neutral: number;\n    fail: number;\n  };\n  wallTechCount: {\n    success: number;\n    fail: number;\n  };\n}\n\nexport interface InputCountsType {\n  buttons: number;\n  triggers: number;\n  joystick: number;\n  cstick: number;\n  total: number;\n}\n\nexport interface OverallType {\n  playerIndex: number;\n  inputCounts: InputCountsType;\n  conversionCount: number;\n  totalDamage: number;\n  killCount: number;\n  successfulConversions: RatioType;\n  inputsPerMinute: RatioType;\n  digitalInputsPerMinute: RatioType;\n  openingsPerKill: RatioType;\n  damagePerOpening: RatioType;\n  neutralWinRatio: RatioType;\n  counterHitRatio: RatioType;\n  beneficialTradeRatio: RatioType;\n}\n\nexport enum State {\n  // Animation ID ranges\n  DAMAGE_START = 0x4b,\n  DAMAGE_END = 0x5b,\n  CAPTURE_START = 0xdf,\n  CAPTURE_END = 0xe8,\n  GUARD_START = 0xb2,\n  GUARD_END = 0xb6,\n  GROUNDED_CONTROL_START = 0xe,\n  GROUNDED_CONTROL_END = 0x18,\n  SQUAT_START = 0x27,\n  SQUAT_END = 0x29,\n  DOWN_START = 0xb7,\n  DOWN_END = 0xc6,\n  TECH_START = 0xc7,\n  TECH_END = 0xcc,\n  DYING_START = 0x0,\n  DYING_END = 0xa,\n  CONTROLLED_JUMP_START = 0x18,\n  CONTROLLED_JUMP_END = 0x22,\n  GROUND_ATTACK_START = 0x2c,\n  GROUND_ATTACK_END = 0x40,\n  AERIAL_ATTACK_START = 0x41,\n  AERIAL_ATTACK_END = 0x4a,\n\n  // Animation ID specific\n  ROLL_FORWARD = 0xe9,\n  ROLL_BACKWARD = 0xea,\n  SPOT_DODGE = 0xeb,\n  AIR_DODGE = 0xec,\n  ACTION_WAIT = 0xe,\n  ACTION_DASH = 0x14,\n  ACTION_KNEE_BEND = 0x18,\n  GUARD_ON = 0xb2,\n  TECH_MISS_UP = 0xb7,\n  TECH_MISS_DOWN = 0xbf,\n  NEUTRAL_TECH = 0xc7,\n  FORWARD_TECH = 0xc8,\n  BACKWARD_TECH = 0xc9,\n  WALL_TECH = 0xca,\n  MISSED_WALL_TECH = 0xf7,\n  DASH = 0x14,\n  TURN = 0x12,\n  LANDING_FALL_SPECIAL = 0x2b,\n  JUMP_FORWARD = 0x19,\n  JUMP_BACKWARD = 0x1a,\n  FALL_FORWARD = 0x1e,\n  FALL_BACKWARD = 0x1f,\n  GRAB = 0xd4,\n  GRAB_WAIT = 0xd8,\n  PUMMEL = 0xd9,\n  CLIFF_CATCH = 0xfc,\n  THROW_UP = 0xdd,\n  THROW_FORWARD = 0xdb,\n  THROW_DOWN = 0xde,\n  THROW_BACK = 0xdc,\n  DAMAGE_FALL = 0x26,\n\n  // Command Grabs\n  BARREL_WAIT = 0x125,\n  COMMAND_GRAB_RANGE1_START = 0x10a,\n  COMMAND_GRAB_RANGE1_END = 0x130,\n\n  COMMAND_GRAB_RANGE2_START = 0x147,\n  COMMAND_GRAB_RANGE2_END = 0x152,\n}\n\nexport const Timers = {\n  PUNISH_RESET_FRAMES: 45,\n  RECOVERY_RESET_FRAMES: 45,\n  COMBO_STRING_RESET_FRAMES: 45,\n};\n\nexport function getSinglesPlayerPermutationsFromSettings(settings: GameStartType): PlayerIndexedType[] {\n  if (!settings || settings.players.length !== 2) {\n    // Only return opponent indices for singles\n    return [];\n  }\n\n  return [\n    {\n      playerIndex: settings.players[0]!.playerIndex,\n      opponentIndex: settings.players[1]!.playerIndex,\n    },\n    {\n      playerIndex: settings.players[1]!.playerIndex,\n      opponentIndex: settings.players[0]!.playerIndex,\n    },\n  ];\n}\n\nexport function didLoseStock(frame: PostFrameUpdateType, prevFrame: PostFrameUpdateType): boolean {\n  if (!frame || !prevFrame) {\n    return false;\n  }\n\n  return prevFrame.stocksRemaining! - frame.stocksRemaining! > 0;\n}\n\nexport function isInControl(state: number): boolean {\n  const ground = state >= State.GROUNDED_CONTROL_START && state <= State.GROUNDED_CONTROL_END;\n  const squat = state >= State.SQUAT_START && state <= State.SQUAT_END;\n  const groundAttack = state > State.GROUND_ATTACK_START && state <= State.GROUND_ATTACK_END;\n  const isGrab = state === State.GRAB;\n  // TODO: Add grounded b moves?\n  return ground || squat || groundAttack || isGrab;\n}\n\nexport function isTeching(state: number): boolean {\n  return state >= State.TECH_START && state <= State.TECH_END;\n}\n\nexport function isDown(state: number): boolean {\n  return state >= State.DOWN_START && state <= State.DOWN_END;\n}\n\nexport function isDamaged(state: number): boolean {\n  return (state >= State.DAMAGE_START && state <= State.DAMAGE_END) || state === State.DAMAGE_FALL;\n}\n\nexport function isGrabbed(state: number): boolean {\n  return state >= State.CAPTURE_START && state <= State.CAPTURE_END;\n}\n\n// TODO: Find better implementation of 3 seperate ranges\nexport function isCommandGrabbed(state: number): boolean {\n  return (\n    ((state >= State.COMMAND_GRAB_RANGE1_START && state <= State.COMMAND_GRAB_RANGE1_END) ||\n      (state >= State.COMMAND_GRAB_RANGE2_START && state <= State.COMMAND_GRAB_RANGE2_END)) &&\n    state !== State.BARREL_WAIT\n  );\n}\n\nexport function isDead(state: number): boolean {\n  return state >= State.DYING_START && state <= State.DYING_END;\n}\n\nexport function calcDamageTaken(frame: PostFrameUpdateType, prevFrame: PostFrameUpdateType): number {\n  const percent = frame.percent ?? 0;\n  const prevPercent = prevFrame.percent ?? 0;\n\n  return percent - prevPercent;\n}\n","import { get, isEqual, keyBy, last, set, size } from \"lodash\";\n\nimport type { FrameEntryType, GameStartType } from \"../types\";\nimport type { ActionCountsType, PlayerIndexedType } from \"./common\";\nimport { getSinglesPlayerPermutationsFromSettings, State } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\n// Frame pattern that indicates a dash dance turn was executed\nconst dashDanceAnimations = [State.DASH, State.TURN, State.DASH];\n\ninterface PlayerActionState {\n  playerCounts: ActionCountsType;\n  animations: number[];\n}\n\nexport class ActionsComputer implements StatComputer<ActionCountsType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, PlayerActionState>();\n\n  public setup(settings: GameStartType): void {\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach((indices) => {\n      const playerCounts: ActionCountsType = {\n        playerIndex: indices.playerIndex,\n        wavedashCount: 0,\n        wavelandCount: 0,\n        airDodgeCount: 0,\n        dashDanceCount: 0,\n        spotDodgeCount: 0,\n        ledgegrabCount: 0,\n        rollCount: 0,\n        lCancelCount: {\n          success: 0,\n          fail: 0,\n        },\n        grabCount: {\n          success: 0,\n          fail: 0,\n        },\n        throwCount: {\n          up: 0,\n          forward: 0,\n          back: 0,\n          down: 0,\n        },\n        groundTechCount: {\n          // tech away/in are in reference to the opponents position and not the stage\n          away: 0,\n          in: 0,\n          neutral: 0,\n          fail: 0,\n        },\n        wallTechCount: {\n          success: 0,\n          fail: 0,\n        },\n      };\n      const playerState: PlayerActionState = {\n        playerCounts: playerCounts,\n        animations: [],\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleActionCompute(state, indices, frame);\n      }\n    });\n  }\n\n  public fetch(): ActionCountsType[] {\n    return Array.from(this.state.values()).map((val) => val.playerCounts);\n  }\n}\n\nfunction didMissGroundTech(animation: State): boolean {\n  return animation === State.TECH_MISS_DOWN || animation === State.TECH_MISS_UP;\n}\n\nfunction isRolling(animation: State): boolean {\n  return animation === State.ROLL_BACKWARD || animation === State.ROLL_FORWARD;\n}\n\nfunction didStartRoll(currentAnimation: number, previousAnimation: number): boolean {\n  const isCurrentlyRolling = isRolling(currentAnimation);\n  const wasPreviouslyRolling = isRolling(previousAnimation);\n\n  return isCurrentlyRolling && !wasPreviouslyRolling;\n}\n\nfunction isSpotDodging(animation: State): boolean {\n  return animation === State.SPOT_DODGE;\n}\n\nfunction didStartGrabSuccess(currentAnimation: State, previousAnimation: State): boolean {\n  return previousAnimation === State.GRAB && currentAnimation <= State.GRAB_WAIT && currentAnimation > State.GRAB;\n}\nfunction didStartGrabFail(currentAnimation: State, previousAnimation: State): boolean {\n  return previousAnimation === State.GRAB && (currentAnimation > State.GRAB_WAIT || currentAnimation < State.GRAB);\n}\n\nfunction didStartSpotDodge(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyDodging = isSpotDodging(currentAnimation);\n  const wasPreviouslyDodging = isSpotDodging(previousAnimation);\n\n  return isCurrentlyDodging && !wasPreviouslyDodging;\n}\n\nfunction isAirDodging(animation: State): boolean {\n  return animation === State.AIR_DODGE;\n}\n\nfunction didStartAirDodge(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyDodging = isAirDodging(currentAnimation);\n  const wasPreviouslyDodging = isAirDodging(previousAnimation);\n\n  return isCurrentlyDodging && !wasPreviouslyDodging;\n}\n\nfunction isGrabbingLedge(animation: State): boolean {\n  return animation === State.CLIFF_CATCH;\n}\n\nfunction isAerialAttack(animation: State): boolean {\n  return animation >= State.AERIAL_ATTACK_START && animation <= State.AERIAL_ATTACK_END;\n}\n\nfunction didStartLedgegrab(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyGrabbingLedge = isGrabbingLedge(currentAnimation);\n  const wasPreviouslyGrabbingLedge = isGrabbingLedge(previousAnimation);\n\n  return isCurrentlyGrabbingLedge && !wasPreviouslyGrabbingLedge;\n}\n\nfunction handleActionCompute(state: PlayerActionState, indices: PlayerIndexedType, frame: FrameEntryType): void {\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n  const incrementCount = (field: string, condition: boolean): void => {\n    if (!condition) {\n      return;\n    }\n\n    const current: number = get(state.playerCounts, field, 0);\n    set(state.playerCounts, field, current + 1);\n  };\n\n  // Manage animation state\n  const currentAnimation = playerFrame.actionStateId!;\n  state.animations.push(currentAnimation);\n\n  // Grab last 3 frames\n  const last3Frames = state.animations.slice(-3);\n  const prevAnimation = last3Frames[last3Frames.length - 2] as number;\n  const newAnimation = currentAnimation !== prevAnimation;\n\n  // Increment counts based on conditions\n  const didDashDance = isEqual(last3Frames, dashDanceAnimations);\n  incrementCount(\"dashDanceCount\", didDashDance);\n\n  const didRoll = didStartRoll(currentAnimation, prevAnimation);\n  incrementCount(\"rollCount\", didRoll);\n\n  const didSpotDodge = didStartSpotDodge(currentAnimation, prevAnimation);\n  incrementCount(\"spotDodgeCount\", didSpotDodge);\n\n  const didAirDodge = didStartAirDodge(currentAnimation, prevAnimation);\n  incrementCount(\"airDodgeCount\", didAirDodge);\n\n  const didGrabLedge = didStartLedgegrab(currentAnimation, prevAnimation);\n  incrementCount(\"ledgegrabCount\", didGrabLedge);\n\n  const didGrabSucceed = didStartGrabSuccess(currentAnimation, prevAnimation);\n  incrementCount(\"grabCount.success\", didGrabSucceed);\n  const didGrabFail = didStartGrabFail(currentAnimation, prevAnimation);\n  incrementCount(\"grabCount.fail\", didGrabFail);\n\n  incrementCount(\"throwCount.up\", currentAnimation === State.THROW_UP && newAnimation);\n  incrementCount(\"throwCount.forward\", currentAnimation === State.THROW_FORWARD && newAnimation);\n  incrementCount(\"throwCount.down\", currentAnimation === State.THROW_DOWN && newAnimation);\n  incrementCount(\"throwCount.back\", currentAnimation === State.THROW_BACK && newAnimation);\n\n  if (newAnimation) {\n    const didMissTech = didMissGroundTech(currentAnimation);\n    incrementCount(\"groundTechCount.fail\", didMissTech);\n    let opponentDir = 1;\n    let facingOpponent = false;\n\n    if (playerFrame.positionX! > opponentFrame.positionX!) {\n      opponentDir = -1;\n    }\n    if (playerFrame.facingDirection == opponentDir) {\n      facingOpponent = true;\n    }\n\n    incrementCount(\"groundTechCount.in\", currentAnimation === State.FORWARD_TECH && facingOpponent);\n    incrementCount(\"groundTechCount.in\", currentAnimation === State.BACKWARD_TECH && !facingOpponent);\n    incrementCount(\"groundTechCount.neutral\", currentAnimation === State.NEUTRAL_TECH);\n    incrementCount(\"groundTechCount.away\", currentAnimation === State.BACKWARD_TECH && facingOpponent);\n    incrementCount(\"groundTechCount.away\", currentAnimation === State.FORWARD_TECH && !facingOpponent);\n\n    incrementCount(\"wallTechCount.success\", currentAnimation === State.WALL_TECH);\n    incrementCount(\"wallTechCount.fail\", currentAnimation === State.MISSED_WALL_TECH);\n  }\n\n  if (isAerialAttack(currentAnimation)) {\n    incrementCount(\"lCancelCount.success\", playerFrame.lCancelStatus === 1);\n    incrementCount(\"lCancelCount.fail\", playerFrame.lCancelStatus === 2);\n  }\n\n  // Handles wavedash detection (and waveland)\n  handleActionWavedash(state.playerCounts, state.animations);\n}\n\nfunction handleActionWavedash(counts: ActionCountsType, animations: State[]): void {\n  const currentAnimation = last(animations);\n  const prevAnimation = animations[animations.length - 2] as number;\n\n  const isSpecialLanding = currentAnimation === State.LANDING_FALL_SPECIAL;\n  const isAcceptablePrevious = isWavedashInitiationAnimation(prevAnimation);\n  const isPossibleWavedash = isSpecialLanding && isAcceptablePrevious;\n\n  if (!isPossibleWavedash) {\n    return;\n  }\n\n  // Here we special landed, it might be a wavedash, let's check\n  // We grab the last 8 frames here because that should be enough time to execute a\n  // wavedash. This number could be tweaked if we find false negatives\n  const recentFrames = animations.slice(-8);\n  const recentAnimations = keyBy(recentFrames, (animation) => animation);\n\n  if (size(recentAnimations) === 2 && recentAnimations[State.AIR_DODGE]) {\n    // If the only other animation is air dodge, this might be really late to the point\n    // where it was actually an air dodge. Air dodge animation is really long\n    return;\n  }\n\n  if (recentAnimations[State.AIR_DODGE]) {\n    // If one of the recent animations was an air dodge, let's remove that from the\n    // air dodge counter, we don't want to count air dodges used to wavedash/land\n    counts.airDodgeCount -= 1;\n  }\n\n  if (recentAnimations[State.ACTION_KNEE_BEND]) {\n    // If a jump was started recently, we will consider this a wavedash\n    counts.wavedashCount += 1;\n  } else {\n    // If there was no jump recently, this is a waveland\n    counts.wavelandCount += 1;\n  }\n}\n\nfunction isWavedashInitiationAnimation(animation: State): boolean {\n  if (animation === State.AIR_DODGE) {\n    return true;\n  }\n\n  const isAboveMin = animation >= State.CONTROLLED_JUMP_START;\n  const isBelowMax = animation <= State.CONTROLLED_JUMP_END;\n  return isAboveMin && isBelowMax;\n}\n","import { EventEmitter } from \"events\";\nimport { last } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ComboType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isDead,\n  isDown,\n  isGrabbed,\n  isTeching,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nexport enum ComboEvent {\n  COMBO_START = \"COMBO_START\",\n  COMBO_EXTEND = \"COMBO_EXTEND\",\n  COMBO_END = \"COMBO_END\",\n}\n\ninterface ComboState {\n  combo: ComboType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n  event: ComboEvent | null;\n}\n\nexport class ComboComputer extends EventEmitter implements StatComputer<ComboType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, ComboState>();\n  private combos = new Array<ComboType>();\n  private settings: GameStartType | null = null;\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.settings = settings;\n    this.state = new Map();\n    this.combos = [];\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: ComboState = {\n        combo: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n        event: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleComboCompute(allFrames, state, indices, frame, this.combos);\n\n        // Emit an event for the new combo\n        if (state.event !== null) {\n          this.emit(state.event, {\n            combo: last(this.combos),\n            settings: this.settings,\n          });\n          state.event = null;\n        }\n      }\n    });\n  }\n\n  public fetch(): ComboType[] {\n    return this.combos;\n  }\n}\n\nfunction handleComboCompute(\n  frames: FramesType,\n  state: ComboState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  combos: ComboType[],\n): void {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a combo or count the moves for the existing combo\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    let comboStarted = false;\n    if (!state.combo) {\n      state.combo = {\n        playerIndex: indices.opponentIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        lastHitBy: indices.playerIndex,\n      };\n\n      combos.push(state.combo);\n\n      // Track whether this is a new combo or not\n      comboStarted = true;\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.combo.moves.push(state.move);\n\n        // Make sure we don't overwrite the START event\n        if (!comboStarted) {\n          state.event = ComboEvent.COMBO_EXTEND;\n        }\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n\n    if (comboStarted) {\n      state.event = ComboEvent.COMBO_START;\n    }\n  }\n\n  if (!state.combo) {\n    // The rest of the function handles combo termination logic, so if we don't\n    // have a combo started, there is no need to continue\n    return;\n  }\n\n  const opntIsTeching = isTeching(oppActionStateId);\n  const opntIsDowned = isDown(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n  const opntIsDying = isDead(oppActionStateId);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.combo.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed || opntIsTeching || opntIsDowned || opntIsDying) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  } else {\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.combo.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - combo resets on time\n  if (state.resetCounter > Timers.COMBO_STRING_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If combo should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.combo.endFrame = playerFrame.frame;\n    state.combo.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n    state.event = ComboEvent.COMBO_END;\n\n    state.combo = null;\n    state.move = null;\n  }\n}\n","export enum Command {\n  MESSAGE_SIZES = 0x35,\n  GAME_START = 0x36,\n  PRE_FRAME_UPDATE = 0x37,\n  POST_FRAME_UPDATE = 0x38,\n  GAME_END = 0x39,\n  ITEM_UPDATE = 0x3b,\n  FRAME_BOOKEND = 0x3c,\n}\n\nexport interface PlayerType {\n  playerIndex: number;\n  port: number;\n  characterId: number | null;\n  characterColor: number | null;\n  startStocks: number | null;\n  type: number | null;\n  teamId: number | null;\n  controllerFix: string | null;\n  nametag: string | null;\n  displayName: string;\n  connectCode: string;\n}\n\nexport enum GameMode {\n  VS = 0x02,\n  ONLINE = 0x08,\n}\n\nexport interface GameStartType {\n  slpVersion: string | null;\n  isTeams: boolean | null;\n  isPAL: boolean | null;\n  stageId: number | null;\n  players: PlayerType[];\n  scene: number | null;\n  gameMode: GameMode | null;\n}\n\nexport interface PreFrameUpdateType {\n  frame: number | null;\n  playerIndex: number | null;\n  isFollower: boolean | null;\n  seed: number | null;\n  actionStateId: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  facingDirection: number | null;\n  joystickX: number | null;\n  joystickY: number | null;\n  cStickX: number | null;\n  cStickY: number | null;\n  trigger: number | null;\n  buttons: number | null;\n  physicalButtons: number | null;\n  physicalLTrigger: number | null;\n  physicalRTrigger: number | null;\n  percent: number | null;\n}\n\nexport interface PostFrameUpdateType {\n  frame: number | null;\n  playerIndex: number | null;\n  isFollower: boolean | null;\n  internalCharacterId: number | null;\n  actionStateId: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  facingDirection: number | null;\n  percent: number | null;\n  shieldSize: number | null;\n  lastAttackLanded: number | null;\n  currentComboCount: number | null;\n  lastHitBy: number | null;\n  stocksRemaining: number | null;\n  actionStateCounter: number | null;\n  miscActionState: number | null;\n  isAirborne: boolean | null;\n  lastGroundId: number | null;\n  jumpsRemaining: number | null;\n  lCancelStatus: number | null;\n  hurtboxCollisionState: number | null;\n  selfInducedSpeeds: SelfInducedSpeedsType | null;\n}\n\nexport interface SelfInducedSpeedsType {\n  airX: number | null;\n  y: number | null;\n  attackX: number | null;\n  attackY: number | null;\n  groundX: number | null;\n}\n\nexport interface ItemUpdateType {\n  frame: number | null;\n  typeId: number | null;\n  state: number | null;\n  facingDirection: number | null;\n  velocityX: number | null;\n  velocityY: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  damageTaken: number | null;\n  expirationTimer: number | null;\n  spawnId: number | null;\n  missileType: number | null;\n  turnipFace: number | null;\n  chargeShotLaunched: number | null;\n  chargePower: number | null;\n  owner: number | null;\n}\n\nexport interface FrameBookendType {\n  frame: number | null;\n  latestFinalizedFrame: number | null;\n}\n\nexport interface GameEndType {\n  gameEndMethod: number | null;\n  lrasInitiatorIndex: number | null;\n}\n\nexport interface MetadataType {\n  startAt?: string | null;\n  playedOn?: string | null;\n  lastFrame?: number | null;\n  players?: {\n    [playerIndex: number]: {\n      characters: {\n        [internalCharacterId: number]: number;\n      };\n      names?: {\n        netplay?: string | null;\n        code?: string | null;\n      };\n    };\n  } | null;\n  consoleNick?: string | null;\n}\n\nexport type EventPayloadTypes =\n  | GameStartType\n  | PreFrameUpdateType\n  | PostFrameUpdateType\n  | ItemUpdateType\n  | FrameBookendType\n  | GameEndType;\n\nexport type EventCallbackFunc = (command: Command, payload?: EventPayloadTypes | null) => boolean;\n\nexport interface FrameEntryType {\n  frame: number;\n  players: {\n    [playerIndex: number]: {\n      pre: PreFrameUpdateType;\n      post: PostFrameUpdateType;\n    } | null;\n  };\n  followers: {\n    [playerIndex: number]: {\n      pre: PreFrameUpdateType;\n      post: PostFrameUpdateType;\n    } | null;\n  };\n  items?: ItemUpdateType[];\n}\n\nexport enum Frames {\n  FIRST = -123,\n  FIRST_PLAYABLE = -39,\n}\n\nexport interface FramesType {\n  [frameIndex: number]: FrameEntryType;\n}\n\nexport interface RollbackFramesType {\n  [frameIndex: number]: FrameEntryType[];\n}\n\nexport interface RollbackFrames {\n  frames: RollbackFramesType;\n  count: number;\n  lengths: number[];\n}\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\nimport type { PlayerIndexedType } from \"./common\";\nimport { getSinglesPlayerPermutationsFromSettings } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nenum JoystickRegion {\n  DZ = 0,\n  NE = 1,\n  SE = 2,\n  SW = 3,\n  NW = 4,\n  N = 5,\n  E = 6,\n  S = 7,\n  W = 8,\n}\n\nexport interface PlayerInput {\n  playerIndex: number;\n  opponentIndex: number;\n  inputCount: number;\n  joystickInputCount: number;\n  cstickInputCount: number;\n  buttonInputCount: number;\n  triggerInputCount: number;\n}\n\nexport class InputComputer implements StatComputer<PlayerInput[]> {\n  private state = new Map<PlayerIndexedType, PlayerInput>();\n  private playerPermutations = new Array<PlayerIndexedType>();\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerInput = {\n        playerIndex: indices.playerIndex,\n        opponentIndex: indices.opponentIndex,\n        inputCount: 0,\n        joystickInputCount: 0,\n        cstickInputCount: 0,\n        buttonInputCount: 0,\n        triggerInputCount: 0,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleInputCompute(allFrames, state, indices, frame);\n      }\n    });\n  }\n\n  public fetch(): PlayerInput[] {\n    return Array.from(this.state.values());\n  }\n}\n\nfunction handleInputCompute(\n  frames: FramesType,\n  state: PlayerInput,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n): void {\n  const playerFrame = frame.players[indices.playerIndex]!.pre;\n  const currentFrameNumber = playerFrame.frame!;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber]!.players[indices.playerIndex]!.pre : null;\n\n  if (currentFrameNumber < Frames.FIRST_PLAYABLE || !prevPlayerFrame) {\n    // Don't count inputs until the game actually starts\n    return;\n  }\n\n  // First count the number of buttons that go from 0 to 1\n  // Increment action count by amount of button presses\n  const invertedPreviousButtons = ~prevPlayerFrame.physicalButtons!;\n  const currentButtons = playerFrame.physicalButtons!;\n  const buttonChanges = invertedPreviousButtons & currentButtons & 0xfff;\n  const newInputsPressed = countSetBits(buttonChanges);\n  state.inputCount += newInputsPressed;\n  state.buttonInputCount += newInputsPressed;\n\n  // Increment action count when sticks change from one region to another.\n  // Don't increment when stick returns to deadzone\n  const prevAnalogRegion = getJoystickRegion(prevPlayerFrame.joystickX!, prevPlayerFrame.joystickY!);\n  const currentAnalogRegion = getJoystickRegion(playerFrame.joystickX!, playerFrame.joystickY!);\n  if (prevAnalogRegion !== currentAnalogRegion && currentAnalogRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.joystickInputCount += 1;\n  }\n\n  // Do the same for c-stick\n  const prevCstickRegion = getJoystickRegion(prevPlayerFrame.cStickX!, prevPlayerFrame.cStickY!);\n  const currentCstickRegion = getJoystickRegion(playerFrame.cStickX!, playerFrame.cStickY!);\n  if (prevCstickRegion !== currentCstickRegion && currentCstickRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.cstickInputCount += 1;\n  }\n\n  // Increment action on analog trigger... I'm not sure when. This needs revision\n  // Currently will update input count when the button gets pressed past 0.3\n  // Changes from hard shield to light shield should probably count as inputs but\n  // are not counted here\n  if (prevPlayerFrame.physicalLTrigger! < 0.3 && playerFrame.physicalLTrigger! >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n  if (prevPlayerFrame.physicalRTrigger! < 0.3 && playerFrame.physicalRTrigger! >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n}\n\nfunction countSetBits(x: number): number {\n  // This function solves the Hamming Weight problem. Effectively it counts the number of\n  // bits in the input that are set to 1\n  // This implementation is supposedly very efficient when most bits are zero.\n  // Found: https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation\n  let bits = x;\n\n  let count;\n  for (count = 0; bits; count += 1) {\n    bits &= bits - 1;\n  }\n  return count;\n}\n\nfunction getJoystickRegion(x: number, y: number): JoystickRegion {\n  let region = JoystickRegion.DZ;\n\n  if (x >= 0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NE;\n  } else if (x >= 0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SE;\n  } else if (x <= -0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SW;\n  } else if (x <= -0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NW;\n  } else if (y >= 0.2875) {\n    region = JoystickRegion.N;\n  } else if (x >= 0.2875) {\n    region = JoystickRegion.E;\n  } else if (y <= -0.2875) {\n    region = JoystickRegion.S;\n  } else if (x <= -0.2875) {\n    region = JoystickRegion.W;\n  }\n\n  return region;\n}\n","import { EventEmitter } from \"events\";\nimport { filter, get, groupBy, last, orderBy } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ConversionType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isGrabbed,\n  isInControl,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ninterface PlayerConversionState {\n  conversion: ConversionType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n}\n\ninterface MetadataType {\n  lastEndFrameByOppIdx: {\n    [oppIdx: number]: number;\n  };\n}\n\nexport class ConversionComputer extends EventEmitter implements StatComputer<ConversionType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private conversions = new Array<ConversionType>();\n  private state = new Map<PlayerIndexedType, PlayerConversionState>();\n  private metadata: MetadataType;\n  private settings: GameStartType | null = null;\n\n  public constructor() {\n    super();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n  }\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.conversions = [];\n    this.state = new Map();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n    this.settings = settings;\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerConversionState = {\n        conversion: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        const terminated = handleConversionCompute(allFrames, state, indices, frame, this.conversions);\n        if (terminated) {\n          this.emit(\"CONVERSION\", {\n            combo: last(this.conversions),\n            settings: this.settings,\n          });\n        }\n      }\n    });\n  }\n\n  public fetch(): ConversionType[] {\n    this._populateConversionTypes();\n    return this.conversions;\n  }\n\n  private _populateConversionTypes(): void {\n    // Post-processing step: set the openingTypes\n    const conversionsToHandle = filter(this.conversions, (conversion) => {\n      return conversion.openingType === \"unknown\";\n    });\n\n    // Group new conversions by startTime and sort\n    const groupedConversions = groupBy(conversionsToHandle, \"startFrame\");\n    const sortedConversions = orderBy(groupedConversions, (conversions) => get(conversions, [0, \"startFrame\"]));\n\n    // Set the opening types on the conversions we need to handle\n    sortedConversions.forEach((conversions) => {\n      const isTrade = conversions.length >= 2;\n      conversions.forEach((conversion) => {\n        // Set end frame for this conversion\n        this.metadata.lastEndFrameByOppIdx[conversion.playerIndex] = conversion.endFrame!;\n\n        if (isTrade) {\n          // If trade, just short-circuit\n          conversion.openingType = \"trade\";\n          return;\n        }\n\n        // If not trade, check the opponent endFrame\n        const lastMove = last(conversion.moves);\n        const oppEndFrame =\n          this.metadata.lastEndFrameByOppIdx[lastMove ? lastMove.playerIndex : conversion.playerIndex];\n        const isCounterAttack = oppEndFrame && oppEndFrame > conversion.startFrame;\n        conversion.openingType = isCounterAttack ? \"counter-attack\" : \"neutral-win\";\n      });\n    });\n  }\n}\n\nfunction handleConversionCompute(\n  frames: FramesType,\n  state: PlayerConversionState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  conversions: ConversionType[],\n): boolean {\n  const currentFrameNumber = frame.frame;\n  const playerFrame: PostFrameUpdateType = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a conversion or\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    if (!state.conversion) {\n      state.conversion = {\n        playerIndex: indices.opponentIndex,\n        lastHitBy: indices.playerIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        openingType: \"unknown\", // Will be updated later\n      };\n\n      conversions.push(state.conversion);\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.conversion.moves.push(state.move);\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n  }\n\n  if (!state.conversion) {\n    // The rest of the function handles conversion termination logic, so if we don't\n    // have a conversion started, there is no need to continue\n    return false;\n  }\n\n  const opntInControl = isInControl(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.conversion.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  }\n\n  const shouldStartResetCounter = state.resetCounter === 0 && opntInControl;\n  const shouldContinueResetCounter = state.resetCounter > 0;\n  if (shouldStartResetCounter || shouldContinueResetCounter) {\n    // This will increment the reset timer under the following conditions:\n    // 1) if we were punishing opponent but they have now entered an actionable state\n    // 2) if counter has already started counting meaning opponent has entered actionable state\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.conversion.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - conversion resets on time\n  if (state.resetCounter > Timers.PUNISH_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If conversion should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.conversion.endFrame = playerFrame.frame;\n    state.conversion.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n\n    state.conversion = null;\n    state.move = null;\n  }\n\n  return shouldTerminate;\n}\n","import { first, flatten, get, groupBy, keyBy, last, mapValues, zip } from \"lodash\";\n\nimport type { GameStartType } from \"../types\";\nimport type { ConversionType, InputCountsType, OverallType, RatioType } from \"./common\";\nimport type { PlayerInput } from \"./inputs\";\n\ninterface ConversionsByPlayerByOpening {\n  [playerIndex: string]: {\n    [openingType: string]: ConversionType[];\n  };\n}\n\nexport function generateOverallStats({\n  settings,\n  inputs,\n  conversions,\n  playableFrameCount,\n}: {\n  settings: GameStartType;\n  inputs: PlayerInput[];\n  conversions: ConversionType[];\n  playableFrameCount: number;\n}): OverallType[] {\n  const inputsByPlayer = keyBy(inputs, \"playerIndex\");\n  const originalConversions = conversions;\n  const conversionsByPlayer = groupBy(conversions, (conv) => conv.moves[0]?.playerIndex);\n  const conversionsByPlayerByOpening: ConversionsByPlayerByOpening = mapValues(conversionsByPlayer, (conversions) =>\n    groupBy(conversions, \"openingType\"),\n  );\n\n  const gameMinutes = playableFrameCount / 3600;\n\n  const overall = settings.players.map((player) => {\n    const playerIndex = player.playerIndex;\n\n    const playerInputs = get(inputsByPlayer, playerIndex) || {};\n    const inputCounts: InputCountsType = {\n      buttons: get(playerInputs, \"buttonInputCount\"),\n      triggers: get(playerInputs, \"triggerInputCount\"),\n      cstick: get(playerInputs, \"cstickInputCount\"),\n      joystick: get(playerInputs, \"joystickInputCount\"),\n      total: get(playerInputs, \"inputCount\"),\n    };\n    // const conversions = get(conversionsByPlayer, playerIndex) || [];\n    // const successfulConversions = conversions.filter((conversion) => conversion.moves.length > 1);\n    let conversionCount = 0;\n    let successfulConversionCount = 0;\n\n    const opponentIndices = settings.players\n      .filter((opp) => {\n        // We want players which aren't ourselves\n        if (opp.playerIndex === playerIndex) {\n          return false;\n        }\n\n        // Make sure they're not on our team either\n        return !settings.isTeams || opp.teamId !== player.teamId;\n      })\n      .map((opp) => opp.playerIndex);\n\n    let totalDamage = 0;\n    let killCount = 0;\n\n    // These are the conversions that we did on our opponents\n    originalConversions\n      // Filter down to conversions of our opponent\n      .filter((conversion) => conversion.playerIndex !== playerIndex)\n      .forEach((conversion) => {\n        conversionCount++;\n\n        // We killed the opponent\n        if (conversion.didKill && conversion.lastHitBy === playerIndex) {\n          killCount += 1;\n        }\n        if (conversion.moves.length > 1 && conversion.moves[0]!.playerIndex === playerIndex) {\n          successfulConversionCount++;\n        }\n        conversion.moves.forEach((move) => {\n          if (move.playerIndex === playerIndex) {\n            totalDamage += move.damage;\n          }\n        });\n      });\n\n    return {\n      playerIndex: playerIndex,\n      inputCounts: inputCounts,\n      conversionCount: conversionCount,\n      totalDamage: totalDamage,\n      killCount: killCount,\n\n      successfulConversions: getRatio(successfulConversionCount, conversionCount),\n      inputsPerMinute: getRatio(inputCounts.total, gameMinutes),\n      digitalInputsPerMinute: getRatio(inputCounts.buttons, gameMinutes),\n      openingsPerKill: getRatio(conversionCount, killCount),\n      damagePerOpening: getRatio(totalDamage, conversionCount),\n      neutralWinRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"neutral-win\"),\n      counterHitRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"counter-attack\"),\n      beneficialTradeRatio: getBeneficialTradeRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices),\n    };\n  });\n\n  return overall;\n}\n\nfunction getRatio(count: number, total: number): RatioType {\n  return {\n    count: count,\n    total: total,\n    ratio: total ? count / total : null,\n  };\n}\n\nfunction getOpeningRatio(\n  conversionsByPlayerByOpening: ConversionsByPlayerByOpening,\n  playerIndex: number,\n  opponentIndices: number[],\n  type: string,\n): RatioType {\n  const openings = get(conversionsByPlayerByOpening, [playerIndex, type]) || [];\n\n  const opponentOpenings = flatten(\n    opponentIndices.map((opponentIndex) => get(conversionsByPlayerByOpening, [opponentIndex, type]) || []),\n  );\n\n  return getRatio(openings.length, openings.length + opponentOpenings.length);\n}\n\nfunction getBeneficialTradeRatio(\n  conversionsByPlayerByOpening: ConversionsByPlayerByOpening,\n  playerIndex: number,\n  opponentIndices: number[],\n): RatioType {\n  const playerTrades = get(conversionsByPlayerByOpening, [playerIndex, \"trade\"]) || [];\n  const opponentTrades = flatten(\n    opponentIndices.map((opponentIndex) => get(conversionsByPlayerByOpening, [opponentIndex, \"trade\"]) || []),\n  );\n\n  const benefitsPlayer = [];\n\n  // Figure out which punishes benefited this player\n  const zippedTrades = zip(playerTrades, opponentTrades);\n  zippedTrades.forEach((conversionPair) => {\n    const playerConversion = first(conversionPair);\n    const opponentConversion = last(conversionPair);\n    if (playerConversion && opponentConversion) {\n      const playerDamage = playerConversion.currentPercent - playerConversion.startPercent;\n      const opponentDamage = opponentConversion.currentPercent - opponentConversion.startPercent;\n\n      if (playerConversion!.didKill && !opponentConversion!.didKill) {\n        benefitsPlayer.push(playerConversion);\n      } else if (playerDamage > opponentDamage) {\n        benefitsPlayer.push(playerConversion);\n      }\n    }\n  });\n\n  return getRatio(benefitsPlayer.length, playerTrades.length);\n}\n","import { get } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\n\nexport interface StatComputer<T> {\n  setup(settings: GameStartType): void;\n  processFrame(newFrame: FrameEntryType, allFrames: FramesType): void;\n  fetch(): T;\n}\n\nexport interface StatOptions {\n  processOnTheFly: boolean;\n}\n\nconst defaultOptions: StatOptions = {\n  processOnTheFly: false,\n};\n\nexport class Stats {\n  private options: StatOptions;\n  private lastProcessedFrame: number | null = null;\n  private frames: FramesType = {};\n  private players: number[] = [];\n  private allComputers = new Array<StatComputer<unknown>>();\n\n  public constructor(options?: StatOptions) {\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n\n  /**\n   * Should reset the frames to their default values.\n   */\n  public setup(settings: GameStartType): void {\n    // Reset the frames since it's a new game\n    this.frames = {};\n    this.players = settings.players.map((v) => v.playerIndex);\n\n    // Forward the settings on to the individual stat computer\n    this.allComputers.forEach((comp) => comp.setup(settings));\n  }\n\n  public register(...computer: StatComputer<unknown>[]): void {\n    this.allComputers.push(...computer);\n  }\n\n  public process(): void {\n    if (this.players.length === 0) {\n      return;\n    }\n\n    let i = this.lastProcessedFrame !== null ? this.lastProcessedFrame + 1 : Frames.FIRST;\n    while (this.frames[i]) {\n      const frame = this.frames[i];\n      // Don't attempt to compute stats on frames that have not been fully received\n      if (!isCompletedFrame(this.players, frame)) {\n        return;\n      }\n      this.allComputers.forEach((comp) => comp.processFrame(frame, this.frames));\n      this.lastProcessedFrame = i;\n      i++;\n    }\n  }\n\n  public addFrame(frame: FrameEntryType): void {\n    this.frames[frame.frame] = frame;\n\n    if (this.options.processOnTheFly) {\n      this.process();\n    }\n  }\n}\n\nfunction isCompletedFrame(players: number[], frame?: FrameEntryType): frame is FrameEntryType {\n  if (!frame) {\n    return false;\n  }\n\n  // This function checks whether we have successfully received an entire frame.\n  // It is not perfect because it does not wait for follower frames. Fortunately,\n  // follower frames are not used for any stat calculations so this doesn't matter\n  // for our purposes.\n  for (const player of players) {\n    const playerPostFrame = get(frame, [\"players\", player, \"post\"]);\n    if (!playerPostFrame) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport type { PlayerIndexedType, StockType } from \"./common\";\nimport { didLoseStock, getSinglesPlayerPermutationsFromSettings, isDead } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ninterface StockState {\n  stock?: StockType | null;\n}\n\nexport class StockComputer implements StatComputer<StockType[]> {\n  private state = new Map<PlayerIndexedType, StockState>();\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private stocks = new Array<StockType>();\n\n  public setup(settings: GameStartType): void {\n    // Reset state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.stocks = [];\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: StockState = {\n        stock: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleStockCompute(allFrames, state, indices, frame, this.stocks);\n      }\n    });\n  }\n\n  public fetch(): StockType[] {\n    return this.stocks;\n  }\n}\n\nfunction handleStockCompute(\n  frames: FramesType,\n  state: StockState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  stocks: StockType[],\n): void {\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const currentFrameNumber = playerFrame.frame!;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber]!.players[indices.playerIndex]!.post : null;\n\n  // If there is currently no active stock, wait until the player is no longer spawning.\n  // Once the player is no longer spawning, start the stock\n  if (!state.stock) {\n    const isPlayerDead = isDead(playerFrame.actionStateId!);\n    if (isPlayerDead) {\n      return;\n    }\n\n    state.stock = {\n      playerIndex: indices.playerIndex,\n      startFrame: currentFrameNumber,\n      endFrame: null,\n      startPercent: 0,\n      endPercent: null,\n      currentPercent: 0,\n      count: playerFrame.stocksRemaining!,\n      deathAnimation: null,\n    };\n\n    stocks.push(state.stock);\n  } else if (prevPlayerFrame && didLoseStock(playerFrame, prevPlayerFrame)) {\n    state.stock.endFrame = playerFrame.frame;\n    state.stock.endPercent = prevPlayerFrame.percent ?? 0;\n    state.stock.deathAnimation = playerFrame.actionStateId;\n    state.stock = null;\n  } else {\n    state.stock.currentPercent = playerFrame.percent ?? 0;\n  }\n}\n","import type { FrameEntryType, RollbackFramesType } from \"../types\";\n\nexport class RollbackCounter {\n  private rollbackFrames: RollbackFramesType = {};\n  private rollbackFrameCount = 0;\n  private rollbackPlayerIdx: number | null = null; // for keeping track of rollbacks by following a single player\n  private lastFrameWasRollback = false;\n  private currentRollbackLength = 0;\n  private rollbackLengths: number[] = [];\n\n  public checkIfRollbackFrame(currentFrame: FrameEntryType | undefined, playerIdx: number) {\n    if (this.rollbackPlayerIdx === null) {\n      // we only want to follow a single player to avoid double counting. So we use whoever is on first.\n      this.rollbackPlayerIdx = playerIdx;\n    } else if (this.rollbackPlayerIdx !== playerIdx) {\n      return;\n    }\n\n    if (currentFrame) {\n      // frame already exists for currentFrameNumber so we must be rolling back\n      if (this.rollbackFrames[currentFrame.frame]) {\n        this.rollbackFrames[currentFrame.frame]!.push(currentFrame);\n      } else {\n        this.rollbackFrames[currentFrame.frame] = [currentFrame];\n      }\n      this.rollbackFrameCount++;\n      this.currentRollbackLength++;\n      this.lastFrameWasRollback = true;\n    } else if (this.lastFrameWasRollback) {\n      this.rollbackLengths.push(this.currentRollbackLength);\n      this.currentRollbackLength = 0;\n      this.lastFrameWasRollback = false;\n    }\n    return this.lastFrameWasRollback;\n  }\n\n  public getFrames() {\n    return this.rollbackFrames;\n  }\n\n  public getCount() {\n    return this.rollbackFrameCount;\n  }\n\n  public getLengths() {\n    return this.rollbackLengths;\n  }\n}\n","import { EventEmitter } from \"events\";\nimport { get, keyBy, set } from \"lodash\";\nimport semver from \"semver\";\n\nimport type {\n  FrameBookendType,\n  FrameEntryType,\n  FramesType,\n  GameEndType,\n  GameStartType,\n  ItemUpdateType,\n  PostFrameUpdateType,\n  PreFrameUpdateType,\n  RollbackFrames,\n} from \"../types\";\nimport { Command, Frames, GameMode } from \"../types\";\nimport { RollbackCounter } from \"./rollbackCounter\";\n\nexport const MAX_ROLLBACK_FRAMES = 7;\n\nexport enum SlpParserEvent {\n  SETTINGS = \"settings\",\n  END = \"end\",\n  FRAME = \"frame\", // Emitted for every frame\n  FINALIZED_FRAME = \"finalized-frame\", // Emitted for only finalized frames\n  ROLLBACK_FRAME = \"rollback-frame\", // Emitted if a frame is being replaced\n}\n\n// If strict mode is on, we will do strict validation checking\n// which could throw errors on invalid data.\n// Default to false though since probably only real time applications\n// would care about valid data.\nconst defaultSlpParserOptions = {\n  strict: false,\n};\n\nexport type SlpParserOptions = typeof defaultSlpParserOptions;\n\nexport class SlpParser extends EventEmitter {\n  private frames: FramesType = {};\n  private rollbackCounter: RollbackCounter = new RollbackCounter();\n  private settings: GameStartType | null = null;\n  private gameEnd: GameEndType | null = null;\n  private latestFrameIndex: number | null = null;\n  private settingsComplete = false;\n  private lastFinalizedFrame = Frames.FIRST - 1;\n  private options: SlpParserOptions;\n\n  public constructor(options?: Partial<SlpParserOptions>) {\n    super();\n    this.options = Object.assign({}, defaultSlpParserOptions, options);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public handleCommand(command: Command, payload: any): void {\n    switch (command) {\n      case Command.GAME_START:\n        this._handleGameStart(payload as GameStartType);\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // We need to handle the post frame update first since that\n        // will finalize the settings object, before we fire the frame update\n        this._handlePostFrameUpdate(payload as PostFrameUpdateType);\n        this._handleFrameUpdate(command, payload as PostFrameUpdateType);\n        break;\n      case Command.PRE_FRAME_UPDATE:\n        this._handleFrameUpdate(command, payload as PreFrameUpdateType);\n        break;\n      case Command.ITEM_UPDATE:\n        this._handleItemUpdate(payload as ItemUpdateType);\n        break;\n      case Command.FRAME_BOOKEND:\n        this._handleFrameBookend(payload as FrameBookendType);\n        break;\n      case Command.GAME_END:\n        this._handleGameEnd(payload as GameEndType);\n        break;\n    }\n  }\n\n  /**\n   * Resets the parser state to their default values.\n   */\n  public reset(): void {\n    this.frames = {};\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = Frames.FIRST - 1;\n  }\n\n  public getLatestFrameNumber(): number {\n    return this.latestFrameIndex ?? Frames.FIRST - 1;\n  }\n\n  public getPlayableFrameCount(): number {\n    if (this.latestFrameIndex === null) {\n      return 0;\n    }\n    return this.latestFrameIndex < Frames.FIRST_PLAYABLE ? 0 : this.latestFrameIndex - Frames.FIRST_PLAYABLE;\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    // return this.playerFrames[this.latestFrameIndex];\n\n    // TODO: Modify this to check if we actually have all the latest frame data and return that\n    // TODO: If we do. For now I'm just going to take a shortcut\n    const allFrames = this.getFrames();\n    const frameIndex = this.latestFrameIndex !== null ? this.latestFrameIndex : Frames.FIRST;\n    const indexToUse = this.gameEnd ? frameIndex : frameIndex - 1;\n    return get(allFrames, indexToUse) || null;\n  }\n\n  public getSettings(): GameStartType | null {\n    return this.settingsComplete ? this.settings : null;\n  }\n\n  public getGameEnd(): GameEndType | null {\n    return this.gameEnd;\n  }\n\n  public getFrames(): FramesType {\n    return this.frames;\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    return {\n      frames: this.rollbackCounter.getFrames(),\n      count: this.rollbackCounter.getCount(),\n      lengths: this.rollbackCounter.getLengths(),\n    };\n  }\n\n  public getFrame(num: number): FrameEntryType | null {\n    return this.frames[num] || null;\n  }\n\n  private _handleGameEnd(payload: GameEndType): void {\n    // Finalize remaining frames if necessary\n    if (this.latestFrameIndex !== null && this.latestFrameIndex !== this.lastFinalizedFrame) {\n      this._finalizeFrames(this.latestFrameIndex);\n    }\n\n    payload = payload as GameEndType;\n    this.gameEnd = payload;\n    this.emit(SlpParserEvent.END, this.gameEnd);\n  }\n\n  private _handleGameStart(payload: GameStartType): void {\n    this.settings = payload;\n    const players = payload.players;\n    this.settings.players = players.filter((player) => player.type !== 3);\n\n    // Check to see if the file was created after the sheik fix so we know\n    // we don't have to process the first frame of the game for the full settings\n    if (payload.slpVersion && semver.gte(payload.slpVersion, \"1.6.0\")) {\n      this._completeSettings();\n    }\n  }\n\n  private _handlePostFrameUpdate(payload: PostFrameUpdateType): void {\n    if (this.settingsComplete) {\n      return;\n    }\n\n    // Finish calculating settings\n    if (payload.frame! <= Frames.FIRST) {\n      const playerIndex = payload.playerIndex!;\n      const playersByIndex = keyBy(this.settings!.players, \"playerIndex\");\n\n      switch (payload.internalCharacterId) {\n        case 0x7:\n          playersByIndex[playerIndex]!.characterId = 0x13; // Sheik\n          break;\n        case 0x13:\n          playersByIndex[playerIndex]!.characterId = 0x12; // Zelda\n          break;\n      }\n    }\n    if (payload.frame! > Frames.FIRST) {\n      this._completeSettings();\n    }\n  }\n\n  private _handleFrameUpdate(command: Command, payload: PreFrameUpdateType | PostFrameUpdateType): void {\n    payload = payload as PostFrameUpdateType;\n    const location = command === Command.PRE_FRAME_UPDATE ? \"pre\" : \"post\";\n    const field = payload.isFollower ? \"followers\" : \"players\";\n    const currentFrameNumber = payload.frame!;\n    this.latestFrameIndex = currentFrameNumber;\n    if (location === \"pre\" && !payload.isFollower) {\n      const currentFrame = this.frames[currentFrameNumber];\n      const wasRolledback = this.rollbackCounter.checkIfRollbackFrame(currentFrame, payload.playerIndex!);\n      if (wasRolledback) {\n        // frame is about to be overwritten\n        this.emit(SlpParserEvent.ROLLBACK_FRAME, currentFrame);\n      }\n    }\n    set(this.frames, [currentFrameNumber, field, payload.playerIndex!, location], payload);\n    set(this.frames, [currentFrameNumber, \"frame\"], currentFrameNumber);\n\n    // If file is from before frame bookending, add frame to stats computer here. Does a little\n    // more processing than necessary, but it works\n    const settings = this.getSettings();\n    if (settings && (!settings.slpVersion || semver.lte(settings.slpVersion, \"2.2.0\"))) {\n      this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n      // Finalize the previous frame since no bookending exists\n      this._finalizeFrames(currentFrameNumber - 1);\n    } else {\n      set(this.frames, [currentFrameNumber, \"isTransferComplete\"], false);\n    }\n  }\n\n  private _handleItemUpdate(payload: ItemUpdateType): void {\n    const currentFrameNumber = payload.frame!;\n    const items = this.frames[currentFrameNumber]?.items ?? [];\n    items.push(payload);\n\n    // Set items with newest\n    set(this.frames, [currentFrameNumber, \"items\"], items);\n  }\n\n  private _handleFrameBookend(payload: FrameBookendType): void {\n    const latestFinalizedFrame = payload.latestFinalizedFrame!;\n    const currentFrameNumber = payload.frame!;\n    set(this.frames, [currentFrameNumber, \"isTransferComplete\"], true);\n    // Fire off a normal frame event\n    this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n\n    // Finalize frames if necessary\n    const validLatestFrame = this.settings!.gameMode === GameMode.ONLINE;\n    if (validLatestFrame && latestFinalizedFrame >= Frames.FIRST) {\n      // Ensure valid latestFinalizedFrame\n      if (this.options.strict && latestFinalizedFrame < currentFrameNumber - MAX_ROLLBACK_FRAMES) {\n        throw new Error(`latestFinalizedFrame should be within ${MAX_ROLLBACK_FRAMES} frames of ${currentFrameNumber}`);\n      }\n      this._finalizeFrames(latestFinalizedFrame);\n    } else {\n      // Since we don't have a valid finalized frame, just finalize the frame based on MAX_ROLLBACK_FRAMES\n      this._finalizeFrames(currentFrameNumber - MAX_ROLLBACK_FRAMES);\n    }\n  }\n\n  /**\n   * Fires off the FINALIZED_FRAME event for frames up until a certain number\n   * @param num The frame to finalize until\n   */\n  private _finalizeFrames(num: number): void {\n    while (this.lastFinalizedFrame < num) {\n      const frameToFinalize = this.lastFinalizedFrame + 1;\n      const frame = this.getFrame(frameToFinalize)!;\n\n      // Check that we have all the pre and post frame data for all players if we're in strict mode\n      if (this.options.strict) {\n        for (const player of this.settings!.players) {\n          const playerFrameInfo = frame.players[player.playerIndex];\n          // Allow player frame info to be empty in non 1v1 games since\n          // players which have been defeated will have no frame info.\n          if (this.settings!.players.length > 2 && !playerFrameInfo) {\n            continue;\n          }\n\n          const { pre, post } = playerFrameInfo!;\n          if (!pre || !post) {\n            const preOrPost = pre ? \"pre\" : \"post\";\n            throw new Error(\n              `Could not finalize frame ${frameToFinalize} of ${num}: missing ${preOrPost}-frame update for player ${player.playerIndex}`,\n            );\n          }\n        }\n      }\n\n      // Our frame is complete so finalize the frame\n      this.emit(SlpParserEvent.FINALIZED_FRAME, frame);\n      this.lastFinalizedFrame = frameToFinalize;\n    }\n  }\n\n  private _completeSettings(): void {\n    if (!this.settingsComplete) {\n      this.settingsComplete = true;\n      this.emit(SlpParserEvent.SETTINGS, this.settings);\n    }\n  }\n}\n","import { decode } from \"@shelacek/ubjson\";\nimport iconv from \"iconv-lite\";\nimport { mapValues } from \"lodash\";\n\nimport type { EventCallbackFunc, EventPayloadTypes, MetadataType, PlayerType, SelfInducedSpeedsType } from \"../types\";\nimport { Command } from \"../types\";\nimport { toHalfwidth } from \"./fullwidth\";\n\nexport enum SlpInputSource {\n  BUFFER = \"buffer\",\n  FILE = \"file\",\n}\n\nexport interface SlpReadInput {\n  source: SlpInputSource;\n  filePath?: string;\n  buffer?: Buffer;\n}\n\nexport type SlpRefType = SlpFileSourceRef | SlpBufferSourceRef;\n\nexport interface SlpFileType {\n  ref: SlpRefType;\n  rawDataPosition: number;\n  rawDataLength: number;\n  metadataPosition: number;\n  metadataLength: number;\n  messageSizes: {\n    [command: number]: number;\n  };\n}\n\nexport interface SlpFileSourceRef {\n  source: SlpInputSource;\n  fileDescriptor: number;\n}\n\nexport interface SlpBufferSourceRef {\n  source: SlpInputSource;\n  buffer: Buffer;\n}\n\nfunction getRef(input: SlpReadInput): SlpRefType {\n  switch (input.source) {\n    case SlpInputSource.BUFFER:\n      return {\n        source: input.source,\n        buffer: input.buffer,\n      } as SlpBufferSourceRef;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\nfunction readRef(ref: SlpRefType, buffer: Uint8Array, offset: number, length: number, position: number): number {\n  switch (ref.source) {\n    case SlpInputSource.BUFFER:\n      // return (ref as SlpBufferSourceRef).buffer.copy(buffer, offset, position, position + length);\n      for (let i = 0; i < length; i++) {\n        buffer[offset + i] = (ref as SlpBufferSourceRef).buffer[position + i]!;\n      }\n      return buffer.length;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\nfunction getLenRef(ref: SlpRefType): number {\n  switch (ref.source) {\n    case SlpInputSource.BUFFER:\n      return (ref as SlpBufferSourceRef).buffer.length;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\n/**\n * Opens a file at path\n */\nexport function openSlpFile(input: SlpReadInput): SlpFileType {\n  const ref = getRef(input);\n\n  const rawDataPosition = getRawDataPosition(ref);\n  const rawDataLength = getRawDataLength(ref, rawDataPosition);\n  const metadataPosition = rawDataPosition + rawDataLength + 10; // remove metadata string\n  const metadataLength = getMetadataLength(ref, metadataPosition);\n  const messageSizes = getMessageSizes(ref, rawDataPosition);\n\n  return {\n    ref: ref,\n    rawDataPosition: rawDataPosition,\n    rawDataLength: rawDataLength,\n    metadataPosition: metadataPosition,\n    metadataLength: metadataLength,\n    messageSizes: messageSizes,\n  };\n}\n\nexport function closeSlpFile(file: SlpFileType): void {\n  switch (file.ref.source) {\n    case SlpInputSource.FILE:\n      break;\n  }\n}\n\nvar Buffer = require(\"buffer/\").Buffer;\n// This function gets the position where the raw data starts\nfunction getRawDataPosition(ref: SlpRefType): number {\n  const buffer = Buffer.from(new Uint8Array(1));\n  readRef(ref, buffer, 0, buffer.length, 0);\n\n  if (buffer[0] === 0x36) {\n    return 0;\n  }\n\n  if (buffer[0] !== \"{\".charCodeAt(0)) {\n    return 0; // return error?\n  }\n\n  return 15;\n}\n\nfunction getRawDataLength(ref: SlpRefType, position: number): number {\n  const fileSize = getLenRef(ref);\n  if (position === 0) {\n    return fileSize;\n  }\n\n  const buffer = new Uint8Array(4);\n  readRef(ref, buffer, 0, buffer.length, position - 4);\n\n  const rawDataLen = (buffer[0]! << 24) | (buffer[1]! << 16) | (buffer[2]! << 8) | buffer[3]!;\n  if (rawDataLen > 0) {\n    // If this method manages to read a number, it's probably trustworthy\n    return rawDataLen;\n  }\n\n  // If the above does not return a valid data length,\n  // return a file size based on file length. This enables\n  // some support for severed files\n  return fileSize - position;\n}\n\nfunction getMetadataLength(ref: SlpRefType, position: number): number {\n  const len = getLenRef(ref);\n  return len - position - 1;\n}\n\nfunction getMessageSizes(\n  ref: SlpRefType,\n  position: number,\n): {\n  [command: number]: number;\n} {\n  const messageSizes: {\n    [command: number]: number;\n  } = {};\n  // Support old file format\n  if (position === 0) {\n    messageSizes[0x36] = 0x140;\n    messageSizes[0x37] = 0x6;\n    messageSizes[0x38] = 0x46;\n    messageSizes[0x39] = 0x1;\n    return messageSizes;\n  }\n\n  const buffer = new Uint8Array(2);\n  readRef(ref, buffer, 0, buffer.length, position);\n  if (buffer[0] !== Command.MESSAGE_SIZES) {\n    return {};\n  }\n\n  const payloadLength = buffer[1] as number;\n  (messageSizes[0x35] as any) = payloadLength;\n\n  const messageSizesBuffer = new Uint8Array(payloadLength - 1);\n  readRef(ref, messageSizesBuffer, 0, messageSizesBuffer.length, position + 2);\n  for (let i = 0; i < payloadLength - 1; i += 3) {\n    const command = messageSizesBuffer[i] as number;\n\n    // Get size of command\n    (messageSizes[command] as any) = (messageSizesBuffer[i + 1]! << 8) | messageSizesBuffer[i + 2]!;\n  }\n\n  return messageSizes;\n}\n\n/**\n * Iterates through slp events and parses payloads\n */\nexport function iterateEvents(\n  slpFile: SlpFileType,\n  callback: EventCallbackFunc,\n  startPos: number | null = null,\n): number {\n  const ref = slpFile.ref;\n\n  let readPosition = startPos !== null && startPos > 0 ? startPos : slpFile.rawDataPosition;\n  const stopReadingAt = slpFile.rawDataPosition + slpFile.rawDataLength;\n\n  // Generate read buffers for each\n  const commandPayloadBuffers = mapValues(slpFile.messageSizes, (size) => new Uint8Array(size + 1));\n\n  const commandByteBuffer = new Uint8Array(1);\n  while (readPosition < stopReadingAt) {\n    readRef(ref, commandByteBuffer, 0, 1, readPosition);\n    const commandByte = commandByteBuffer[0] as number;\n    const buffer = commandPayloadBuffers[commandByte];\n    if (buffer === undefined) {\n      // If we don't have an entry for this command, return false to indicate failed read\n      return readPosition;\n    }\n\n    if (buffer.length > stopReadingAt - readPosition) {\n      return readPosition;\n    }\n\n    readRef(ref, buffer, 0, buffer.length, readPosition);\n    const parsedPayload = parseMessage(commandByte, buffer);\n    const shouldStop = callback(commandByte, parsedPayload);\n    if (shouldStop) {\n      break;\n    }\n\n    readPosition += buffer.length;\n  }\n\n  return readPosition;\n}\n\nexport function parseMessage(command: Command, payload: Uint8Array): EventPayloadTypes | null {\n  const view = new DataView(payload.buffer);\n  switch (command) {\n    case Command.GAME_START:\n      const getPlayerObject = (playerIndex: number): PlayerType => {\n        // Controller Fix stuff\n        const cfOffset = playerIndex * 0x8;\n        const dashback = readUint32(view, 0x141 + cfOffset);\n        const shieldDrop = readUint32(view, 0x145 + cfOffset);\n        let cfOption = \"None\";\n        if (dashback !== shieldDrop) {\n          cfOption = \"Mixed\";\n        } else if (dashback === 1) {\n          cfOption = \"UCF\";\n        } else if (dashback === 2) {\n          cfOption = \"Dween\";\n        }\n\n        // Nametag stuff\n        const nametagLength = 0x10;\n        const nametagOffset = playerIndex * nametagLength;\n        const nametagStart = 0x161 + nametagOffset;\n        const nametagBuf = payload.slice(nametagStart, nametagStart + nametagLength);\n        const nameTagString = iconv\n          .decode(nametagBuf as Buffer, \"Shift_JIS\")\n          .split(\"\\0\")\n          .shift();\n        const nametag = nameTagString ? toHalfwidth(nameTagString) : \"\";\n\n        // Display name\n        const displayNameLength = 0x1f;\n        const displayNameOffset = playerIndex * displayNameLength;\n        const displayNameStart = 0x1a5 + displayNameOffset;\n        const displayNameBuf = payload.slice(displayNameStart, displayNameStart + displayNameLength);\n        const displayNameString = iconv\n          .decode(displayNameBuf as Buffer, \"Shift_JIS\")\n          .split(\"\\0\")\n          .shift();\n        const displayName = displayNameString ? toHalfwidth(displayNameString) : \"\";\n\n        // Connect code\n        const connectCodeLength = 0xa;\n        const connectCodeOffset = playerIndex * connectCodeLength;\n        const connectCodeStart = 0x221 + connectCodeOffset;\n        const connectCodeBuf = payload.slice(connectCodeStart, connectCodeStart + connectCodeLength);\n        const connectCodeString = iconv\n          .decode(connectCodeBuf as Buffer, \"Shift_JIS\")\n          .split(\"\\0\")\n          .shift();\n        const connectCode = connectCodeString ? toHalfwidth(connectCodeString) : \"\";\n\n        const offset = playerIndex * 0x24;\n        return {\n          playerIndex: playerIndex,\n          port: playerIndex + 1,\n          characterId: readUint8(view, 0x65 + offset),\n          characterColor: readUint8(view, 0x68 + offset),\n          startStocks: readUint8(view, 0x67 + offset),\n          type: readUint8(view, 0x66 + offset),\n          teamId: readUint8(view, 0x6e + offset),\n          controllerFix: cfOption,\n          nametag: nametag,\n          displayName: displayName,\n          connectCode: connectCode,\n        };\n      };\n      return {\n        slpVersion: `${readUint8(view, 0x1)}.${readUint8(view, 0x2)}.${readUint8(view, 0x3)}`,\n        isTeams: readBool(view, 0xd),\n        isPAL: readBool(view, 0x1a1),\n        stageId: readUint16(view, 0x13),\n        players: [0, 1, 2, 3].map(getPlayerObject),\n        scene: readUint8(view, 0x1a3),\n        gameMode: readUint8(view, 0x1a4),\n      };\n    case Command.PRE_FRAME_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        seed: readUint32(view, 0x7),\n        actionStateId: readUint16(view, 0xb),\n        positionX: readFloat(view, 0xd),\n        positionY: readFloat(view, 0x11),\n        facingDirection: readFloat(view, 0x15),\n        joystickX: readFloat(view, 0x19),\n        joystickY: readFloat(view, 0x1d),\n        cStickX: readFloat(view, 0x21),\n        cStickY: readFloat(view, 0x25),\n        trigger: readFloat(view, 0x29),\n        buttons: readUint32(view, 0x2d),\n        physicalButtons: readUint16(view, 0x31),\n        physicalLTrigger: readFloat(view, 0x33),\n        physicalRTrigger: readFloat(view, 0x37),\n        percent: readFloat(view, 0x3c),\n      };\n    case Command.POST_FRAME_UPDATE:\n      const selfInducedSpeeds: SelfInducedSpeedsType = {\n        airX: readFloat(view, 0x35),\n        y: readFloat(view, 0x39),\n        attackX: readFloat(view, 0x3d),\n        attackY: readFloat(view, 0x41),\n        groundX: readFloat(view, 0x45),\n      };\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        internalCharacterId: readUint8(view, 0x7),\n        actionStateId: readUint16(view, 0x8),\n        positionX: readFloat(view, 0xa),\n        positionY: readFloat(view, 0xe),\n        facingDirection: readFloat(view, 0x12),\n        percent: readFloat(view, 0x16),\n        shieldSize: readFloat(view, 0x1a),\n        lastAttackLanded: readUint8(view, 0x1e),\n        currentComboCount: readUint8(view, 0x1f),\n        lastHitBy: readUint8(view, 0x20),\n        stocksRemaining: readUint8(view, 0x21),\n        actionStateCounter: readFloat(view, 0x22),\n        miscActionState: readFloat(view, 0x2b),\n        isAirborne: readBool(view, 0x2f),\n        lastGroundId: readUint16(view, 0x30),\n        jumpsRemaining: readUint8(view, 0x32),\n        lCancelStatus: readUint8(view, 0x33),\n        hurtboxCollisionState: readUint8(view, 0x34),\n        selfInducedSpeeds: selfInducedSpeeds,\n      };\n    case Command.ITEM_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        typeId: readUint16(view, 0x5),\n        state: readUint8(view, 0x7),\n        facingDirection: readFloat(view, 0x8),\n        velocityX: readFloat(view, 0xc),\n        velocityY: readFloat(view, 0x10),\n        positionX: readFloat(view, 0x14),\n        positionY: readFloat(view, 0x18),\n        damageTaken: readUint16(view, 0x1c),\n        expirationTimer: readFloat(view, 0x1e),\n        spawnId: readUint32(view, 0x22),\n        missileType: readUint8(view, 0x26),\n        turnipFace: readUint8(view, 0x27),\n        chargeShotLaunched: readUint8(view, 0x28),\n        chargePower: readUint8(view, 0x29),\n        owner: readInt8(view, 0x2a),\n      };\n    case Command.FRAME_BOOKEND:\n      return {\n        frame: readInt32(view, 0x1),\n        latestFinalizedFrame: readInt32(view, 0x5),\n      };\n    case Command.GAME_END:\n      return {\n        gameEndMethod: readUint8(view, 0x1),\n        lrasInitiatorIndex: readInt8(view, 0x2),\n      };\n    default:\n      return null;\n  }\n}\n\nfunction canReadFromView(view: DataView, offset: number, length: number): boolean {\n  const viewLength = view.byteLength;\n  return offset + length <= viewLength;\n}\n\nfunction readFloat(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getFloat32(offset);\n}\n\nfunction readInt32(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getInt32(offset);\n}\n\nfunction readInt8(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getInt8(offset);\n}\n\nfunction readUint32(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getUint32(offset);\n}\n\nfunction readUint16(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 2)) {\n    return null;\n  }\n\n  return view.getUint16(offset);\n}\n\nfunction readUint8(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getUint8(offset);\n}\n\nfunction readBool(view: DataView, offset: number): boolean | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return !!view.getUint8(offset);\n}\n\nexport function getMetadata(slpFile: SlpFileType): MetadataType | null {\n  if (slpFile.metadataLength <= 0) {\n    // This will happen on a severed incomplete file\n    // $FlowFixMe\n    return null;\n  }\n\n  const buffer = new Uint8Array(slpFile.metadataLength);\n\n  readRef(slpFile.ref, buffer, 0, buffer.length, slpFile.metadataPosition);\n\n  let metadata = null;\n  try {\n    metadata = decode(buffer);\n  } catch (ex) {\n    // Do nothing\n    // console.log(ex);\n  }\n\n  // $FlowFixMe\n  return metadata;\n}\n","import { map } from \"lodash\";\n\nexport function toHalfwidth(str: string): string {\n  // Converts a fullwidth character to halfwidth\n  const convertChar = (charCode: number): number => {\n    /**\n     * Standard full width encodings\n     * https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)\n     */\n    if (charCode > 0xff00 && charCode < 0xff5f) {\n      return 0x0020 + (charCode - 0xff00);\n    }\n\n    // space:\n    if (charCode === 0x3000) {\n      return 0x0020;\n    }\n\n    /**\n     * Exceptions found in Melee/Japanese keyboards\n     */\n    // single quote: '\n    if (charCode === 0x2019) {\n      return 0x0027;\n    }\n\n    // double quote: \"\n    if (charCode === 0x201d) {\n      return 0x0022;\n    }\n\n    return charCode;\n  };\n\n  const ret = map(str, (char) => convertChar(char.charCodeAt(0)));\n\n  return String.fromCharCode(...ret);\n}\n","import type { StatOptions, StatsType } from \"./stats\";\nimport {\n  ActionsComputer,\n  ComboComputer,\n  ConversionComputer,\n  generateOverallStats,\n  InputComputer,\n  Stats,\n  StockComputer,\n} from \"./stats\";\n// Type imports\nimport type { FrameEntryType, GameEndType, GameStartType, MetadataType } from \"./types\";\nimport { SlpParser, SlpParserEvent } from \"./utils/slpParser\";\nimport type { SlpReadInput } from \"./utils/slpReader\";\nimport { closeSlpFile, getMetadata, iterateEvents, openSlpFile, SlpInputSource } from \"./utils/slpReader\";\n\nvar Buffer = require(\"buffer/\").Buffer;\n\n/**\n * Slippi Game class that wraps a file\n */\nexport class SlippiGame {\n  private input: SlpReadInput;\n  private metadata: MetadataType | null = null;\n  private finalStats: StatsType | null = null;\n  private parser: SlpParser;\n  private readPosition: number | null = null;\n  private actionsComputer: ActionsComputer = new ActionsComputer();\n  private conversionComputer: ConversionComputer = new ConversionComputer();\n  private comboComputer: ComboComputer = new ComboComputer();\n  private stockComputer: StockComputer = new StockComputer();\n  private inputComputer: InputComputer = new InputComputer();\n  protected statsComputer: Stats;\n\n  public constructor(input: any, opts?: StatOptions) {\n    this.input = {\n      source: SlpInputSource.BUFFER,\n      // buffer: Buffer.from(input),\n      buffer: Buffer.from(input.buffer),\n    };\n    // if (typeof input === \"string\") {\n    //   this.input = {\n    //     source: SlpInputSource.FILE,\n    //     filePath: input,\n    //   };\n    // } else if (input instanceof Buffer) {\n    //   this.input = {\n    //     source: SlpInputSource.BUFFER,\n    //     buffer: input,\n    //   };\n    // } else if (input instanceof ArrayBuffer) {\n    //   this.input = {\n    //     source: SlpInputSource.BUFFER,\n    //     buffer: Buffer.from(input),\n    //   };\n    // } else {\n    //   throw new Error(\"Cannot create SlippiGame with input of that type\");\n    // }\n\n    // Set up stats calculation\n    this.statsComputer = new Stats(opts);\n    this.statsComputer.register(\n      this.actionsComputer,\n      this.comboComputer,\n      this.conversionComputer,\n      this.inputComputer,\n      this.stockComputer,\n    );\n    this.parser = new SlpParser();\n    this.parser.on(SlpParserEvent.SETTINGS, (settings) => {\n      this.statsComputer.setup(settings);\n    });\n    // Use finalized frames for stats computation\n    this.parser.on(SlpParserEvent.FINALIZED_FRAME, (frame: FrameEntryType) => {\n      this.statsComputer.addFrame(frame);\n    });\n  }\n\n  private _process(settingsOnly = false): void {\n    if (this.parser.getGameEnd() !== null) {\n      return;\n    }\n    const slpfile = openSlpFile(this.input);\n    // Generate settings from iterating through file\n    this.readPosition = iterateEvents(\n      slpfile,\n      (command, payload) => {\n        if (!payload) {\n          // If payload is falsy, keep iterating. The parser probably just doesn't know\n          // about this command yet\n          return false;\n        }\n        this.parser.handleCommand(command, payload);\n        return settingsOnly && this.parser.getSettings() !== null;\n      },\n      this.readPosition,\n    );\n    closeSlpFile(slpfile);\n  }\n\n  /**\n   * Gets the game settings, these are the settings that describe the starting state of\n   * the game such as characters, stage, etc.\n   */\n  public getSettings(): GameStartType | null {\n    // Settings is only complete after post-frame update\n    this._process(true);\n    return this.parser.getSettings();\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    this._process();\n    return this.parser.getLatestFrame();\n  }\n\n  public getGameEnd(): GameEndType | null {\n    this._process();\n    return this.parser.getGameEnd();\n  }\n\n  public getStats(): StatsType | null {\n    if (this.finalStats) {\n      return this.finalStats;\n    }\n\n    this._process();\n\n    const settings = this.parser.getSettings();\n    if (settings === null) {\n      return null;\n    }\n\n    // Finish processing if we're not up to date\n    this.statsComputer.process();\n    const inputs = this.inputComputer.fetch();\n    const stocks = this.stockComputer.fetch();\n    const conversions = this.conversionComputer.fetch();\n    const playableFrameCount = this.parser.getPlayableFrameCount();\n    const overall = generateOverallStats({ settings, inputs, conversions, playableFrameCount });\n\n    const stats = {\n      lastFrame: this.parser.getLatestFrameNumber(),\n      playableFrameCount,\n      stocks: stocks,\n      conversions: conversions,\n      combos: this.comboComputer.fetch(),\n      actionCounts: this.actionsComputer.fetch(),\n      overall: overall,\n      gameComplete: this.parser.getGameEnd() !== null,\n    };\n\n    if (this.parser.getGameEnd() !== null) {\n      // If the game is complete, store a cached version of stats because it should not\n      // change anymore. Ideally the statsCompuer.process and fetch functions would simply do no\n      // work in this case instead but currently the conversions fetch function,\n      // generateOverallStats, and maybe more are doing work on every call.\n      this.finalStats = stats;\n    }\n\n    return stats;\n  }\n\n  public getMetadata(): MetadataType | null {\n    if (this.metadata) {\n      return this.metadata;\n    }\n    const slpfile = openSlpFile(this.input);\n    this.metadata = getMetadata(slpfile);\n    closeSlpFile(slpfile);\n    return this.metadata;\n  }\n}\n","import { SlippiGame } from \"@slippi/slippi-js\";\n\ndeclare var FileReaderSync: any;\ndeclare var self: any;\n\nconst invalidMetadata = metadata => {\n  if (!metadata || !metadata.lastFrame) return true;\n  if (metadata.lastFrame < 60*40) return true;\n  if (!metadata.startAt.startsWith('2025')) return true;\n  if (Object.keys(metadata.players).length !== 2) return true;\n  if (!metadata.players[0]?.names?.netplay) return true;\n  if (!metadata.players[0]?.names?.code)    return true;\n  if (!metadata.players[1]?.names?.netplay) return true;\n  if (!metadata.players[1]?.names?.code)    return true;\n  const char_p0 = Object.keys(metadata.players[0].characters)[0];\n  if (char_p0 > 26) return true;\n  const char_p1 = Object.keys(metadata.players[1].characters)[0];\n  if (char_p1 > 26) return true;\n  return false;\n};\n\nconst VALID_STAGE_IDs = [2, 3, 8, 28, 31, 32];\nconst invalidStats = ({ stocks, inputs }, settings) => {\n  if (settings.is_teams) return true;\n  if (!VALID_STAGE_IDs.includes(settings.stageId)) return true;\n  if (![2, 8].includes(settings.gameMode)) return true;\n\n  // Check if both players had 2+ stocks at the end\n  const p0_deaths = stocks.filter(s => s.playerIndex === 0 && s.endFrame).length;\n  const p1_deaths = stocks.filter(s => s.playerIndex === 1 && s.endFrame).length;\n  if (p0_deaths <= 2 && p1_deaths <= 2) return true;\n\n  // Check if when quitting out, both players where grounded\n  const player_0_airborne = inputs[0].airborne;\n  const player_1_airborne = inputs[1].airborne;\n  if (!player_0_airborne && !player_1_airborne) return true;\n\n  return false;\n};\n\nconst reader = new FileReaderSync();\nconst processGame = file => {\n  try {\n    const result = reader.readAsArrayBuffer(file);\n    const game = new SlippiGame(new Uint8Array(result));\n\n    const metadata = game.getMetadata();\n    if (invalidMetadata(metadata)) return null;\n    const settings = game.getSettings();\n    const stats = game.getStats();\n    const lf = game.getLatestFrame();\n    stats.inputs = [ // We add this here for retrocompability, we should do this in marahslp\n      { airborne: lf?.players?.[0]?.post?.isAirborne || false },\n      { airborne: lf?.players?.[1]?.post?.isAirborne || false },\n    ];\n    stats.settings = settings;\n    stats.last_combo = stats.combos.at(-1);\n    stats.combos = [];\n    game.input = {};\n    console.log('Processed game:', { metadata, settings, stats });\n    if (invalidStats(stats, settings)) return null;\n\n    return {\n      metadata,\n      stats,\n    };\n  } catch (e) {\n    console.log('SLIPPI-JS ERROR:', e);\n    return null;\n  }\n};\n\nself.onmessage = async ({ data }) => {\n  const file = data.file;\n  const result = processGame(file);\n  self.postMessage(result);\n};\n"],"names":["State","Timers","getSinglesPlayerPermutationsFromSettings","settings","players","length","playerIndex","opponentIndex","didLoseStock","frame","prevFrame","stocksRemaining","isDamaged","state","DAMAGE_START","DAMAGE_END","DAMAGE_FALL","isGrabbed","CAPTURE_START","CAPTURE_END","isCommandGrabbed","COMMAND_GRAB_RANGE1_START","COMMAND_GRAB_RANGE1_END","COMMAND_GRAB_RANGE2_START","COMMAND_GRAB_RANGE2_END","BARREL_WAIT","isDead","DYING_START","DYING_END","calcDamageTaken","_frame$percent","percent","_prevFrame$percent","dashDanceAnimations","DASH","TURN","ActionsComputer","playerPermutations","Array","Map","setup","this","forEach","indices","playerState","playerCounts","wavedashCount","wavelandCount","airDodgeCount","dashDanceCount","spotDodgeCount","ledgegrabCount","rollCount","lCancelCount","success","fail","grabCount","throwCount","up","forward","back","down","groundTechCount","away","in","neutral","wallTechCount","animations","set","processFrame","get","playerFrame","post","opponentFrame","incrementCount","field","condition","current","currentAnimation","actionStateId","push","last3Frames","slice","prevAnimation","newAnimation","didDashDance","isEqual","didRoll","previousAnimation","isCurrentlyRolling","isRolling","wasPreviouslyRolling","didStartRoll","didSpotDodge","isCurrentlyDodging","isSpotDodging","wasPreviouslyDodging","didStartSpotDodge","didAirDodge","isAirDodging","didStartAirDodge","didGrabLedge","isCurrentlyGrabbingLedge","isGrabbingLedge","wasPreviouslyGrabbingLedge","didStartLedgegrab","didGrabSucceed","GRAB","GRAB_WAIT","didStartGrabSuccess","didGrabFail","didStartGrabFail","THROW_UP","THROW_FORWARD","THROW_DOWN","THROW_BACK","animation","TECH_MISS_DOWN","TECH_MISS_UP","opponentDir","facingOpponent","positionX","facingDirection","FORWARD_TECH","BACKWARD_TECH","NEUTRAL_TECH","WALL_TECH","MISSED_WALL_TECH","AERIAL_ATTACK_START","AERIAL_ATTACK_END","isAerialAttack","lCancelStatus","counts","last","isSpecialLanding","LANDING_FALL_SPECIAL","isAcceptablePrevious","AIR_DODGE","isAboveMin","CONTROLLED_JUMP_START","isBelowMax","CONTROLLED_JUMP_END","isWavedashInitiationAnimation","recentFrames","recentAnimations","keyBy","size","ACTION_KNEE_BEND","handleActionWavedash","handleActionCompute","fetch","from","values","map","val","ROLL_BACKWARD","ROLL_FORWARD","SPOT_DODGE","CLIFF_CATCH","ComboEvent","ComboComputer","EventEmitter","combos","combo","move","resetCounter","lastHitAnimation","event","allFrames","frames","currentFrameNumber","prevFrameNumber","prevPlayerFrame","prevOpponentFrame","oppActionStateId","opntIsDamaged","opntIsGrabbed","opntIsCommandGrabbed","opntDamageTaken","actionChangedSinceHit","actionCounter","actionStateCounter","prevActionCounter","actionFrameCounterReset","comboStarted","_prevOpponentFrame$pe","_opponentFrame$percen","startFrame","endFrame","startPercent","currentPercent","endPercent","moves","didKill","lastHitBy","moveId","lastAttackLanded","hitCount","damage","COMBO_EXTEND","COMBO_START","opntIsTeching","TECH_START","TECH_END","isTeching","opntIsDowned","DOWN_START","DOWN_END","isDown","opntDidLoseStock","opntIsDying","_opponentFrame$percen2","shouldTerminate","_prevOpponentFrame$pe2","COMBO_END","handleComboCompute","emit","Command","GameMode","Frames","JoystickRegion","ConversionComputer","constructor","super","conversions","metadata","lastEndFrameByOppIdx","conversion","terminated","openingType","opntInControl","ground","GROUNDED_CONTROL_START","GROUNDED_CONTROL_END","squat","SQUAT_START","SQUAT_END","groundAttack","GROUND_ATTACK_START","GROUND_ATTACK_END","isGrab","isInControl","shouldStartResetCounter","shouldContinueResetCounter","handleConversionCompute","_populateConversionTypes","conversionsToHandle","filter","groupedConversions","groupBy","orderBy","isTrade","lastMove","oppEndFrame","isCounterAttack","InputComputer","inputCount","joystickInputCount","cstickInputCount","buttonInputCount","triggerInputCount","pre","FIRST_PLAYABLE","invertedPreviousButtons","physicalButtons","currentButtons","newInputsPressed","x","count","bits","countSetBits","prevAnalogRegion","getJoystickRegion","joystickX","joystickY","currentAnalogRegion","DZ","prevCstickRegion","cStickX","cStickY","currentCstickRegion","physicalLTrigger","physicalRTrigger","handleInputCompute","y","region","NE","SE","SW","NW","N","E","S","W","getRatio","total","ratio","getOpeningRatio","conversionsByPlayerByOpening","opponentIndices","type","openings","opponentOpenings","flatten","getBeneficialTradeRatio","playerTrades","opponentTrades","benefitsPlayer","zip","conversionPair","playerConversion","first","opponentConversion","playerDamage","opponentDamage","defaultOptions","processOnTheFly","Stats","options","lastProcessedFrame","allComputers","Object","assign","v","comp","register","arguments","process","i","FIRST","isCompletedFrame","addFrame","player","StockComputer","stocks","stock","_prevPlayerFrame$perc","deathAnimation","_playerFrame$percent","handleStockCompute","RollbackCounter","rollbackFrames","rollbackFrameCount","rollbackPlayerIdx","lastFrameWasRollback","currentRollbackLength","rollbackLengths","checkIfRollbackFrame","currentFrame","playerIdx","getFrames","getCount","getLengths","SlpParserEvent","defaultSlpParserOptions","strict","SlpParser","rollbackCounter","gameEnd","latestFrameIndex","settingsComplete","lastFinalizedFrame","handleCommand","command","payload","GAME_START","_handleGameStart","POST_FRAME_UPDATE","_handlePostFrameUpdate","_handleFrameUpdate","PRE_FRAME_UPDATE","ITEM_UPDATE","_handleItemUpdate","FRAME_BOOKEND","_handleFrameBookend","GAME_END","_handleGameEnd","reset","getLatestFrameNumber","_this$latestFrameInde","getPlayableFrameCount","getLatestFrame","frameIndex","indexToUse","getSettings","getGameEnd","getRollbackFrames","lengths","getFrame","num","_finalizeFrames","END","slpVersion","semver","_completeSettings","playersByIndex","internalCharacterId","characterId","location","isFollower","ROLLBACK_FRAME","FRAME","items","_this$frames$currentF","_this$frames$currentF2","latestFinalizedFrame","gameMode","ONLINE","Error","concat","frameToFinalize","playerFrameInfo","preOrPost","FINALIZED_FRAME","SETTINGS","SlpInputSource","toHalfwidth","str","ret","char","convertChar","charCode","charCodeAt","String","fromCharCode","readRef","ref","buffer","offset","position","source","BUFFER","getLenRef","openSlpFile","input","getRef","rawDataPosition","Buffer","Uint8Array","getRawDataPosition","rawDataLength","fileSize","rawDataLen","getRawDataLength","metadataPosition","metadataLength","len","getMetadataLength","messageSizes","MESSAGE_SIZES","payloadLength","messageSizesBuffer","getMessageSizes","require","parseMessage","view","DataView","getPlayerObject","cfOffset","dashback","readUint32","cfOption","nametagStart","nametagBuf","nameTagString","iconv","split","shift","nametag","displayNameStart","displayNameBuf","displayNameString","displayName","connectCodeStart","connectCodeBuf","connectCodeString","connectCode","port","readUint8","characterColor","startStocks","teamId","controllerFix","isTeams","readBool","isPAL","stageId","readUint16","scene","readInt32","seed","readFloat","positionY","trigger","buttons","selfInducedSpeeds","airX","attackX","attackY","groundX","shieldSize","currentComboCount","miscActionState","isAirborne","lastGroundId","jumpsRemaining","hurtboxCollisionState","typeId","velocityX","velocityY","damageTaken","expirationTimer","spawnId","missileType","turnipFace","chargeShotLaunched","chargePower","owner","readInt8","gameEndMethod","lrasInitiatorIndex","canReadFromView","byteLength","getFloat32","getInt32","getInt8","getUint32","getUint16","getUint8","SlippiGame","opts","finalStats","parser","readPosition","actionsComputer","conversionComputer","comboComputer","stockComputer","inputComputer","statsComputer","on","_process","settingsOnly","undefined","slpfile","slpFile","callback","startPos","stopReadingAt","commandPayloadBuffers","mapValues","commandByteBuffer","commandByte","iterateEvents","getStats","inputs","playableFrameCount","overall","_ref","inputsByPlayer","originalConversions","conversionsByPlayer","conv","_conv$moves$","gameMinutes","playerInputs","inputCounts","triggers","cstick","joystick","conversionCount","successfulConversionCount","opp","totalDamage","killCount","successfulConversions","inputsPerMinute","digitalInputsPerMinute","openingsPerKill","damagePerOpening","neutralWinRatio","counterHitRatio","beneficialTradeRatio","generateOverallStats","stats","lastFrame","actionCounts","gameComplete","getMetadata","decode","ex","VALID_STAGE_IDs","reader","FileReaderSync","processGame","file","_lf$players","_lf$players$","_lf$players$$post","_lf$players2","_lf$players2$","_lf$players2$$post","result","readAsArrayBuffer","game","_metadata$players$","_metadata$players$$na","_metadata$players$2","_metadata$players$2$n","_metadata$players$3","_metadata$players$3$n","_metadata$players$4","_metadata$players$4$n","startAt","startsWith","keys","names","netplay","code","characters","invalidMetadata","lf","airborne","last_combo","at","console","log","invalidStats","is_teams","includes","p0_deaths","s","p1_deaths","player_0_airborne","player_1_airborne","e","self","onmessage","async","data","_ref2","postMessage"],"ignoreList":[],"sourceRoot":""}