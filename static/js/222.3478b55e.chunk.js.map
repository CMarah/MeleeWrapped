{"version":3,"file":"static/js/222.3478b55e.chunk.js","mappings":"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","sources":["lib/worker.js","../../marahslp/src/melee/types.ts","../../marahslp/src/melee/characters.ts","../../marahslp/src/melee/moves.ts","../../marahslp/src/melee/stages.ts","../../marahslp/src/stats/common.ts","../../marahslp/src/stats/actions.ts","../../marahslp/src/stats/combos.ts","../../marahslp/src/types.ts","../../marahslp/src/stats/inputs.ts","../../marahslp/src/stats/conversions.ts","../../marahslp/src/stats/overall.ts","../../marahslp/src/stats/stats.ts","../../marahslp/src/reading/browserReading.ts","../../marahslp/src/stats/stocks.ts","../../marahslp/src/reading/fullwidth.ts","../../marahslp/src/reading/slpReader.ts","../../marahslp/src/utils/slpStream.ts","../../marahslp/src/utils/slpParser.ts","../../marahslp/src/utils/slpFile.ts","../../marahslp/src/utils/rollbackCounter.ts","../../marahslp/src/SlippiGame.ts","../../marahslp/src/reading/index.ts","../../marahslp/src/reading/metadata.ts"],"sourcesContent":["import { SlippiGame } from \"@slippi/slippi-js\";\n\ndeclare var FileReaderSync: any;\ndeclare var self: any;\n\nconst invalidMetadata = metadata => {\n  if (metadata.lastFrame < 60*40) return true;\n  if (!metadata.startAt.startsWith('2022')) return true;\n  if (Object.keys(metadata.players).length !== 2) return true;\n  if (!metadata.players[0]?.names?.netplay) return true;\n  if (!metadata.players[0]?.names?.code)    return true;\n  if (!metadata.players[1]?.names?.netplay) return true;\n  if (!metadata.players[1]?.names?.code)    return true;\n  return false;\n};\n\nconst VALID_STAGE_IDs = [2, 3, 8, 28, 31, 32];\nconst invalidStats = ({ settings, stocks, inputs }) => {\n  if (settings.is_teams) return true;\n  if (!VALID_STAGE_IDs.includes(settings.stageId)) return true;\n  if (![2, 8].includes(settings.gameMode)) return true;\n\n  // Check if both players had 2+ stocks at the end\n  const p0_deaths = stocks.filter(s => s.playerIndex === 0 && s.endFrame).length;\n  const p1_deaths = stocks.filter(s => s.playerIndex === 1 && s.endFrame).length;\n  if (p0_deaths <= 2 && p1_deaths <= 2) return true;\n\n  // Check if when quitting out, both players where grounded\n  const player_0_airborne = inputs[0].airborne;\n  const player_1_airborne = inputs[1].airborne;\n  if (!player_0_airborne && !player_1_airborne) return true;\n\n  return false;\n};\n\nconst reader = new FileReaderSync();\nconst processGame = file => {\n  const result = reader.readAsArrayBuffer(file);\n  const game = new SlippiGame(new Uint8Array(result));\n\n  const metadata = game.getMetadata();\n  if (invalidMetadata(metadata)) return null;\n  const stats = game.getStats();\n  if (invalidStats(stats)) return null;\n\n  return {\n    metadata,\n    stats,\n  };\n};\n\nself.onmessage = async ({ data }) => {\n  const file = data.file;\n  const result = processGame(file);\n  self.postMessage(result);\n};\n","export enum Character {\n  CAPTAIN_FALCON = 0,\n  DONKEY_KONG = 1,\n  FOX = 2,\n  GAME_AND_WATCH = 3,\n  KIRBY = 4,\n  BOWSER = 5,\n  LINK = 6,\n  LUIGI = 7,\n  MARIO = 8,\n  MARTH = 9,\n  MEWTWO = 10,\n  NESS = 11,\n  PEACH = 12,\n  PIKACHU = 13,\n  ICE_CLIMBERS = 14,\n  JIGGLYPUFF = 15,\n  SAMUS = 16,\n  YOSHI = 17,\n  ZELDA = 18,\n  SHEIK = 19,\n  FALCO = 20,\n  YOUNG_LINK = 21,\n  DR_MARIO = 22,\n  ROY = 23,\n  PICHU = 24,\n  GANONDORF = 25,\n  MASTER_HAND = 26,\n  WIREFRAME_MALE = 27,\n  WIREFRAME_FEMALE = 28,\n  GIGA_BOWSER = 29,\n  CRAZY_HAND = 30,\n  SANDBAG = 31,\n  POPO = 32,\n}\n\nexport enum Stage {\n  FOUNTAIN_OF_DREAMS = 2,\n  POKEMON_STADIUM = 3,\n  PEACHS_CASTLE = 4,\n  KONGO_JUNGLE = 5,\n  BRINSTAR = 6,\n  CORNERIA = 7,\n  YOSHIS_STORY = 8,\n  ONETT = 9,\n  MUTE_CITY = 10,\n  RAINBOW_CRUISE = 11,\n  JUNGLE_JAPES = 12,\n  GREAT_BAY = 13,\n  HYRULE_TEMPLE = 14,\n  BRINSTAR_DEPTHS = 15,\n  YOSHIS_ISLAND = 16,\n  GREEN_GREENS = 17,\n  FOURSIDE = 18,\n  MUSHROOM_KINGDOM = 19,\n  MUSHROOM_KINGDOM_2 = 20,\n  VENOM = 22,\n  POKE_FLOATS = 23,\n  BIG_BLUE = 24,\n  ICICLE_MOUNTAIN = 25,\n  ICETOP = 26,\n  FLAT_ZONE = 27,\n  DREAMLAND = 28,\n  YOSHIS_ISLAND_N64 = 29,\n  KONGO_JUNGLE_N64 = 30,\n  BATTLEFIELD = 31,\n  FINAL_DESTINATION = 32,\n  TARGET_TEST_MARIO = 33,\n  TARGET_TEST_CAPTAIN_FALCON = 34,\n  TARGET_TEST_YOUNG_LINK = 35,\n  TARGET_TEST_DONKEY_KONG = 36,\n  TARGET_TEST_DR_MARIO = 37,\n  TARGET_TEST_FALCO = 38,\n  TARGET_TEST_FOX = 39,\n  TARGET_TEST_ICE_CLIMBERS = 40,\n  TARGET_TEST_KIRBY = 41,\n  TARGET_TEST_BOWSER = 42,\n  TARGET_TEST_LINK = 43,\n  TARGET_TEST_LUIGI = 44,\n  TARGET_TEST_MARTH = 45,\n  TARGET_TEST_MEWTWO = 46,\n  TARGET_TEST_NESS = 47,\n  TARGET_TEST_PEACH = 48,\n  TARGET_TEST_PICHU = 49,\n  TARGET_TEST_PIKACHU = 50,\n  TARGET_TEST_JIGGLYPUFF = 51,\n  TARGET_TEST_SAMUS = 52,\n  TARGET_TEST_SHEIK = 53,\n  TARGET_TEST_YOSHI = 54,\n  TARGET_TEST_ZELDA = 55,\n  TARGET_TEST_GAME_AND_WATCH = 56,\n  TARGET_TEST_ROY = 57,\n  TARGET_TEST_GANONDORF = 58,\n  HOME_RUN_CONTEST = 84,\n}\n","import { Character } from \"./types\";\n\nexport type CharacterColor = string;\nconst DEFAULT_COLOR: CharacterColor = \"Default\";\n\nexport interface CharacterInfo {\n  id: number;\n  name: string;\n  shortName: string;\n  colors: CharacterColor[];\n}\n\nexport const UnknownCharacter: CharacterInfo = {\n  id: -1,\n  name: \"Unknown Character\",\n  shortName: \"Unknown\",\n  colors: [DEFAULT_COLOR],\n};\n\nconst externalCharacters: CharacterInfo[] = [\n  {\n    id: Character.CAPTAIN_FALCON,\n    name: \"Captain Falcon\",\n    shortName: \"Falcon\",\n    colors: [DEFAULT_COLOR, \"Black\", \"Red\", \"White\", \"Green\", \"Blue\"],\n  },\n  {\n    id: Character.DONKEY_KONG,\n    name: \"Donkey Kong\",\n    shortName: \"DK\",\n    colors: [DEFAULT_COLOR, \"Black\", \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.FOX,\n    name: \"Fox\",\n    shortName: \"Fox\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.GAME_AND_WATCH,\n    name: \"Mr. Game & Watch\",\n    shortName: \"G&W\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.KIRBY,\n    name: \"Kirby\",\n    shortName: \"Kirby\",\n    colors: [DEFAULT_COLOR, \"Yellow\", \"Blue\", \"Red\", \"Green\", \"White\"],\n  },\n  {\n    id: Character.BOWSER,\n    name: \"Bowser\",\n    shortName: \"Bowser\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Black\"],\n  },\n  {\n    id: Character.LINK,\n    name: \"Link\",\n    shortName: \"Link\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Black\", \"White\"],\n  },\n  {\n    id: Character.LUIGI,\n    name: \"Luigi\",\n    shortName: \"Luigi\",\n    colors: [DEFAULT_COLOR, \"White\", \"Blue\", \"Red\"],\n  },\n  {\n    id: Character.MARIO,\n    name: \"Mario\",\n    shortName: \"Mario\",\n    colors: [DEFAULT_COLOR, \"Yellow\", \"Black\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.MARTH,\n    name: \"Marth\",\n    shortName: \"Marth\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Green\", \"Black\", \"White\"],\n  },\n  {\n    id: Character.MEWTWO,\n    name: \"Mewtwo\",\n    shortName: \"Mewtwo\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.NESS,\n    name: \"Ness\",\n    shortName: \"Ness\",\n    colors: [DEFAULT_COLOR, \"Yellow\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.PEACH,\n    name: \"Peach\",\n    shortName: \"Peach\",\n    colors: [DEFAULT_COLOR, \"Daisy\", \"White\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.PIKACHU,\n    name: \"Pikachu\",\n    shortName: \"Pikachu\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Party Hat\", \"Cowboy Hat\"],\n  },\n  {\n    id: Character.ICE_CLIMBERS,\n    name: \"Ice Climbers\",\n    shortName: \"ICs\",\n    colors: [DEFAULT_COLOR, \"Green\", \"Orange\", \"Red\"],\n  },\n  {\n    id: Character.JIGGLYPUFF,\n    name: \"Jigglypuff\",\n    shortName: \"Puff\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Headband\", \"Crown\"],\n  },\n  {\n    id: Character.SAMUS,\n    name: \"Samus\",\n    shortName: \"Samus\",\n    colors: [DEFAULT_COLOR, \"Pink\", \"Black\", \"Green\", \"Purple\"],\n  },\n  {\n    id: Character.YOSHI,\n    name: \"Yoshi\",\n    shortName: \"Yoshi\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Yellow\", \"Pink\", \"Cyan\"],\n  },\n  {\n    id: Character.ZELDA,\n    name: \"Zelda\",\n    shortName: \"Zelda\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"White\"],\n  },\n  {\n    id: Character.SHEIK,\n    name: \"Sheik\",\n    shortName: \"Sheik\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"White\"],\n  },\n  {\n    id: Character.FALCO,\n    name: \"Falco\",\n    shortName: \"Falco\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.YOUNG_LINK,\n    name: \"Young Link\",\n    shortName: \"YLink\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"White\", \"Black\"],\n  },\n  {\n    id: Character.DR_MARIO,\n    name: \"Dr. Mario\",\n    shortName: \"Doc\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"Black\"],\n  },\n  {\n    id: Character.ROY,\n    name: \"Roy\",\n    shortName: \"Roy\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"Yellow\"],\n  },\n  {\n    id: Character.PICHU,\n    name: \"Pichu\",\n    shortName: \"Pichu\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\"],\n  },\n  {\n    id: Character.GANONDORF,\n    name: \"Ganondorf\",\n    shortName: \"Ganon\",\n    colors: [DEFAULT_COLOR, \"Red\", \"Blue\", \"Green\", \"Purple\"],\n  },\n];\n\nexport function getAllCharacters(): CharacterInfo[] {\n  return externalCharacters;\n}\n\nexport function getCharacterInfo(externalCharacterId: number): CharacterInfo {\n  const charInfo = externalCharacters[externalCharacterId];\n  if (charInfo) {\n    return charInfo;\n  }\n  return UnknownCharacter;\n}\n\nexport function getCharacterShortName(externalCharacterId: number): string {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.shortName;\n}\n\nexport function getCharacterName(externalCharacterId: number): string {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.name;\n}\n\n// Return a human-readable color from a characterCode.\nexport function getCharacterColorName(externalCharacterId: number, characterColor: number): CharacterColor {\n  const character = getCharacterInfo(externalCharacterId);\n  const color = character.colors[characterColor];\n  if (color) {\n    return color;\n  }\n  return DEFAULT_COLOR;\n}\n","export interface Move {\n  id: number;\n  name: string;\n  shortName: string;\n}\n\nexport const UnknownMove: Move = {\n  id: -1,\n  name: \"Unknown Move\",\n  shortName: \"unknown\",\n};\n\nconst moves: { [id: number]: Move } = {\n  1: {\n    // This includes all thrown items, zair, luigi's taunt, samus bombs, etc\n    id: 1,\n    name: \"Miscellaneous\",\n    shortName: \"misc\",\n  },\n  2: {\n    id: 2,\n    name: \"Jab\",\n    shortName: \"jab\",\n  },\n  3: {\n    id: 3,\n    name: \"Jab\",\n    shortName: \"jab\",\n  },\n  4: {\n    id: 4,\n    name: \"Jab\",\n    shortName: \"jab\",\n  },\n  5: {\n    id: 5,\n    name: \"Rapid Jabs\",\n    shortName: \"rapid-jabs\",\n  },\n  6: {\n    id: 6,\n    name: \"Dash Attack\",\n    shortName: \"dash\",\n  },\n  7: {\n    id: 7,\n    name: \"Forward Tilt\",\n    shortName: \"ftilt\",\n  },\n  8: {\n    id: 8,\n    name: \"Up Tilt\",\n    shortName: \"utilt\",\n  },\n  9: {\n    id: 9,\n    name: \"Down Tilt\",\n    shortName: \"dtilt\",\n  },\n  10: {\n    id: 10,\n    name: \"Forward Smash\",\n    shortName: \"fsmash\",\n  },\n  11: {\n    id: 11,\n    name: \"Up Smash\",\n    shortName: \"usmash\",\n  },\n  12: {\n    id: 12,\n    name: \"Down Smash\",\n    shortName: \"dsmash\",\n  },\n  13: {\n    id: 13,\n    name: \"Neutral Air\",\n    shortName: \"nair\",\n  },\n  14: {\n    id: 14,\n    name: \"Forward Air\",\n    shortName: \"fair\",\n  },\n  15: {\n    id: 15,\n    name: \"Back Air\",\n    shortName: \"bair\",\n  },\n  16: {\n    id: 16,\n    name: \"Up Air\",\n    shortName: \"uair\",\n  },\n  17: {\n    id: 17,\n    name: \"Down Air\",\n    shortName: \"dair\",\n  },\n  18: {\n    id: 18,\n    name: \"Neutral B\",\n    shortName: \"neutral-b\",\n  },\n  19: {\n    id: 19,\n    name: \"Side B\",\n    shortName: \"side-b\",\n  },\n  20: {\n    id: 20,\n    name: \"Up B\",\n    shortName: \"up-b\",\n  },\n  21: {\n    id: 21,\n    name: \"Down B\",\n    shortName: \"down-b\",\n  },\n  50: {\n    id: 50,\n    name: \"Getup Attack\",\n    shortName: \"getup\",\n  },\n  51: {\n    id: 51,\n    name: \"Getup Attack (Slow)\",\n    shortName: \"getup-slow\",\n  },\n  52: {\n    id: 52,\n    name: \"Grab Pummel\",\n    shortName: \"pummel\",\n  },\n  53: {\n    id: 53,\n    name: \"Forward Throw\",\n    shortName: \"fthrow\",\n  },\n  54: {\n    id: 54,\n    name: \"Back Throw\",\n    shortName: \"bthrow\",\n  },\n  55: {\n    id: 55,\n    name: \"Up Throw\",\n    shortName: \"uthrow\",\n  },\n  56: {\n    id: 56,\n    name: \"Down Throw\",\n    shortName: \"dthrow\",\n  },\n  61: {\n    id: 61,\n    name: \"Edge Attack (Slow)\",\n    shortName: \"edge-slow\",\n  },\n  62: {\n    id: 62,\n    name: \"Edge Attack\",\n    shortName: \"edge\",\n  },\n};\n\nexport function getMoveInfo(moveId: number): Move {\n  const m = moves[moveId];\n  if (!m) {\n    return UnknownMove;\n  }\n  return m;\n}\n\nexport function getMoveShortName(moveId: number): string {\n  const move = getMoveInfo(moveId);\n  return move.shortName;\n}\n\nexport function getMoveName(moveId: number): string {\n  const move = getMoveInfo(moveId);\n  return move.name;\n}\n","import { Stage } from \"./types\";\n\nexport interface StageInfo {\n  id: number;\n  name: string;\n}\n\nexport const UnknownStage: StageInfo = {\n  id: -1,\n  name: \"Unknown Stage\",\n};\n\nconst stages: { [id: number]: StageInfo } = {\n  [Stage.FOUNTAIN_OF_DREAMS]: {\n    id: Stage.FOUNTAIN_OF_DREAMS,\n    name: \"Fountain of Dreams\",\n  },\n  [Stage.POKEMON_STADIUM]: {\n    id: Stage.POKEMON_STADIUM,\n    name: \"Pokmon Stadium\",\n  },\n  [Stage.PEACHS_CASTLE]: {\n    id: Stage.PEACHS_CASTLE,\n    name: \"Princess Peach's Castle\",\n  },\n  [Stage.KONGO_JUNGLE]: {\n    id: Stage.KONGO_JUNGLE,\n    name: \"Kongo Jungle\",\n  },\n  [Stage.BRINSTAR]: {\n    id: Stage.BRINSTAR,\n    name: \"Brinstar\",\n  },\n  [Stage.CORNERIA]: {\n    id: Stage.CORNERIA,\n    name: \"Corneria\",\n  },\n  [Stage.YOSHIS_STORY]: {\n    id: Stage.YOSHIS_STORY,\n    name: \"Yoshi's Story\",\n  },\n  [Stage.ONETT]: {\n    id: Stage.ONETT,\n    name: \"Onett\",\n  },\n  [Stage.MUTE_CITY]: {\n    id: Stage.MUTE_CITY,\n    name: \"Mute City\",\n  },\n  [Stage.RAINBOW_CRUISE]: {\n    id: Stage.RAINBOW_CRUISE,\n    name: \"Rainbow Cruise\",\n  },\n  [Stage.JUNGLE_JAPES]: {\n    id: Stage.JUNGLE_JAPES,\n    name: \"Jungle Japes\",\n  },\n  [Stage.GREAT_BAY]: {\n    id: Stage.GREAT_BAY,\n    name: \"Great Bay\",\n  },\n  [Stage.HYRULE_TEMPLE]: {\n    id: Stage.HYRULE_TEMPLE,\n    name: \"Hyrule Temple\",\n  },\n  [Stage.BRINSTAR_DEPTHS]: {\n    id: Stage.BRINSTAR_DEPTHS,\n    name: \"Brinstar Depths\",\n  },\n  [Stage.YOSHIS_ISLAND]: {\n    id: Stage.YOSHIS_ISLAND,\n    name: \"Yoshi's Island\",\n  },\n  [Stage.GREEN_GREENS]: {\n    id: Stage.GREEN_GREENS,\n    name: \"Green Greens\",\n  },\n  [Stage.FOURSIDE]: {\n    id: Stage.FOURSIDE,\n    name: \"Fourside\",\n  },\n  [Stage.MUSHROOM_KINGDOM]: {\n    id: Stage.MUSHROOM_KINGDOM,\n    name: \"Mushroom Kingdom I\",\n  },\n  [Stage.MUSHROOM_KINGDOM_2]: {\n    id: Stage.MUSHROOM_KINGDOM_2,\n    name: \"Mushroom Kingdom II\",\n  },\n  [Stage.VENOM]: {\n    id: Stage.VENOM,\n    name: \"Venom\",\n  },\n  [Stage.POKE_FLOATS]: {\n    id: Stage.POKE_FLOATS,\n    name: \"Pok Floats\",\n  },\n  [Stage.BIG_BLUE]: {\n    id: Stage.BIG_BLUE,\n    name: \"Big Blue\",\n  },\n  [Stage.ICICLE_MOUNTAIN]: {\n    id: Stage.ICICLE_MOUNTAIN,\n    name: \"Icicle Mountain\",\n  },\n  [Stage.ICETOP]: {\n    id: Stage.ICETOP,\n    name: \"Icetop\",\n  },\n  [Stage.FLAT_ZONE]: {\n    id: Stage.FLAT_ZONE,\n    name: \"Flat Zone\",\n  },\n  [Stage.DREAMLAND]: {\n    id: Stage.DREAMLAND,\n    name: \"Dream Land N64\",\n  },\n  [Stage.YOSHIS_ISLAND_N64]: {\n    id: Stage.YOSHIS_ISLAND_N64,\n    name: \"Yoshi's Island N64\",\n  },\n  [Stage.KONGO_JUNGLE_N64]: {\n    id: Stage.KONGO_JUNGLE_N64,\n    name: \"Kongo Jungle N64\",\n  },\n  [Stage.BATTLEFIELD]: {\n    id: Stage.BATTLEFIELD,\n    name: \"Battlefield\",\n  },\n  [Stage.FINAL_DESTINATION]: {\n    id: Stage.FINAL_DESTINATION,\n    name: \"Final Destination\",\n  },\n  [Stage.TARGET_TEST_MARIO]: {\n    id: Stage.TARGET_TEST_MARIO,\n    name: \"Target Test (Mario)\",\n  },\n  [Stage.TARGET_TEST_CAPTAIN_FALCON]: {\n    id: Stage.TARGET_TEST_CAPTAIN_FALCON,\n    name: \"Target Test (Captain Falcon)\",\n  },\n  [Stage.TARGET_TEST_YOUNG_LINK]: {\n    id: Stage.TARGET_TEST_YOUNG_LINK,\n    name: \"Target Test (Young Link)\",\n  },\n  [Stage.TARGET_TEST_DONKEY_KONG]: {\n    id: Stage.TARGET_TEST_DONKEY_KONG,\n    name: \"Target Test (Donkey Kong)\",\n  },\n  [Stage.TARGET_TEST_DR_MARIO]: {\n    id: Stage.TARGET_TEST_DR_MARIO,\n    name: \"Target Test (Dr. Mario)\",\n  },\n  [Stage.TARGET_TEST_FALCO]: {\n    id: Stage.TARGET_TEST_FALCO,\n    name: \"Target Test (Falco)\",\n  },\n  [Stage.TARGET_TEST_FOX]: {\n    id: Stage.TARGET_TEST_FOX,\n    name: \"Target Test (Fox)\",\n  },\n  [Stage.TARGET_TEST_ICE_CLIMBERS]: {\n    id: Stage.TARGET_TEST_ICE_CLIMBERS,\n    name: \"Target Test (Ice Climbers)\",\n  },\n  [Stage.TARGET_TEST_KIRBY]: {\n    id: Stage.TARGET_TEST_KIRBY,\n    name: \"Target Test (Kirby)\",\n  },\n  [Stage.TARGET_TEST_BOWSER]: {\n    id: Stage.TARGET_TEST_BOWSER,\n    name: \"Target Test (Bowser)\",\n  },\n  [Stage.TARGET_TEST_LINK]: {\n    id: Stage.TARGET_TEST_LINK,\n    name: \"Target Test (Link)\",\n  },\n  [Stage.TARGET_TEST_LUIGI]: {\n    id: Stage.TARGET_TEST_LUIGI,\n    name: \"Target Test (Luigi)\",\n  },\n  [Stage.TARGET_TEST_MARTH]: {\n    id: Stage.TARGET_TEST_MARTH,\n    name: \"Target Test (Marth)\",\n  },\n  [Stage.TARGET_TEST_MEWTWO]: {\n    id: Stage.TARGET_TEST_MEWTWO,\n    name: \"Target Test (Mewtwo)\",\n  },\n  [Stage.TARGET_TEST_NESS]: {\n    id: Stage.TARGET_TEST_NESS,\n    name: \"Target Test (Ness)\",\n  },\n  [Stage.TARGET_TEST_PEACH]: {\n    id: Stage.TARGET_TEST_PEACH,\n    name: \"Target Test (Peach)\",\n  },\n  [Stage.TARGET_TEST_PICHU]: {\n    id: Stage.TARGET_TEST_PICHU,\n    name: \"Target Test (Pichu)\",\n  },\n  [Stage.TARGET_TEST_PIKACHU]: {\n    id: Stage.TARGET_TEST_PIKACHU,\n    name: \"Target Test (Pikachu)\",\n  },\n  [Stage.TARGET_TEST_JIGGLYPUFF]: {\n    id: Stage.TARGET_TEST_JIGGLYPUFF,\n    name: \"Target Test (Jigglypuff)\",\n  },\n  [Stage.TARGET_TEST_SAMUS]: {\n    id: Stage.TARGET_TEST_SAMUS,\n    name: \"Target Test (Samus)\",\n  },\n  [Stage.TARGET_TEST_SHEIK]: {\n    id: Stage.TARGET_TEST_SHEIK,\n    name: \"Target Test (Sheik)\",\n  },\n  [Stage.TARGET_TEST_YOSHI]: {\n    id: Stage.TARGET_TEST_YOSHI,\n    name: \"Target Test (Yoshi)\",\n  },\n  [Stage.TARGET_TEST_ZELDA]: {\n    id: Stage.TARGET_TEST_ZELDA,\n    name: \"Target Test (Zelda)\",\n  },\n  [Stage.TARGET_TEST_GAME_AND_WATCH]: {\n    id: Stage.TARGET_TEST_GAME_AND_WATCH,\n    name: \"Target Test (Mr. Game & Watch)\",\n  },\n  [Stage.TARGET_TEST_ROY]: {\n    id: Stage.TARGET_TEST_ROY,\n    name: \"Target Test (Roy)\",\n  },\n  [Stage.TARGET_TEST_GANONDORF]: {\n    id: Stage.TARGET_TEST_GANONDORF,\n    name: \"Target Test (Ganondorf)\",\n  },\n  [Stage.HOME_RUN_CONTEST]: {\n    id: Stage.HOME_RUN_CONTEST,\n    name: \"Home-Run Contest\",\n  },\n};\n\nexport function getStageInfo(stageId: number): StageInfo {\n  const s = stages[stageId];\n  if (!s) {\n    return UnknownStage;\n  }\n  return s;\n}\n\nexport function getStageName(stageId: number): string {\n  const stage = getStageInfo(stageId);\n  return stage.name;\n}\n","import type { GameStartType, PostFrameUpdateType } from \"../types\";\n\nexport interface StatsType {\n  gameComplete: boolean;\n  lastFrame: number;\n  stocks: StockType[];\n  last_combo: ComboType;\n  overall: OverallType[];\n}\n\nexport interface RatioType {\n  count: number;\n  total: number;\n  ratio: number | null;\n}\n\nexport interface PlayerIndexedType {\n  playerIndex: number;\n  opponentIndex: number;\n}\n\nexport interface DurationType {\n  startFrame: number;\n  endFrame?: number | null;\n}\n\nexport interface DamageType {\n  startPercent: number;\n  currentPercent: number;\n  endPercent?: number | null;\n}\n\nexport interface StockType extends DurationType, DamageType {\n  playerIndex: number;\n  count: number;\n  deathAnimation?: number | null;\n}\n\nexport interface MoveLandedType {\n  playerIndex: number;\n  frame: number;\n  moveId: number;\n  hitCount: number;\n  damage: number;\n}\n\nexport interface ComboType extends DurationType, DamageType {\n  playerIndex: number;\n  moves: MoveLandedType[];\n  didKill: boolean;\n  lastHitBy: number | null;\n}\n\nexport interface ConversionType extends ComboType {\n  openingType: string;\n}\n\nexport interface ActionCountsType {\n  playerIndex: number;\n  wavedashCount: number;\n  wavelandCount: number;\n  airDodgeCount: number;\n  dashDanceCount: number;\n  spotDodgeCount: number;\n  ledgegrabCount: number;\n  rollCount: number;\n  lCancelCount: {\n    success: number;\n    fail: number;\n  };\n  grabCount: {\n    success: number;\n    fail: number;\n  };\n  throwCount: {\n    up: number;\n    forward: number;\n    back: number;\n    down: number;\n  };\n  groundTechCount: {\n    // tech away/in are in reference to the opponents position and not the stage\n    away: number;\n    in: number;\n    neutral: number;\n    fail: number;\n  };\n  wallTechCount: {\n    success: number;\n    fail: number;\n  };\n}\n\nexport interface InputCountsType {\n  buttons: number;\n  triggers: number;\n  joystick: number;\n  cstick: number;\n  total: number;\n}\n\nexport interface OverallType {\n  playerIndex: number;\n  totalDamage: number;\n  killCount: number;\n  inputsPerMinute: RatioType;\n  openingsPerKill: RatioType;\n  damagePerOpening: RatioType;\n  neutralWinRatio: RatioType;\n}\n\nexport enum State {\n  // Animation ID ranges\n  DAMAGE_START = 0x4b,\n  DAMAGE_END = 0x5b,\n  CAPTURE_START = 0xdf,\n  CAPTURE_END = 0xe8,\n  GUARD_START = 0xb2,\n  GUARD_END = 0xb6,\n  GROUNDED_CONTROL_START = 0xe,\n  GROUNDED_CONTROL_END = 0x18,\n  SQUAT_START = 0x27,\n  SQUAT_END = 0x29,\n  DOWN_START = 0xb7,\n  DOWN_END = 0xc6,\n  TECH_START = 0xc7,\n  TECH_END = 0xcc,\n  DYING_START = 0x0,\n  DYING_END = 0xa,\n  CONTROLLED_JUMP_START = 0x18,\n  CONTROLLED_JUMP_END = 0x22,\n  GROUND_ATTACK_START = 0x2c,\n  GROUND_ATTACK_END = 0x40,\n  AERIAL_ATTACK_START = 0x41,\n  AERIAL_ATTACK_END = 0x4a,\n\n  // Animation ID specific\n  ROLL_FORWARD = 0xe9,\n  ROLL_BACKWARD = 0xea,\n  SPOT_DODGE = 0xeb,\n  AIR_DODGE = 0xec,\n  ACTION_WAIT = 0xe,\n  ACTION_DASH = 0x14,\n  ACTION_KNEE_BEND = 0x18,\n  GUARD_ON = 0xb2,\n  TECH_MISS_UP = 0xb7,\n  TECH_MISS_DOWN = 0xbf,\n  NEUTRAL_TECH = 0xc7,\n  FORWARD_TECH = 0xc8,\n  BACKWARD_TECH = 0xc9,\n  WALL_TECH = 0xca,\n  MISSED_WALL_TECH = 0xf7,\n  DASH = 0x14,\n  TURN = 0x12,\n  LANDING_FALL_SPECIAL = 0x2b,\n  JUMP_FORWARD = 0x19,\n  JUMP_BACKWARD = 0x1a,\n  FALL_FORWARD = 0x1e,\n  FALL_BACKWARD = 0x1f,\n  GRAB = 0xd4,\n  GRAB_WAIT = 0xd8,\n  PUMMEL = 0xd9,\n  CLIFF_CATCH = 0xfc,\n  THROW_UP = 0xdd,\n  THROW_FORWARD = 0xdb,\n  THROW_DOWN = 0xde,\n  THROW_BACK = 0xdc,\n  DAMAGE_FALL = 0x26,\n\n  // Command Grabs\n  BARREL_WAIT = 0x125,\n  COMMAND_GRAB_RANGE1_START = 0x10a,\n  COMMAND_GRAB_RANGE1_END = 0x130,\n\n  COMMAND_GRAB_RANGE2_START = 0x147,\n  COMMAND_GRAB_RANGE2_END = 0x152,\n}\n\nexport const Timers = {\n  PUNISH_RESET_FRAMES: 45,\n  RECOVERY_RESET_FRAMES: 45,\n  COMBO_STRING_RESET_FRAMES: 45,\n};\n\nexport function getSinglesPlayerPermutationsFromSettings(settings: GameStartType): PlayerIndexedType[] {\n  if (!settings || settings.players.length !== 2) {\n    // Only return opponent indices for singles\n    return [];\n  }\n\n  return [\n    {\n      playerIndex: settings.players[0]!.playerIndex,\n      opponentIndex: settings.players[1]!.playerIndex,\n    },\n    {\n      playerIndex: settings.players[1]!.playerIndex,\n      opponentIndex: settings.players[0]!.playerIndex,\n    },\n  ];\n}\n\nexport function didLoseStock(frame: PostFrameUpdateType, prevFrame: PostFrameUpdateType): boolean {\n  if (!frame || !prevFrame) {\n    return false;\n  }\n\n  return prevFrame.stocksRemaining! - frame.stocksRemaining! > 0;\n}\n\nexport function isInControl(state: number): boolean {\n  const ground = state >= State.GROUNDED_CONTROL_START && state <= State.GROUNDED_CONTROL_END;\n  const squat = state >= State.SQUAT_START && state <= State.SQUAT_END;\n  const groundAttack = state > State.GROUND_ATTACK_START && state <= State.GROUND_ATTACK_END;\n  const isGrab = state === State.GRAB;\n  // TODO: Add grounded b moves?\n  return ground || squat || groundAttack || isGrab;\n}\n\nexport function isTeching(state: number): boolean {\n  return state >= State.TECH_START && state <= State.TECH_END;\n}\n\nexport function isDown(state: number): boolean {\n  return state >= State.DOWN_START && state <= State.DOWN_END;\n}\n\nexport function isDamaged(state: number): boolean {\n  return (state >= State.DAMAGE_START && state <= State.DAMAGE_END) || state === State.DAMAGE_FALL;\n}\n\nexport function isGrabbed(state: number): boolean {\n  return state >= State.CAPTURE_START && state <= State.CAPTURE_END;\n}\n\n// TODO: Find better implementation of 3 seperate ranges\nexport function isCommandGrabbed(state: number): boolean {\n  return (\n    ((state >= State.COMMAND_GRAB_RANGE1_START && state <= State.COMMAND_GRAB_RANGE1_END) ||\n      (state >= State.COMMAND_GRAB_RANGE2_START && state <= State.COMMAND_GRAB_RANGE2_END)) &&\n    state !== State.BARREL_WAIT\n  );\n}\n\nexport function isDead(state: number): boolean {\n  return state >= State.DYING_START && state <= State.DYING_END;\n}\n\nexport function calcDamageTaken(frame: PostFrameUpdateType, prevFrame: PostFrameUpdateType): number {\n  const percent = frame.percent ?? 0;\n  const prevPercent = prevFrame.percent ?? 0;\n\n  return percent - prevPercent;\n}\n","import { get, isEqual, keyBy, last, set, size } from \"lodash\";\n\nimport type { FrameEntryType, GameStartType } from \"../types\";\nimport type { ActionCountsType, PlayerIndexedType } from \"./common\";\nimport { getSinglesPlayerPermutationsFromSettings, State } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\n// Frame pattern that indicates a dash dance turn was executed\nconst dashDanceAnimations = [State.DASH, State.TURN, State.DASH];\n\ninterface PlayerActionState {\n  playerCounts: ActionCountsType;\n  animations: number[];\n}\n\nexport class ActionsComputer implements StatComputer<ActionCountsType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, PlayerActionState>();\n\n  public setup(settings: GameStartType): void {\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach((indices) => {\n      const playerCounts: ActionCountsType = {\n        playerIndex: indices.playerIndex,\n        wavedashCount: 0,\n        wavelandCount: 0,\n        airDodgeCount: 0,\n        dashDanceCount: 0,\n        spotDodgeCount: 0,\n        ledgegrabCount: 0,\n        rollCount: 0,\n        lCancelCount: {\n          success: 0,\n          fail: 0,\n        },\n        grabCount: {\n          success: 0,\n          fail: 0,\n        },\n        throwCount: {\n          up: 0,\n          forward: 0,\n          back: 0,\n          down: 0,\n        },\n        groundTechCount: {\n          // tech away/in are in reference to the opponents position and not the stage\n          away: 0,\n          in: 0,\n          neutral: 0,\n          fail: 0,\n        },\n        wallTechCount: {\n          success: 0,\n          fail: 0,\n        },\n      };\n      const playerState: PlayerActionState = {\n        playerCounts: playerCounts,\n        animations: [],\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleActionCompute(state, indices, frame);\n      }\n    });\n  }\n\n  public fetch(): ActionCountsType[] {\n    return Array.from(this.state.values()).map((val) => val.playerCounts);\n  }\n}\n\nfunction didMissGroundTech(animation: State): boolean {\n  return animation === State.TECH_MISS_DOWN || animation === State.TECH_MISS_UP;\n}\n\nfunction isRolling(animation: State): boolean {\n  return animation === State.ROLL_BACKWARD || animation === State.ROLL_FORWARD;\n}\n\nfunction didStartRoll(currentAnimation: number, previousAnimation: number): boolean {\n  const isCurrentlyRolling = isRolling(currentAnimation);\n  const wasPreviouslyRolling = isRolling(previousAnimation);\n\n  return isCurrentlyRolling && !wasPreviouslyRolling;\n}\n\nfunction isSpotDodging(animation: State): boolean {\n  return animation === State.SPOT_DODGE;\n}\n\nfunction didStartGrabSuccess(currentAnimation: State, previousAnimation: State): boolean {\n  return previousAnimation === State.GRAB && currentAnimation <= State.GRAB_WAIT && currentAnimation > State.GRAB;\n}\nfunction didStartGrabFail(currentAnimation: State, previousAnimation: State): boolean {\n  return previousAnimation === State.GRAB && (currentAnimation > State.GRAB_WAIT || currentAnimation < State.GRAB);\n}\n\nfunction didStartSpotDodge(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyDodging = isSpotDodging(currentAnimation);\n  const wasPreviouslyDodging = isSpotDodging(previousAnimation);\n\n  return isCurrentlyDodging && !wasPreviouslyDodging;\n}\n\nfunction isAirDodging(animation: State): boolean {\n  return animation === State.AIR_DODGE;\n}\n\nfunction didStartAirDodge(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyDodging = isAirDodging(currentAnimation);\n  const wasPreviouslyDodging = isAirDodging(previousAnimation);\n\n  return isCurrentlyDodging && !wasPreviouslyDodging;\n}\n\nfunction isGrabbingLedge(animation: State): boolean {\n  return animation === State.CLIFF_CATCH;\n}\n\nfunction isAerialAttack(animation: State): boolean {\n  return animation >= State.AERIAL_ATTACK_START && animation <= State.AERIAL_ATTACK_END;\n}\n\nfunction didStartLedgegrab(currentAnimation: State, previousAnimation: State): boolean {\n  const isCurrentlyGrabbingLedge = isGrabbingLedge(currentAnimation);\n  const wasPreviouslyGrabbingLedge = isGrabbingLedge(previousAnimation);\n\n  return isCurrentlyGrabbingLedge && !wasPreviouslyGrabbingLedge;\n}\n\nfunction handleActionCompute(state: PlayerActionState, indices: PlayerIndexedType, frame: FrameEntryType): void {\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n  const incrementCount = (field: string, condition: boolean): void => {\n    if (!condition) {\n      return;\n    }\n\n    const current: number = get(state.playerCounts, field, 0);\n    set(state.playerCounts, field, current + 1);\n  };\n\n  // Manage animation state\n  const currentAnimation = playerFrame.actionStateId!;\n  state.animations.push(currentAnimation);\n\n  // Grab last 3 frames\n  const last3Frames = state.animations.slice(-3);\n  const prevAnimation = last3Frames[last3Frames.length - 2] as number;\n  const newAnimation = currentAnimation !== prevAnimation;\n\n  // Increment counts based on conditions\n  const didDashDance = isEqual(last3Frames, dashDanceAnimations);\n  incrementCount(\"dashDanceCount\", didDashDance);\n\n  const didRoll = didStartRoll(currentAnimation, prevAnimation);\n  incrementCount(\"rollCount\", didRoll);\n\n  const didSpotDodge = didStartSpotDodge(currentAnimation, prevAnimation);\n  incrementCount(\"spotDodgeCount\", didSpotDodge);\n\n  const didAirDodge = didStartAirDodge(currentAnimation, prevAnimation);\n  incrementCount(\"airDodgeCount\", didAirDodge);\n\n  const didGrabLedge = didStartLedgegrab(currentAnimation, prevAnimation);\n  incrementCount(\"ledgegrabCount\", didGrabLedge);\n\n  const didGrabSucceed = didStartGrabSuccess(currentAnimation, prevAnimation);\n  incrementCount(\"grabCount.success\", didGrabSucceed);\n  const didGrabFail = didStartGrabFail(currentAnimation, prevAnimation);\n  incrementCount(\"grabCount.fail\", didGrabFail);\n\n  incrementCount(\"throwCount.up\", currentAnimation === State.THROW_UP && newAnimation);\n  incrementCount(\"throwCount.forward\", currentAnimation === State.THROW_FORWARD && newAnimation);\n  incrementCount(\"throwCount.down\", currentAnimation === State.THROW_DOWN && newAnimation);\n  incrementCount(\"throwCount.back\", currentAnimation === State.THROW_BACK && newAnimation);\n\n  if (newAnimation) {\n    const didMissTech = didMissGroundTech(currentAnimation);\n    incrementCount(\"groundTechCount.fail\", didMissTech);\n    let opponentDir = 1;\n    let facingOpponent = false;\n\n    if (playerFrame.positionX! > opponentFrame.positionX!) {\n      opponentDir = -1;\n    }\n    if (playerFrame.facingDirection == opponentDir) {\n      facingOpponent = true;\n    }\n\n    incrementCount(\"groundTechCount.in\", currentAnimation === State.FORWARD_TECH && facingOpponent);\n    incrementCount(\"groundTechCount.in\", currentAnimation === State.BACKWARD_TECH && !facingOpponent);\n    incrementCount(\"groundTechCount.neutral\", currentAnimation === State.NEUTRAL_TECH);\n    incrementCount(\"groundTechCount.away\", currentAnimation === State.BACKWARD_TECH && facingOpponent);\n    incrementCount(\"groundTechCount.away\", currentAnimation === State.FORWARD_TECH && !facingOpponent);\n\n    incrementCount(\"wallTechCount.success\", currentAnimation === State.WALL_TECH);\n    incrementCount(\"wallTechCount.fail\", currentAnimation === State.MISSED_WALL_TECH);\n  }\n\n  if (isAerialAttack(currentAnimation)) {\n    incrementCount(\"lCancelCount.success\", playerFrame.lCancelStatus === 1);\n    incrementCount(\"lCancelCount.fail\", playerFrame.lCancelStatus === 2);\n  }\n\n  // Handles wavedash detection (and waveland)\n  handleActionWavedash(state.playerCounts, state.animations);\n}\n\nfunction handleActionWavedash(counts: ActionCountsType, animations: State[]): void {\n  const currentAnimation = last(animations);\n  const prevAnimation = animations[animations.length - 2] as number;\n\n  const isSpecialLanding = currentAnimation === State.LANDING_FALL_SPECIAL;\n  const isAcceptablePrevious = isWavedashInitiationAnimation(prevAnimation);\n  const isPossibleWavedash = isSpecialLanding && isAcceptablePrevious;\n\n  if (!isPossibleWavedash) {\n    return;\n  }\n\n  // Here we special landed, it might be a wavedash, let's check\n  // We grab the last 8 frames here because that should be enough time to execute a\n  // wavedash. This number could be tweaked if we find false negatives\n  const recentFrames = animations.slice(-8);\n  const recentAnimations = keyBy(recentFrames, (animation) => animation);\n\n  if (size(recentAnimations) === 2 && recentAnimations[State.AIR_DODGE]) {\n    // If the only other animation is air dodge, this might be really late to the point\n    // where it was actually an air dodge. Air dodge animation is really long\n    return;\n  }\n\n  if (recentAnimations[State.AIR_DODGE]) {\n    // If one of the recent animations was an air dodge, let's remove that from the\n    // air dodge counter, we don't want to count air dodges used to wavedash/land\n    counts.airDodgeCount -= 1;\n  }\n\n  if (recentAnimations[State.ACTION_KNEE_BEND]) {\n    // If a jump was started recently, we will consider this a wavedash\n    counts.wavedashCount += 1;\n  } else {\n    // If there was no jump recently, this is a waveland\n    counts.wavelandCount += 1;\n  }\n}\n\nfunction isWavedashInitiationAnimation(animation: State): boolean {\n  if (animation === State.AIR_DODGE) {\n    return true;\n  }\n\n  const isAboveMin = animation >= State.CONTROLLED_JUMP_START;\n  const isBelowMax = animation <= State.CONTROLLED_JUMP_END;\n  return isAboveMin && isBelowMax;\n}\n","import { EventEmitter } from \"events\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ComboType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isDead,\n  isDown,\n  isGrabbed,\n  isTeching,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nexport enum ComboEvent {\n  COMBO_START = \"COMBO_START\",\n  COMBO_EXTEND = \"COMBO_EXTEND\",\n  COMBO_END = \"COMBO_END\",\n}\n\ninterface ComboState {\n  combo: ComboType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n  event: ComboEvent | null;\n}\n\nexport class ComboComputer extends EventEmitter implements StatComputer<ComboType> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, ComboState>();\n  private last_combo: ComboType = {\n    playerIndex: 0,\n    moves: [],\n    didKill: false,\n    lastHitBy: null,\n    startFrame: 0,\n    endFrame: null,\n    startPercent: 0,\n    currentPercent: 0,\n    endPercent: null,\n  };\n  private settings: GameStartType | null = null;\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: ComboState = {\n        combo: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n        event: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleComboCompute(allFrames, state, indices, frame);\n        // Emit an event for the new combo\n        if (state.event === \"COMBO_START\" && state.combo) {\n          this.last_combo = state.combo;\n        }\n        if (state.event !== null) {\n          this.emit(state.event, {\n            last_combo: this.last_combo,\n            settings: this.settings,\n          });\n          state.event = null;\n        }\n      }\n    });\n  }\n\n  public fetch(): ComboType {\n    return this.last_combo;\n  }\n}\n\nfunction handleComboCompute(\n  frames: FramesType,\n  state: ComboState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n): void {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a combo or count the moves for the existing combo\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    let comboStarted = false;\n    if (!state.combo) {\n      state.combo = {\n        playerIndex: indices.opponentIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        lastHitBy: indices.playerIndex,\n      };\n\n      // Track whether this is a new combo or not\n      comboStarted = true;\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.combo.moves.push(state.move);\n\n        // Make sure we don't overwrite the START event\n        if (!comboStarted) {\n          state.event = ComboEvent.COMBO_EXTEND;\n        }\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n\n    if (comboStarted) {\n      state.event = ComboEvent.COMBO_START;\n    }\n  }\n\n  if (!state.combo) {\n    // The rest of the function handles combo termination logic, so if we don't\n    // have a combo started, there is no need to continue\n    return;\n  }\n\n  const opntIsTeching = isTeching(oppActionStateId);\n  const opntIsDowned = isDown(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n  const opntIsDying = isDead(oppActionStateId);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.combo.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed || opntIsTeching || opntIsDowned || opntIsDying) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  } else {\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.combo.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - combo resets on time\n  if (state.resetCounter > Timers.COMBO_STRING_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If combo should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.combo.endFrame = playerFrame.frame;\n    state.combo.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n    state.event = ComboEvent.COMBO_END;\n\n    state.combo = null;\n    state.move = null;\n  }\n}\n","export enum Command {\n  MESSAGE_SIZES = 0x35,\n  GAME_START = 0x36,\n  PRE_FRAME_UPDATE = 0x37,\n  POST_FRAME_UPDATE = 0x38,\n  GAME_END = 0x39,\n  ITEM_UPDATE = 0x3b,\n  FRAME_BOOKEND = 0x3c,\n}\n\nexport interface PlayerType {\n  playerIndex: number;\n  port: number;\n  characterId: number | null;\n  characterColor: number | null;\n  startStocks: number | null;\n  type: number | null;\n  teamId: number | null;\n  controllerFix: string | null;\n  nametag: string | null;\n  displayName: string;\n  connectCode: string;\n}\n\nexport enum GameMode {\n  VS = 0x02,\n  ONLINE = 0x08,\n}\n\nexport interface GameStartType {\n  slpVersion: string | null;\n  isTeams: boolean | null;\n  isPAL: boolean | null;\n  stageId: number | null;\n  players: PlayerType[];\n  scene: number | null;\n  gameMode: GameMode | null;\n}\n\nexport interface PreFrameUpdateType {\n  frame: number | null;\n  playerIndex: number | null;\n  isFollower: boolean | null;\n  seed: number | null;\n  actionStateId: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  facingDirection: number | null;\n  joystickX: number | null;\n  joystickY: number | null;\n  cStickX: number | null;\n  cStickY: number | null;\n  trigger: number | null;\n  buttons: number | null;\n  physicalButtons: number | null;\n  physicalLTrigger: number | null;\n  physicalRTrigger: number | null;\n  percent: number | null;\n}\n\nexport interface PostFrameUpdateType {\n  frame: number | null;\n  playerIndex: number | null;\n  isFollower: boolean | null;\n  internalCharacterId: number | null;\n  actionStateId: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  facingDirection: number | null;\n  percent: number | null;\n  shieldSize: number | null;\n  lastAttackLanded: number | null;\n  currentComboCount: number | null;\n  lastHitBy: number | null;\n  stocksRemaining: number | null;\n  actionStateCounter: number | null;\n  miscActionState: number | null;\n  isAirborne: boolean | null;\n  lastGroundId: number | null;\n  jumpsRemaining: number | null;\n  lCancelStatus: number | null;\n  hurtboxCollisionState: number | null;\n  selfInducedSpeeds: SelfInducedSpeedsType | null;\n}\n\nexport interface SelfInducedSpeedsType {\n  airX: number | null;\n  y: number | null;\n  attackX: number | null;\n  attackY: number | null;\n  groundX: number | null;\n}\n\nexport interface ItemUpdateType {\n  frame: number | null;\n  typeId: number | null;\n  state: number | null;\n  facingDirection: number | null;\n  velocityX: number | null;\n  velocityY: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  damageTaken: number | null;\n  expirationTimer: number | null;\n  spawnId: number | null;\n  missileType: number | null;\n  turnipFace: number | null;\n  chargeShotLaunched: number | null;\n  chargePower: number | null;\n  owner: number | null;\n}\n\nexport interface FrameBookendType {\n  frame: number | null;\n  latestFinalizedFrame: number | null;\n}\n\nexport interface GameEndType {\n  gameEndMethod: number | null;\n  lrasInitiatorIndex: number | null;\n}\n\nexport interface MetadataType {\n  startAt?: string | null;\n  playedOn?: string | null;\n  lastFrame?: number | null;\n  players?: {\n    [playerIndex: number]: {\n      characters: {\n        [internalCharacterId: number]: number;\n      };\n      names?: {\n        netplay?: string | null;\n        code?: string | null;\n      };\n    };\n  } | null;\n  consoleNick?: string | null;\n}\n\nexport type EventPayloadTypes =\n  | GameStartType\n  | PreFrameUpdateType\n  | PostFrameUpdateType\n  | ItemUpdateType\n  | FrameBookendType\n  | GameEndType;\n\nexport type EventCallbackFunc = (command: Command, payload?: EventPayloadTypes | null) => boolean;\n\nexport interface FrameEntryType {\n  frame: number;\n  players: {\n    [playerIndex: number]: {\n      pre: PreFrameUpdateType;\n      post: PostFrameUpdateType;\n    } | null;\n  };\n  followers: {\n    [playerIndex: number]: {\n      pre: PreFrameUpdateType;\n      post: PostFrameUpdateType;\n    } | null;\n  };\n  items?: ItemUpdateType[];\n}\n\nexport enum Frames {\n  FIRST = -123,\n  FIRST_PLAYABLE = -39,\n}\n\nexport interface FramesType {\n  [frameIndex: number]: FrameEntryType;\n}\n\nexport interface RollbackFramesType {\n  [frameIndex: number]: FrameEntryType[];\n}\n\nexport interface RollbackFrames {\n  frames: RollbackFramesType;\n  count: number;\n  lengths: number[];\n}\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\nimport type { PlayerIndexedType } from \"./common\";\nimport { getSinglesPlayerPermutationsFromSettings } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nenum JoystickRegion {\n  DZ = 0,\n  NE = 1,\n  SE = 2,\n  SW = 3,\n  NW = 4,\n  N = 5,\n  E = 6,\n  S = 7,\n  W = 8,\n}\n\nexport interface PlayerInput {\n  playerIndex: number;\n  opponentIndex: number;\n  inputCount: number;\n  joystickInputCount: number;\n  cstickInputCount: number;\n  buttonInputCount: number;\n  triggerInputCount: number;\n  pressing_start?: boolean;\n  airborne?: boolean;\n}\n\nexport class InputComputer implements StatComputer<PlayerInput[]> {\n  private state = new Map<PlayerIndexedType, PlayerInput>();\n  private playerPermutations = new Array<PlayerIndexedType>();\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerInput = {\n        playerIndex: indices.playerIndex,\n        opponentIndex: indices.opponentIndex,\n        inputCount: 0,\n        joystickInputCount: 0,\n        cstickInputCount: 0,\n        buttonInputCount: 0,\n        triggerInputCount: 0,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleInputCompute(allFrames, state, indices, frame);\n      }\n    });\n  }\n\n  public fetch(): PlayerInput[] {\n    return Array.from(this.state.values());\n  }\n}\n\nfunction handleInputCompute(\n  frames: FramesType,\n  state: PlayerInput,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n): void {\n  const playerFrame = frame.players[indices.playerIndex]!.pre;\n  const currentFrameNumber = playerFrame.frame!;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber]!.players[indices.playerIndex]!.pre : null;\n\n  if (currentFrameNumber < Frames.FIRST_PLAYABLE || !prevPlayerFrame) {\n    // Don't count inputs until the game actually starts\n    return;\n  }\n\n  // First count the number of buttons that go from 0 to 1\n  // Increment action count by amount of button presses\n  const invertedPreviousButtons = ~prevPlayerFrame.physicalButtons!;\n  const currentButtons = playerFrame.physicalButtons!;\n  const pressing_start = currentButtons & 0x1000;\n  state.pressing_start = pressing_start ? true : false;\n  const postplayerFrame = frame.players[indices.playerIndex]!.post;\n  state.airborne = postplayerFrame.isAirborne ? true : false;\n  const buttonChanges = invertedPreviousButtons & currentButtons & 0xfff;\n  const newInputsPressed = countSetBits(buttonChanges);\n  state.inputCount += newInputsPressed;\n  state.buttonInputCount += newInputsPressed;\n\n  // Increment action count when sticks change from one region to another.\n  // Don't increment when stick returns to deadzone\n  const prevAnalogRegion = getJoystickRegion(prevPlayerFrame.joystickX!, prevPlayerFrame.joystickY!);\n  const currentAnalogRegion = getJoystickRegion(playerFrame.joystickX!, playerFrame.joystickY!);\n  if (prevAnalogRegion !== currentAnalogRegion && currentAnalogRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.joystickInputCount += 1;\n  }\n\n  // Do the same for c-stick\n  const prevCstickRegion = getJoystickRegion(prevPlayerFrame.cStickX!, prevPlayerFrame.cStickY!);\n  const currentCstickRegion = getJoystickRegion(playerFrame.cStickX!, playerFrame.cStickY!);\n  if (prevCstickRegion !== currentCstickRegion && currentCstickRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.cstickInputCount += 1;\n  }\n\n  // Increment action on analog trigger... I'm not sure when. This needs revision\n  // Currently will update input count when the button gets pressed past 0.3\n  // Changes from hard shield to light shield should probably count as inputs but\n  // are not counted here\n  if (prevPlayerFrame.physicalLTrigger! < 0.3 && playerFrame.physicalLTrigger! >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n  if (prevPlayerFrame.physicalRTrigger! < 0.3 && playerFrame.physicalRTrigger! >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n}\n\nfunction countSetBits(x: number): number {\n  // This function solves the Hamming Weight problem. Effectively it counts the number of\n  // bits in the input that are set to 1\n  // This implementation is supposedly very efficient when most bits are zero.\n  // Found: https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation\n  let bits = x;\n\n  let count;\n  for (count = 0; bits; count += 1) {\n    bits &= bits - 1;\n  }\n  return count;\n}\n\nfunction getJoystickRegion(x: number, y: number): JoystickRegion {\n  let region = JoystickRegion.DZ;\n\n  if (x >= 0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NE;\n  } else if (x >= 0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SE;\n  } else if (x <= -0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SW;\n  } else if (x <= -0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NW;\n  } else if (y >= 0.2875) {\n    region = JoystickRegion.N;\n  } else if (x >= 0.2875) {\n    region = JoystickRegion.E;\n  } else if (y <= -0.2875) {\n    region = JoystickRegion.S;\n  } else if (x <= -0.2875) {\n    region = JoystickRegion.W;\n  }\n\n  return region;\n}\n","import { EventEmitter } from \"events\";\nimport { filter, get, groupBy, last, orderBy } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ConversionType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isGrabbed,\n  isInControl,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ninterface PlayerConversionState {\n  conversion: ConversionType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n}\n\ninterface MetadataType {\n  lastEndFrameByOppIdx: {\n    [oppIdx: number]: number;\n  };\n}\n\nexport class ConversionComputer extends EventEmitter implements StatComputer<ConversionType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private conversions = new Array<ConversionType>();\n  private state = new Map<PlayerIndexedType, PlayerConversionState>();\n  private metadata: MetadataType;\n  private settings: GameStartType | null = null;\n\n  public constructor() {\n    super();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n  }\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.conversions = [];\n    this.state = new Map();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n    this.settings = settings;\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerConversionState = {\n        conversion: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        const terminated = handleConversionCompute(allFrames, state, indices, frame, this.conversions);\n        if (terminated) {\n          this.emit(\"CONVERSION\", {\n            combo: last(this.conversions),\n            settings: this.settings,\n          });\n        }\n      }\n    });\n  }\n\n  public fetch(): ConversionType[] {\n    this._populateConversionTypes();\n    return this.conversions;\n  }\n\n  private _populateConversionTypes(): void {\n    // Post-processing step: set the openingTypes\n    const conversionsToHandle = filter(this.conversions, (conversion) => {\n      return conversion.openingType === \"unknown\";\n    });\n\n    // Group new conversions by startTime and sort\n    const groupedConversions = groupBy(conversionsToHandle, \"startFrame\");\n    const sortedConversions = orderBy(groupedConversions, (conversions) => get(conversions, [0, \"startFrame\"]));\n\n    // Set the opening types on the conversions we need to handle\n    sortedConversions.forEach((conversions) => {\n      const isTrade = conversions.length >= 2;\n      conversions.forEach((conversion) => {\n        // Set end frame for this conversion\n        this.metadata.lastEndFrameByOppIdx[conversion.playerIndex] = conversion.endFrame!;\n\n        if (isTrade) {\n          // If trade, just short-circuit\n          conversion.openingType = \"trade\";\n          return;\n        }\n\n        // If not trade, check the opponent endFrame\n        const lastMove = last(conversion.moves);\n        const oppEndFrame =\n          this.metadata.lastEndFrameByOppIdx[lastMove ? lastMove.playerIndex : conversion.playerIndex];\n        const isCounterAttack = oppEndFrame && oppEndFrame > conversion.startFrame;\n        conversion.openingType = isCounterAttack ? \"counter-attack\" : \"neutral-win\";\n      });\n    });\n  }\n}\n\nfunction handleConversionCompute(\n  frames: FramesType,\n  state: PlayerConversionState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  conversions: ConversionType[],\n): boolean {\n  const currentFrameNumber = frame.frame;\n  const playerFrame: PostFrameUpdateType = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a conversion or\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    if (!state.conversion) {\n      state.conversion = {\n        playerIndex: indices.opponentIndex,\n        lastHitBy: indices.playerIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        openingType: \"unknown\", // Will be updated later\n      };\n\n      conversions.push(state.conversion);\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.conversion.moves.push(state.move);\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n  }\n\n  if (!state.conversion) {\n    // The rest of the function handles conversion termination logic, so if we don't\n    // have a conversion started, there is no need to continue\n    return false;\n  }\n\n  const opntInControl = isInControl(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.conversion.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  }\n\n  const shouldStartResetCounter = state.resetCounter === 0 && opntInControl;\n  const shouldContinueResetCounter = state.resetCounter > 0;\n  if (shouldStartResetCounter || shouldContinueResetCounter) {\n    // This will increment the reset timer under the following conditions:\n    // 1) if we were punishing opponent but they have now entered an actionable state\n    // 2) if counter has already started counting meaning opponent has entered actionable state\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.conversion.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - conversion resets on time\n  if (state.resetCounter > Timers.PUNISH_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If conversion should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.conversion.endFrame = playerFrame.frame;\n    state.conversion.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n\n    state.conversion = null;\n    state.move = null;\n  }\n\n  return shouldTerminate;\n}\n","import { flatten, get, groupBy, keyBy, mapValues } from \"lodash\";\n\nimport type { GameStartType } from \"../types\";\nimport type { ConversionType, InputCountsType, OverallType, RatioType } from \"./common\";\nimport type { PlayerInput } from \"./inputs\";\n\ninterface ConversionsByPlayerByOpening {\n  [playerIndex: string]: {\n    [openingType: string]: ConversionType[];\n  };\n}\n\nexport function generateOverallStats({\n  settings,\n  inputs,\n  conversions,\n  playableFrameCount,\n}: {\n  settings: GameStartType;\n  inputs: PlayerInput[];\n  conversions: ConversionType[];\n  playableFrameCount: number;\n}): OverallType[] {\n  const inputsByPlayer = keyBy(inputs, \"playerIndex\");\n  const originalConversions = conversions;\n  const conversionsByPlayer = groupBy(conversions, (conv) => conv.moves[0]?.playerIndex);\n  const conversionsByPlayerByOpening: ConversionsByPlayerByOpening = mapValues(conversionsByPlayer, (conversions) =>\n    groupBy(conversions, \"openingType\"),\n  );\n\n  const gameMinutes = playableFrameCount / 3600;\n\n  const overall = settings.players.map((player) => {\n    const playerIndex = player.playerIndex;\n\n    const playerInputs = get(inputsByPlayer, playerIndex) || {};\n    const inputCounts: InputCountsType = {\n      buttons: get(playerInputs, \"buttonInputCount\"),\n      triggers: get(playerInputs, \"triggerInputCount\"),\n      cstick: get(playerInputs, \"cstickInputCount\"),\n      joystick: get(playerInputs, \"joystickInputCount\"),\n      total: get(playerInputs, \"inputCount\"),\n    };\n    // const conversions = get(conversionsByPlayer, playerIndex) || [];\n    // const successfulConversions = conversions.filter((conversion) => conversion.moves.length > 1);\n    let conversionCount = 0;\n\n    const opponentIndices = settings.players\n      .filter((opp) => {\n        // We want players which aren't ourselves\n        if (opp.playerIndex === playerIndex) {\n          return false;\n        }\n\n        // Make sure they're not on our team either\n        return !settings.isTeams || opp.teamId !== player.teamId;\n      })\n      .map((opp) => opp.playerIndex);\n\n    let totalDamage = 0;\n    let killCount = 0;\n\n    // These are the conversions that we did on our opponents\n    originalConversions\n      // Filter down to conversions of our opponent\n      .filter((conversion) => conversion.playerIndex !== playerIndex)\n      .forEach((conversion) => {\n        conversionCount++;\n\n        // We killed the opponent\n        if (conversion.didKill && conversion.lastHitBy === playerIndex) {\n          killCount += 1;\n        }\n        conversion.moves.forEach((move) => {\n          if (move.playerIndex === playerIndex) {\n            totalDamage += move.damage;\n          }\n        });\n      });\n\n    return {\n      playerIndex: playerIndex,\n      totalDamage: totalDamage,\n      killCount: killCount,\n      inputsPerMinute: getRatio(inputCounts.total, gameMinutes),\n      openingsPerKill: getRatio(conversionCount, killCount),\n      damagePerOpening: getRatio(totalDamage, conversionCount),\n      neutralWinRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"neutral-win\"),\n    };\n  });\n\n  return overall;\n}\n\nfunction getRatio(count: number, total: number): RatioType {\n  return {\n    count: count,\n    total: total,\n    ratio: total ? count / total : null,\n  };\n}\n\nfunction getOpeningRatio(\n  conversionsByPlayerByOpening: ConversionsByPlayerByOpening,\n  playerIndex: number,\n  opponentIndices: number[],\n  type: string,\n): RatioType {\n  const openings = get(conversionsByPlayerByOpening, [playerIndex, type]) || [];\n\n  const opponentOpenings = flatten(\n    opponentIndices.map((opponentIndex) => get(conversionsByPlayerByOpening, [opponentIndex, type]) || []),\n  );\n\n  return getRatio(openings.length, openings.length + opponentOpenings.length);\n}\n","import { get } from \"lodash\";\n\nimport type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\n\nexport interface StatComputer<T> {\n  setup(settings: GameStartType): void;\n  processFrame(newFrame: FrameEntryType, allFrames: FramesType): void;\n  fetch(): T;\n}\n\nexport interface StatOptions {\n  processOnTheFly: boolean;\n}\n\nconst defaultOptions: StatOptions = {\n  processOnTheFly: false,\n};\n\nexport class Stats {\n  private options: StatOptions;\n  private lastProcessedFrame: number | null = null;\n  private frames: FramesType = {};\n  private players: number[] = [];\n  private allComputers = new Array<StatComputer<unknown>>();\n\n  public constructor(options?: StatOptions) {\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n\n  /**\n   * Should reset the frames to their default values.\n   */\n  public setup(settings: GameStartType): void {\n    // Reset the frames since it's a new game\n    this.frames = {};\n    this.players = settings.players.map((v) => v.playerIndex);\n\n    // Forward the settings on to the individual stat computer\n    this.allComputers.forEach((comp) => comp.setup(settings));\n  }\n\n  public register(...computer: StatComputer<unknown>[]): void {\n    this.allComputers.push(...computer);\n  }\n\n  public process(): void {\n    if (this.players.length === 0) {\n      return;\n    }\n\n    let i = this.lastProcessedFrame !== null ? this.lastProcessedFrame + 1 : Frames.FIRST;\n    while (this.frames[i]) {\n      const frame = this.frames[i];\n      // Don't attempt to compute stats on frames that have not been fully received\n      if (!isCompletedFrame(this.players, frame)) {\n        return;\n      }\n      this.allComputers.forEach((comp) => comp.processFrame(frame, this.frames));\n      this.lastProcessedFrame = i;\n      i++;\n    }\n  }\n\n  public addFrame(frame: FrameEntryType): void {\n    this.frames[frame.frame] = frame;\n\n    if (this.options.processOnTheFly) {\n      this.process();\n    }\n  }\n}\n\nfunction isCompletedFrame(players: number[], frame?: FrameEntryType): frame is FrameEntryType {\n  if (!frame) {\n    return false;\n  }\n\n  // This function checks whether we have successfully received an entire frame.\n  // It is not perfect because it does not wait for follower frames. Fortunately,\n  // follower frames are not used for any stat calculations so this doesn't matter\n  // for our purposes.\n  for (const player of players) {\n    const playerPostFrame = get(frame, [\"players\", player, \"post\"]);\n    if (!playerPostFrame) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","export interface SlpReadInput {\n  source: SlpInputSource;\n  filePath?: string;\n  buffer?: Uint8Array;\n}\nexport enum SlpInputSource {\n  BUFFER = \"buffer\",\n  FILE = \"file\",\n}\n\nexport interface SlpFileType {\n  ref: SlpRefType;\n  full_data: Uint8Array;\n  rawDataPosition: number;\n  rawDataLength: number;\n  metadataPosition: number;\n  metadataLength: number;\n  messageSizes: {\n    [command: number]: number;\n  };\n}\n\nexport interface SlpFileSourceRef {\n  source: SlpInputSource;\n  fileDescriptor: number;\n}\n\nexport interface SlpBufferSourceRef {\n  source: SlpInputSource;\n  buffer: Uint8Array;\n}\n\nexport interface SlpBufferSourceRef {\n  source: SlpInputSource;\n  buffer: Uint8Array;\n}\n\nexport type SlpRefType = SlpFileSourceRef | SlpBufferSourceRef;\n\nexport const getRef = (input: SlpReadInput): SlpRefType => {\n  switch (input.source) {\n    case SlpInputSource.BUFFER:\n      return {\n        source: input.source,\n        buffer: input.buffer,\n      } as SlpBufferSourceRef;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n};\n\nexport const readRef = (ref: SlpRefType, length: number, position: number): Uint8Array => {\n  switch (ref.source) {\n    case SlpInputSource.BUFFER:\n      return (ref as SlpBufferSourceRef).buffer.slice(position, position + length);\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n};\n\nexport const getLenRef = (ref: SlpRefType): number => {\n  switch (ref.source) {\n    case SlpInputSource.BUFFER:\n      return (ref as SlpBufferSourceRef).buffer.length;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n};\n\nexport const readFullData = (input: SlpReadInput): Uint8Array => {\n  const ref = getRef(input);\n  switch (ref.source) {\n    case SlpInputSource.BUFFER:\n      return input.buffer || new Uint8Array();\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n};\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport type { PlayerIndexedType, StockType } from \"./common\";\nimport { didLoseStock, getSinglesPlayerPermutationsFromSettings, isDead } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ninterface StockState {\n  stock?: StockType | null;\n}\n\nexport class StockComputer implements StatComputer<StockType[]> {\n  private state = new Map<PlayerIndexedType, StockState>();\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private stocks = new Array<StockType>();\n\n  public setup(settings: GameStartType): void {\n    // Reset state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.stocks = [];\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: StockState = {\n        stock: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleStockCompute(allFrames, state, indices, frame, this.stocks);\n      }\n    });\n  }\n\n  public fetch(): StockType[] {\n    return this.stocks;\n  }\n}\n\nfunction handleStockCompute(\n  frames: FramesType,\n  state: StockState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  stocks: StockType[],\n): void {\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const currentFrameNumber = playerFrame.frame!;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber]!.players[indices.playerIndex]!.post : null;\n\n  // If there is currently no active stock, wait until the player is no longer spawning.\n  // Once the player is no longer spawning, start the stock\n  if (!state.stock) {\n    const isPlayerDead = isDead(playerFrame.actionStateId!);\n    if (isPlayerDead) {\n      return;\n    }\n\n    state.stock = {\n      playerIndex: indices.playerIndex,\n      startFrame: currentFrameNumber,\n      endFrame: null,\n      startPercent: 0,\n      endPercent: null,\n      currentPercent: 0,\n      count: playerFrame.stocksRemaining!,\n      deathAnimation: null,\n    };\n\n    stocks.push(state.stock);\n  } else if (prevPlayerFrame && didLoseStock(playerFrame, prevPlayerFrame)) {\n    state.stock.endFrame = playerFrame.frame;\n    state.stock.endPercent = prevPlayerFrame.percent ?? 0;\n    state.stock.deathAnimation = playerFrame.actionStateId;\n    state.stock = null;\n  } else {\n    state.stock.currentPercent = playerFrame.percent ?? 0;\n  }\n}\n","import _ from \"lodash\";\n\nexport function toHalfwidth(str: string): string {\n  // Converts a fullwidth character to halfwidth\n  const convertChar = (charCode: number): number => {\n    /**\n     * Standard full width encodings\n     * https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)\n     */\n    if (charCode > 0xff00 && charCode < 0xff5f) {\n      return 0x0020 + (charCode - 0xff00);\n    }\n\n    // space:\n    if (charCode === 0x3000) {\n      return 0x0020;\n    }\n\n    /**\n     * Exceptions found in Melee/Japanese keyboards\n     */\n    // single quote: '\n    if (charCode === 0x2019) {\n      return 0x0027;\n    }\n\n    // double quote: \"\n    if (charCode === 0x201d) {\n      return 0x0022;\n    }\n\n    return charCode;\n  };\n\n  const ret = _.map(str, (char) => convertChar(char.charCodeAt(0)));\n\n  return String.fromCharCode(...ret);\n}\n","import { convert } from \"encoding-japanese\";\n\nimport type { EventCallbackFunc, EventPayloadTypes, PlayerType, SelfInducedSpeedsType } from \"../types\";\nimport { Command } from \"../types\";\nimport { toHalfwidth } from \"./fullwidth\";\nimport { readFullData } from \"./browserReading\";\n\nexport enum SlpInputSource {\n  BUFFER = \"buffer\",\n  FILE = \"file\",\n}\n\nexport interface SlpReadInput {\n  source: SlpInputSource;\n  filePath?: string;\n  buffer?: Uint8Array;\n}\n\nexport type SlpRefType = SlpFileSourceRef | SlpBufferSourceRef;\n\nexport interface SlpFileType {\n  full_data: Uint8Array;\n  rawDataPosition: number;\n  rawDataLength: number;\n  messageSizes: {\n    [command: number]: number;\n  };\n}\n\nexport interface SlpFileSourceRef {\n  source: SlpInputSource;\n  fileDescriptor: number;\n}\n\nexport interface SlpBufferSourceRef {\n  source: SlpInputSource;\n  buffer: Uint8Array;\n}\n\n/**\n * Opens a file at path\n */\nexport function openSlpFile(input: SlpReadInput): SlpFileType {\n  const full_data = readFullData(input);\n\n  const raw_data_position = getRawDataPosition(full_data);\n  const raw_data_length = getRawDataLength(full_data, raw_data_position);\n  const message_sizes = getMessageSizes(full_data, raw_data_position);\n  return {\n    full_data: full_data,\n    rawDataPosition: raw_data_position,\n    rawDataLength: raw_data_length,\n    messageSizes: message_sizes,\n  };\n}\n\n// This function gets the position where the raw data starts\nfunction getRawDataPosition(buffer: Uint8Array): number {\n  if (buffer[0] !== \"{\".charCodeAt(0)) {\n    return 0; // return error?\n  }\n  return 15;\n}\n\nfunction getRawDataLength(buffer: Uint8Array, position: number): number {\n  const file_size = buffer.length;\n  if (position === 0) {\n    return file_size;\n  }\n  const length_info = buffer.slice(position - 4, position);\n  const raw_data_len = (length_info[0]! << 24) | (length_info[1]! << 16) | (length_info[2]! << 8) | length_info[3]!;\n  if (raw_data_len > 0) {\n    // If this method manages to read a number, it's probably trustworthy\n    return raw_data_len;\n  }\n  // If the above does not return a valid data length,\n  // return a file size based on file length. This enables\n  // some support for severed files\n  return file_size - position;\n}\n\nfunction getMessageSizes(\n  buffer: Uint8Array,\n  position: number,\n): {\n  [command: number]: number;\n} {\n  const messageSizes: {\n    [command: number]: number;\n  } = {};\n  // Support old file format\n  if (position === 0) {\n    messageSizes[0x36] = 0x140;\n    messageSizes[0x37] = 0x6;\n    messageSizes[0x38] = 0x46;\n    messageSizes[0x39] = 0x1;\n    return messageSizes;\n  }\n\n  const message_metadata = buffer.slice(position, position + 2);\n  if (message_metadata[0] !== Command.MESSAGE_SIZES) {\n    return {};\n  }\n  const payloadLength = message_metadata[1] as number;\n  (messageSizes[0x35] as any) = payloadLength;\n\n  const message_sizes_buffer = buffer.slice(position + 2, position + payloadLength + 1);\n  for (let i = 0; i < payloadLength - 1; i += 3) {\n    const command = message_sizes_buffer[i] as number;\n\n    // Get size of command\n    (messageSizes[command] as any) = (message_sizes_buffer[i + 1]! << 8) | message_sizes_buffer[i + 2]!;\n  }\n\n  return messageSizes;\n}\n\n/**\n * Iterates through slp events and parses payloads\n */\nexport function iterateEvents(\n  slpFile: SlpFileType,\n  getShouldStop: EventCallbackFunc,\n  startPos: number | null = null,\n): number {\n  const full_data = slpFile.full_data;\n\n  let readPosition = startPos !== null && startPos > 0 ? startPos : slpFile.rawDataPosition;\n  const stopReadingAt = slpFile.rawDataPosition + slpFile.rawDataLength;\n\n  while (readPosition < stopReadingAt) {\n    const commandByte = full_data[readPosition] as number;\n    const message_size = (slpFile.messageSizes[commandByte] as number) + 1;\n    if (message_size === undefined) {\n      // If we don't have an entry for this command, return false to indicate failed read\n      return readPosition;\n    }\n    if (message_size > stopReadingAt - readPosition) {\n      return readPosition;\n    }\n\n    const data = full_data.slice(readPosition, readPosition + message_size);\n    const parsed_payload = parseMessage(commandByte, data);\n    const shouldStop = getShouldStop(commandByte, parsed_payload);\n    if (shouldStop) {\n      break;\n    }\n\n    readPosition += message_size;\n  }\n\n  return readPosition;\n}\n\nconst decodeBuf = (buf: Uint8Array): string | undefined =>\n  convert(buf, {\n    to: \"UNICODE\",\n    from: \"SJIS\",\n    type: \"string\",\n  })\n    .split(\"\\0\")\n    .shift();\n\nexport function parseMessage(command: Command, payload: Uint8Array): EventPayloadTypes | null {\n  const sliced_buffer = payload.buffer.slice(payload.byteOffset, payload.byteOffset + payload.byteLength);\n  const view = new DataView(sliced_buffer);\n  switch (command) {\n    case Command.GAME_START:\n      const getPlayerObject = (playerIndex: number): PlayerType => {\n        // Controller Fix stuff\n        const cfOffset = playerIndex * 0x8;\n        const dashback = readUint32(view, 0x141 + cfOffset);\n        const shieldDrop = readUint32(view, 0x145 + cfOffset);\n        let cfOption = \"None\";\n        if (dashback !== shieldDrop) {\n          cfOption = \"Mixed\";\n        } else if (dashback === 1) {\n          cfOption = \"UCF\";\n        } else if (dashback === 2) {\n          cfOption = \"Dween\";\n        }\n\n        // Nametag stuff\n        const nametagLength = 0x10;\n        const nametagOffset = playerIndex * nametagLength;\n        const nametagStart = 0x161 + nametagOffset;\n        const nametagBuf = payload.slice(nametagStart, nametagStart + nametagLength);\n        const nameTagString = decodeBuf(nametagBuf);\n        const nametag = nameTagString ? toHalfwidth(nameTagString) : \"\";\n\n        // Display name\n        const displayNameLength = 0x1f;\n        const displayNameOffset = playerIndex * displayNameLength;\n        const displayNameStart = 0x1a5 + displayNameOffset;\n        const displayNameBuf = payload.slice(displayNameStart, displayNameStart + displayNameLength);\n        const displayNameString = decodeBuf(displayNameBuf);\n        const displayName = displayNameString ? toHalfwidth(displayNameString) : \"\";\n\n        // Connect code\n        const connectCodeLength = 0xa;\n        const connectCodeOffset = playerIndex * connectCodeLength;\n        const connectCodeStart = 0x221 + connectCodeOffset;\n        const connectCodeBuf = payload.slice(connectCodeStart, connectCodeStart + connectCodeLength);\n        const connectCodeString = decodeBuf(connectCodeBuf);\n        const connectCode = connectCodeString ? toHalfwidth(connectCodeString) : \"\";\n\n        const offset = playerIndex * 0x24;\n        const result = {\n          playerIndex: playerIndex,\n          port: playerIndex + 1,\n          characterId: readUint8(view, 0x65 + offset),\n          characterColor: readUint8(view, 0x68 + offset),\n          startStocks: readUint8(view, 0x67 + offset),\n          type: readUint8(view, 0x66 + offset),\n          teamId: readUint8(view, 0x6e + offset),\n          controllerFix: cfOption,\n          nametag: nametag,\n          displayName: displayName,\n          connectCode: connectCode,\n        };\n        return result;\n      };\n      return {\n        slpVersion: `${readUint8(view, 0x1)}.${readUint8(view, 0x2)}.${readUint8(view, 0x3)}`,\n        isTeams: readBool(view, 0xd),\n        isPAL: readBool(view, 0x1a1),\n        stageId: readUint16(view, 0x13),\n        players: [0, 1, 2, 3].map(getPlayerObject),\n        scene: readUint8(view, 0x1a3),\n        gameMode: readUint8(view, 0x1a4),\n      };\n    case Command.PRE_FRAME_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        seed: readUint32(view, 0x7),\n        actionStateId: readUint16(view, 0xb),\n        positionX: readFloat(view, 0xd),\n        positionY: readFloat(view, 0x11),\n        facingDirection: readFloat(view, 0x15),\n        joystickX: readFloat(view, 0x19),\n        joystickY: readFloat(view, 0x1d),\n        cStickX: readFloat(view, 0x21),\n        cStickY: readFloat(view, 0x25),\n        trigger: readFloat(view, 0x29),\n        buttons: readUint32(view, 0x2d),\n        physicalButtons: readUint16(view, 0x31),\n        physicalLTrigger: readFloat(view, 0x33),\n        physicalRTrigger: readFloat(view, 0x37),\n        percent: readFloat(view, 0x3c),\n      };\n    case Command.POST_FRAME_UPDATE:\n      const selfInducedSpeeds: SelfInducedSpeedsType = {\n        airX: readFloat(view, 0x35),\n        y: readFloat(view, 0x39),\n        attackX: readFloat(view, 0x3d),\n        attackY: readFloat(view, 0x41),\n        groundX: readFloat(view, 0x45),\n      };\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        internalCharacterId: readUint8(view, 0x7),\n        actionStateId: readUint16(view, 0x8),\n        positionX: readFloat(view, 0xa),\n        positionY: readFloat(view, 0xe),\n        facingDirection: readFloat(view, 0x12),\n        percent: readFloat(view, 0x16),\n        shieldSize: readFloat(view, 0x1a),\n        lastAttackLanded: readUint8(view, 0x1e),\n        currentComboCount: readUint8(view, 0x1f),\n        lastHitBy: readUint8(view, 0x20),\n        stocksRemaining: readUint8(view, 0x21),\n        actionStateCounter: readFloat(view, 0x22),\n        miscActionState: readFloat(view, 0x2b),\n        isAirborne: readBool(view, 0x2f),\n        lastGroundId: readUint16(view, 0x30),\n        jumpsRemaining: readUint8(view, 0x32),\n        lCancelStatus: readUint8(view, 0x33),\n        hurtboxCollisionState: readUint8(view, 0x34),\n        selfInducedSpeeds: selfInducedSpeeds,\n      };\n    case Command.ITEM_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        typeId: readUint16(view, 0x5),\n        state: readUint8(view, 0x7),\n        facingDirection: readFloat(view, 0x8),\n        velocityX: readFloat(view, 0xc),\n        velocityY: readFloat(view, 0x10),\n        positionX: readFloat(view, 0x14),\n        positionY: readFloat(view, 0x18),\n        damageTaken: readUint16(view, 0x1c),\n        expirationTimer: readFloat(view, 0x1e),\n        spawnId: readUint32(view, 0x22),\n        missileType: readUint8(view, 0x26),\n        turnipFace: readUint8(view, 0x27),\n        chargeShotLaunched: readUint8(view, 0x28),\n        chargePower: readUint8(view, 0x29),\n        owner: readInt8(view, 0x2a),\n      };\n    case Command.FRAME_BOOKEND:\n      return {\n        frame: readInt32(view, 0x1),\n        latestFinalizedFrame: readInt32(view, 0x5),\n      };\n    case Command.GAME_END:\n      return {\n        gameEndMethod: readUint8(view, 0x1),\n        lrasInitiatorIndex: readInt8(view, 0x2),\n      };\n    default:\n      return null;\n  }\n}\n\nfunction canReadFromView(view: DataView, offset: number, length: number): boolean {\n  const viewLength = view.byteLength;\n  return offset + length <= viewLength;\n}\n\nfunction readFloat(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getFloat32(offset);\n}\n\nfunction readInt32(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getInt32(offset);\n}\n\nfunction readInt8(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getInt8(offset);\n}\n\nfunction readUint32(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getUint32(offset);\n}\n\nfunction readUint16(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 2)) {\n    return null;\n  }\n\n  return view.getUint16(offset);\n}\n\nfunction readUint8(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getUint8(offset);\n}\n\nfunction readBool(view: DataView, offset: number): boolean | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return !!view.getUint8(offset);\n}\n","import type { WritableOptions } from \"stream\";\nimport { Writable } from \"stream\";\nimport type { EventPayloadTypes } from \"../types\";\nimport { Command } from \"../types\";\nimport { parseMessage } from \"../reading/slpReader\";\n\nconst NETWORK_MESSAGE = \"HELO\\0\";\n\nexport enum SlpStreamMode {\n  AUTO = \"AUTO\", // Always reading data, but errors on invalid command\n  MANUAL = \"MANUAL\", // Stops parsing inputs after a valid game end command, requires manual restarting\n}\n\nconst defaultSettings = {\n  suppressErrors: false,\n  mode: SlpStreamMode.AUTO,\n};\n\nexport type SlpStreamSettings = typeof defaultSettings;\n\nexport type MessageSizes = Map<Command, number>;\n\nexport interface SlpCommandEventPayload {\n  command: Command;\n  payload: EventPayloadTypes | MessageSizes;\n}\n\nexport interface SlpRawEventPayload {\n  command: Command;\n  payload: Buffer;\n}\n\nexport enum SlpStreamEvent {\n  RAW = \"slp-raw\",\n  COMMAND = \"slp-command\",\n}\n\n/**\n * SlpStream is a writable stream of Slippi data. It passes the data being written in\n * and emits an event based on what kind of Slippi messages were processed.\n *\n * SlpStream emits two events: \"slp-raw\" and \"slp-command\". The \"slp-raw\" event emits the raw buffer\n * bytes whenever it processes each command. You can manually parse this or write it to a\n * file. The \"slp-command\" event returns the parsed payload which you can access the attributes.\n *\n * @class SlpStream\n * @extends {Writable}\n */\nexport class SlpStream extends Writable {\n  private gameEnded = false; // True only if in manual mode and the game has completed\n  private settings: SlpStreamSettings;\n  private payloadSizes: MessageSizes | null = null;\n  private previousBuffer: Uint8Array = Buffer.from([]);\n\n  /**\n   *Creates an instance of SlpStream.\n   * @param {Partial<SlpStreamSettings>} [slpOptions]\n   * @param {WritableOptions} [opts]\n   * @memberof SlpStream\n   */\n  public constructor(slpOptions?: Partial<SlpStreamSettings>, opts?: WritableOptions) {\n    super(opts);\n    this.settings = Object.assign({}, defaultSettings, slpOptions);\n  }\n\n  public restart(): void {\n    this.gameEnded = false;\n    this.payloadSizes = null;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public _write(newData: Buffer, encoding: string, callback: (error?: Error | null, data?: any) => void): void {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    }\n\n    // Join the current data with the old data\n    const data = Uint8Array.from(Buffer.concat([this.previousBuffer, newData]));\n\n    // Clear previous data\n    this.previousBuffer = Buffer.from([]);\n\n    const dataView = new DataView(data.buffer);\n\n    // Iterate through the data\n    let index = 0;\n    while (index < data.length) {\n      // We want to filter out the network messages\n      if (Buffer.from(data.slice(index, index + 5)).toString() === NETWORK_MESSAGE) {\n        index += 5;\n        continue;\n      }\n\n      // Make sure we have enough data to read a full payload\n      const command = dataView.getUint8(index);\n      let payloadSize = 0;\n      if (this.payloadSizes) {\n        payloadSize = this.payloadSizes.get(command) ?? 0;\n      }\n      const remainingLen = data.length - index;\n      if (remainingLen < payloadSize + 1) {\n        // If remaining length is not long enough for full payload, save the remaining\n        // data until we receive more data. The data has been split up.\n        this.previousBuffer = data.slice(index);\n        break;\n      }\n\n      // Only process if the game is still going\n      if (this.settings.mode === SlpStreamMode.MANUAL && this.gameEnded) {\n        break;\n      }\n\n      // Increment by one for the command byte\n      index += 1;\n\n      const payloadPtr = data.slice(index);\n      const payloadDataView = new DataView(data.buffer, index);\n      let payloadLen = 0;\n      try {\n        payloadLen = this._processCommand(command, payloadPtr, payloadDataView);\n      } catch (err) {\n        // Only throw the error if we're not suppressing the errors\n        if (!this.settings.suppressErrors) {\n          throw err;\n        }\n        payloadLen = 0;\n      }\n      index += payloadLen;\n    }\n\n    callback();\n  }\n\n  private _writeCommand(command: Command, entirePayload: Uint8Array, payloadSize: number): Uint8Array {\n    const payloadBuf = entirePayload.slice(0, payloadSize);\n    const bufToWrite = Buffer.concat([Buffer.from([command]), payloadBuf]);\n    // Forward the raw buffer onwards\n    this.emit(SlpStreamEvent.RAW, {\n      command: command,\n      payload: bufToWrite,\n    } as SlpRawEventPayload);\n    return new Uint8Array(bufToWrite);\n  }\n\n  private _processCommand(command: Command, entirePayload: Uint8Array, dataView: DataView): number {\n    // Handle the message size command\n    if (command === Command.MESSAGE_SIZES) {\n      const payloadSize = dataView.getUint8(0);\n      // Set the payload sizes\n      this.payloadSizes = processReceiveCommands(dataView);\n      // Emit the raw command event\n      this._writeCommand(command, entirePayload, payloadSize);\n      this.emit(SlpStreamEvent.COMMAND, {\n        command: command,\n        payload: this.payloadSizes,\n      } as SlpCommandEventPayload);\n      return payloadSize;\n    }\n\n    let payloadSize = 0;\n    if (this.payloadSizes) {\n      payloadSize = this.payloadSizes.get(command) ?? 0;\n    }\n\n    // Fetch the payload and parse it\n    let payload: Uint8Array;\n    let parsedPayload: EventPayloadTypes | null = null;\n    if (payloadSize > 0) {\n      payload = this._writeCommand(command, entirePayload, payloadSize);\n      parsedPayload = parseMessage(command, payload);\n    }\n    if (!parsedPayload) {\n      return payloadSize;\n    }\n\n    switch (command) {\n      case Command.GAME_END:\n        // Stop parsing data until we manually restart the stream\n        if (this.settings.mode === SlpStreamMode.MANUAL) {\n          this.gameEnded = true;\n        }\n        break;\n    }\n\n    this.emit(SlpStreamEvent.COMMAND, {\n      command: command,\n      payload: parsedPayload,\n    } as SlpCommandEventPayload);\n    return payloadSize;\n  }\n}\n\nconst processReceiveCommands = (dataView: DataView): MessageSizes => {\n  const payloadSizes = new Map<Command, number>();\n  const payloadLen = dataView.getUint8(0);\n  for (let i = 1; i < payloadLen; i += 3) {\n    const commandByte = dataView.getUint8(i);\n    const payloadSize = dataView.getUint16(i + 1);\n    payloadSizes.set(commandByte, payloadSize);\n  }\n  return payloadSizes;\n};\n","import { EventEmitter } from \"events\";\nimport _ from \"lodash\";\nimport semver from \"semver\";\n\nimport type {\n  FrameBookendType,\n  FrameEntryType,\n  FramesType,\n  GameEndType,\n  GameStartType,\n  ItemUpdateType,\n  PostFrameUpdateType,\n  PreFrameUpdateType,\n  RollbackFrames,\n} from \"../types\";\nimport { Command, Frames, GameMode } from \"../types\";\nimport { RollbackCounter } from \"./rollbackCounter\";\n\nexport const MAX_ROLLBACK_FRAMES = 7;\n\nexport enum SlpParserEvent {\n  SETTINGS = \"settings\",\n  END = \"end\",\n  FRAME = \"frame\", // Emitted for every frame\n  FINALIZED_FRAME = \"finalized-frame\", // Emitted for only finalized frames\n  ROLLBACK_FRAME = \"rollback-frame\", // Emitted if a frame is being replaced\n}\n\n// If strict mode is on, we will do strict validation checking\n// which could throw errors on invalid data.\n// Default to false though since probably only real time applications\n// would care about valid data.\nconst defaultSlpParserOptions = {\n  strict: false,\n};\n\nexport type SlpParserOptions = typeof defaultSlpParserOptions;\n\nexport class SlpParser extends EventEmitter {\n  private frames: FramesType = {};\n  private rollbackCounter: RollbackCounter = new RollbackCounter();\n  private settings: GameStartType | null = null;\n  private gameEnd: GameEndType | null = null;\n  private latestFrameIndex: number | null = null;\n  private settingsComplete = false;\n  private lastFinalizedFrame = Frames.FIRST - 1;\n  private options: SlpParserOptions;\n\n  public constructor(options?: Partial<SlpParserOptions>) {\n    super();\n    this.options = Object.assign({}, defaultSlpParserOptions, options);\n  }\n\n  public handleCommand(command: Command, payload: any): void {\n    switch (command) {\n      case Command.GAME_START:\n        this._handleGameStart(payload as GameStartType);\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // We need to handle the post frame update first since that\n        // will finalize the settings object, before we fire the frame update\n        this._handlePostFrameUpdate(payload as PostFrameUpdateType);\n        this._handleFrameUpdate(command, payload as PostFrameUpdateType);\n        break;\n      case Command.PRE_FRAME_UPDATE:\n        this._handleFrameUpdate(command, payload as PreFrameUpdateType);\n        break;\n      case Command.ITEM_UPDATE:\n        this._handleItemUpdate(payload as ItemUpdateType);\n        break;\n      case Command.FRAME_BOOKEND:\n        this._handleFrameBookend(payload as FrameBookendType);\n        break;\n      case Command.GAME_END:\n        this._handleGameEnd(payload as GameEndType);\n        break;\n    }\n  }\n\n  // Resets the parser state to their default values.\n  public reset(): void {\n    this.frames = {};\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = Frames.FIRST - 1;\n  }\n\n  public getLatestFrameNumber(): number {\n    return this.latestFrameIndex ?? Frames.FIRST - 1;\n  }\n\n  public getPlayableFrameCount(): number {\n    if (this.latestFrameIndex === null) {\n      return 0;\n    }\n    return Math.max(0, this.latestFrameIndex - Frames.FIRST_PLAYABLE);\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    // return this.playerFrames[this.latestFrameIndex];\n\n    // TODO: Modify this to check if we actually have all the latest frame data and return that\n    // TODO: If we do. For now I'm just going to take a shortcut\n    const allFrames = this.getFrames();\n    const frameIndex = this.latestFrameIndex !== null ? this.latestFrameIndex : Frames.FIRST;\n    const indexToUse = this.gameEnd ? frameIndex : frameIndex - 1;\n    return _.get(allFrames, indexToUse) || null;\n  }\n\n  public getSettings(): GameStartType | null {\n    return this.settingsComplete ? this.settings : null;\n  }\n\n  public getGameEnd(): GameEndType | null {\n    return this.gameEnd;\n  }\n\n  public getFrames(): FramesType {\n    return this.frames;\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    return {\n      frames: this.rollbackCounter.getFrames(),\n      count: this.rollbackCounter.getCount(),\n      lengths: this.rollbackCounter.getLengths(),\n    };\n  }\n\n  public getFrame(num: number): FrameEntryType | null {\n    return this.frames[num] || null;\n  }\n\n  private _handleGameEnd(payload: GameEndType): void {\n    // Finalize remaining frames if necessary\n    if (this.latestFrameIndex !== null && this.latestFrameIndex !== this.lastFinalizedFrame) {\n      this._finalizeFrames(this.latestFrameIndex);\n    }\n\n    payload = payload as GameEndType;\n    this.gameEnd = payload;\n    this.emit(SlpParserEvent.END, this.gameEnd);\n  }\n\n  private _handleGameStart(payload: GameStartType): void {\n    this.settings = payload;\n    const players = payload.players;\n    this.settings.players = players.filter((player) => player.type !== 3);\n\n    // Check to see if the file was created after the sheik fix so we know\n    // we don't have to process the first frame of the game for the full settings\n    if (payload.slpVersion && semver.gte(payload.slpVersion, \"1.6.0\")) {\n      this._completeSettings();\n    }\n  }\n\n  private _handlePostFrameUpdate(payload: PostFrameUpdateType): void {\n    if (this.settingsComplete) {\n      return;\n    }\n\n    // Finish calculating settings\n    if (payload.frame! <= Frames.FIRST) {\n      const playerIndex = payload.playerIndex!;\n      const playersByIndex = _.keyBy(this.settings!.players, \"playerIndex\");\n\n      switch (payload.internalCharacterId) {\n        case 0x7:\n          playersByIndex[playerIndex]!.characterId = 0x13; // Sheik\n          break;\n        case 0x13:\n          playersByIndex[playerIndex]!.characterId = 0x12; // Zelda\n          break;\n      }\n    }\n    if (payload.frame! > Frames.FIRST) {\n      this._completeSettings();\n    }\n  }\n\n  private _handleFrameUpdate(command: Command, payload: PreFrameUpdateType | PostFrameUpdateType): void {\n    payload = payload as PostFrameUpdateType;\n    const location = command === Command.PRE_FRAME_UPDATE ? \"pre\" : \"post\";\n    const field = payload.isFollower ? \"followers\" : \"players\";\n    const currentFrameNumber = payload.frame!;\n    this.latestFrameIndex = currentFrameNumber;\n    if (location === \"pre\" && !payload.isFollower) {\n      const currentFrame = this.frames[currentFrameNumber];\n      const wasRolledback = this.rollbackCounter.checkIfRollbackFrame(currentFrame, payload.playerIndex!);\n      if (wasRolledback) {\n        // frame is about to be overwritten\n        this.emit(SlpParserEvent.ROLLBACK_FRAME, currentFrame);\n      }\n    }\n    _.set(this.frames, [currentFrameNumber, field, payload.playerIndex!, location], payload);\n    _.set(this.frames, [currentFrameNumber, \"frame\"], currentFrameNumber);\n\n    // If file is from before frame bookending, add frame to stats computer here. Does a little\n    // more processing than necessary, but it works\n    const settings = this.getSettings();\n    if (settings && (!settings.slpVersion || semver.lte(settings.slpVersion, \"2.2.0\"))) {\n      this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n      // Finalize the previous frame since no bookending exists\n      this._finalizeFrames(currentFrameNumber - 1);\n    } else {\n      _.set(this.frames, [currentFrameNumber, \"isTransferComplete\"], false);\n    }\n  }\n\n  private _handleItemUpdate(payload: ItemUpdateType): void {\n    const currentFrameNumber = payload.frame!;\n    const items = this.frames[currentFrameNumber]?.items ?? [];\n    items.push(payload);\n\n    // Set items with newest\n    _.set(this.frames, [currentFrameNumber, \"items\"], items);\n  }\n\n  private _handleFrameBookend(payload: FrameBookendType): void {\n    const latestFinalizedFrame = payload.latestFinalizedFrame!;\n    const currentFrameNumber = payload.frame!;\n    _.set(this.frames, [currentFrameNumber, \"isTransferComplete\"], true);\n    // Fire off a normal frame event\n    this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n\n    // Finalize frames if necessary\n    const validLatestFrame = this.settings!.gameMode === GameMode.ONLINE;\n    if (validLatestFrame && latestFinalizedFrame >= Frames.FIRST) {\n      // Ensure valid latestFinalizedFrame\n      if (this.options.strict && latestFinalizedFrame < currentFrameNumber - MAX_ROLLBACK_FRAMES) {\n        throw new Error(`latestFinalizedFrame should be within ${MAX_ROLLBACK_FRAMES} frames of ${currentFrameNumber}`);\n      }\n      this._finalizeFrames(latestFinalizedFrame);\n    } else {\n      // Since we don't have a valid finalized frame, just finalize the frame based on MAX_ROLLBACK_FRAMES\n      this._finalizeFrames(currentFrameNumber - MAX_ROLLBACK_FRAMES);\n    }\n  }\n\n  /**\n   * Fires off the FINALIZED_FRAME event for frames up until a certain number\n   * @param num The frame to finalize until\n   */\n  private _finalizeFrames(num: number): void {\n    while (this.lastFinalizedFrame < num) {\n      const frameToFinalize = this.lastFinalizedFrame + 1;\n      const frame = this.getFrame(frameToFinalize)!;\n\n      // Check that we have all the pre and post frame data for all players if we're in strict mode\n      if (this.options.strict) {\n        for (const player of this.settings!.players) {\n          const playerFrameInfo = frame.players[player.playerIndex];\n          // Allow player frame info to be empty in non 1v1 games since\n          // players which have been defeated will have no frame info.\n          if (this.settings!.players.length > 2 && !playerFrameInfo) {\n            continue;\n          }\n\n          const { pre, post } = playerFrameInfo!;\n          if (!pre || !post) {\n            const preOrPost = pre ? \"pre\" : \"post\";\n            throw new Error(\n              `Could not finalize frame ${frameToFinalize} of ${num}: missing ${preOrPost}-frame update for player ${player.playerIndex}`,\n            );\n          }\n        }\n      }\n\n      // Our frame is complete so finalize the frame\n      this.emit(SlpParserEvent.FINALIZED_FRAME, frame);\n      this.lastFinalizedFrame = frameToFinalize;\n    }\n  }\n\n  private _completeSettings(): void {\n    if (!this.settingsComplete) {\n      this.settingsComplete = true;\n      this.emit(SlpParserEvent.SETTINGS, this.settings);\n    }\n  }\n}\n","import { forEach } from \"lodash\";\nimport type { Moment } from \"moment\";\nimport moment from \"moment\";\nimport { Writable } from \"stream\";\n\nimport type { GameStartType, PostFrameUpdateType } from \"../types\";\nimport { Command } from \"../types\";\nimport type { SlpCommandEventPayload } from \"./slpStream\";\nimport { SlpStream, SlpStreamEvent, SlpStreamMode } from \"./slpStream\";\n\nconst DEFAULT_NICKNAME = \"unknown\";\n\nexport interface SlpFileMetadata {\n  startTime: Moment;\n  lastFrame: number;\n  players: {\n    [playerIndex: number]: {\n      characterUsage: {\n        [internalCharacterId: number]: number;\n      };\n      names: {\n        netplay: string;\n        code: string;\n      };\n    };\n  };\n  consoleNickname?: string;\n}\n\n/**\n * SlpFile is a class that wraps a Writable stream. It handles the writing of the binary\n * header and footer, and also handles the overwriting of the raw data length.\n *\n * @class SlpFile\n * @extends {Writable}\n */\nexport class SlpFile extends Writable {\n  private filePath: string;\n  private metadata: SlpFileMetadata;\n  private slpStream: SlpStream;\n  private usesExternalStream = false;\n\n  /**\n   * Creates an instance of SlpFile.\n   * @param {string} filePath The file location to write to.\n   * @param {any} [opts] Options for writing.\n   * @memberof SlpFile\n   */\n  public constructor(filePath: string, slpStream?: SlpStream, opts?: any) {\n    super(opts);\n    this.filePath = filePath;\n    this.metadata = {\n      consoleNickname: DEFAULT_NICKNAME,\n      startTime: moment(),\n      lastFrame: -124,\n      players: {},\n    };\n    this.usesExternalStream = Boolean(slpStream);\n\n    // Create a new SlpStream if one wasn't already provided\n    // This SLP stream represents a single game not multiple, so use manual mode\n    this.slpStream = slpStream ? slpStream : new SlpStream({ mode: SlpStreamMode.MANUAL });\n\n    this._setupListeners();\n  }\n\n  /**\n   * Get the current file path being written to.\n   *\n   * @returns {string} The location of the current file path\n   * @memberof SlpFile\n   */\n  public path(): string {\n    return this.filePath;\n  }\n\n  /**\n   * Sets the metadata of the Slippi file, such as consoleNickname, lastFrame, and players.\n   * @param metadata The metadata to be written\n   */\n  public setMetadata(metadata: Partial<SlpFileMetadata>): void {\n    this.metadata = Object.assign({}, this.metadata, metadata);\n  }\n\n  public _write(chunk: Uint8Array, encoding: string, callback: (error?: Error | null) => void): void {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    }\n    // Parse the data manually if it's an internal stream\n    if (!this.usesExternalStream) {\n      this.slpStream.write(chunk);\n    }\n\n    // Keep track of the bytes we've written\n    callback();\n  }\n\n  /**\n   * Here we define what to do on each command. We need to populate the metadata field\n   * so we keep track of the latest frame, as well as the number of frames each character has\n   * been used.\n   *\n   * @param data The parsed data from a SlpStream\n   */\n  private _onCommand(data: SlpCommandEventPayload): void {\n    const { command, payload } = data;\n    switch (command) {\n      case Command.GAME_START:\n        const { players } = payload as GameStartType;\n        forEach(players, (player, i) => {\n          if (player.type === 3) {\n            return;\n          }\n\n          this.metadata.players[i] = {\n            characterUsage: {},\n            names: {\n              netplay: player.displayName,\n              code: player.connectCode,\n            },\n          };\n        });\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // Here we need to update some metadata fields\n        const { frame, playerIndex, isFollower, internalCharacterId } = payload as PostFrameUpdateType;\n        if (isFollower) {\n          // No need to do this for follower\n          break;\n        }\n\n        // Update frame index\n        this.metadata.lastFrame = frame!;\n\n        // Update character usage\n        const prevPlayer = this.metadata.players[playerIndex!];\n        const characterUsage = prevPlayer!.characterUsage;\n        const curCharFrames = characterUsage[internalCharacterId!] || 0;\n        const player = {\n          ...prevPlayer,\n          characterUsage: {\n            ...characterUsage,\n            [internalCharacterId!]: curCharFrames + 1,\n          },\n        };\n        (this.metadata.players as any)[playerIndex!] = player;\n        break;\n    }\n  }\n\n  private _setupListeners(): void {\n    const streamListener = (data: SlpCommandEventPayload): void => {\n      this._onCommand(data);\n    };\n    this.slpStream.on(SlpStreamEvent.COMMAND, streamListener);\n\n    this.on(\"finish\", () => {\n      // Update file with bytes written\n      // Unsubscribe from the stream\n      this.slpStream.removeListener(SlpStreamEvent.COMMAND, streamListener);\n      // Terminate the internal stream\n      if (!this.usesExternalStream) {\n        this.slpStream.end();\n      }\n    });\n  }\n\n  public _final(): void {\n    let footer = Buffer.concat([Buffer.from(\"U\"), Buffer.from([8]), Buffer.from(\"metadata{\")]);\n\n    // Write game start time\n    const startTimeStr = this.metadata.startTime.toISOString();\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([7]),\n      Buffer.from(\"startAtSU\"),\n      Buffer.from([startTimeStr.length]),\n      Buffer.from(startTimeStr),\n    ]);\n\n    // Write last frame index\n    // TODO: Get last frame\n    const lastFrame = this.metadata.lastFrame;\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([9]),\n      Buffer.from(\"lastFramel\"),\n      createInt32Buffer(lastFrame),\n    ]);\n\n    // write the Console Nickname\n    const consoleNick = this.metadata.consoleNickname || DEFAULT_NICKNAME;\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([11]),\n      Buffer.from(\"consoleNickSU\"),\n      Buffer.from([consoleNick.length]),\n      Buffer.from(consoleNick),\n    ]);\n\n    // Start writting player specific data\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([7]), Buffer.from(\"players{\")]);\n    const players = this.metadata.players;\n    forEach(players, (player, index) => {\n      // Start player obj with index being the player index\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([index.length]), Buffer.from(`${index}{`)]);\n\n      // Start characters key for this player\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([10]), Buffer.from(\"characters{\")]);\n\n      // Write character usage\n      forEach(player.characterUsage, (usage, internalId) => {\n        // Write this character\n        footer = Buffer.concat([\n          footer,\n          Buffer.from(\"U\"),\n          Buffer.from([internalId.length]),\n          Buffer.from(`${internalId}l`),\n          createUInt32Buffer(usage),\n        ]);\n      });\n\n      // Close characters\n      footer = Buffer.concat([footer, Buffer.from(\"}\")]);\n\n      // Start names key for this player\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([5]), Buffer.from(\"names{\")]);\n\n      // Write display name\n      footer = Buffer.concat([\n        footer,\n        Buffer.from(\"U\"),\n        Buffer.from([7]),\n        Buffer.from(\"netplaySU\"),\n        Buffer.from([player.names.netplay.length]),\n        Buffer.from(`${player.names.netplay}`),\n      ]);\n\n      // Write connect code\n      footer = Buffer.concat([\n        footer,\n        Buffer.from(\"U\"),\n        Buffer.from([4]),\n        Buffer.from(\"codeSU\"),\n        Buffer.from([player.names.code.length]),\n        Buffer.from(`${player.names.code}`),\n      ]);\n\n      // Close names and player\n      footer = Buffer.concat([footer, Buffer.from(\"}}\")]);\n    });\n\n    // Close players\n    footer = Buffer.concat([footer, Buffer.from(\"}\")]);\n\n    // Write played on\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([8]),\n      Buffer.from(\"playedOnSU\"),\n      Buffer.from([7]),\n      Buffer.from(\"network\"),\n    ]);\n\n    // Close metadata and file\n    footer = Buffer.concat([footer, Buffer.from(\"}}\")]);\n  }\n}\n\nconst createInt32Buffer = (number: number): Buffer => {\n  const buf = Buffer.alloc(4);\n  buf.writeInt32BE(number, 0);\n  return buf;\n};\n\nconst createUInt32Buffer = (number: number): Buffer => {\n  const buf = Buffer.alloc(4);\n  buf.writeUInt32BE(number, 0);\n  return buf;\n};\n","import type { FrameEntryType, RollbackFramesType } from \"../types\";\n\nexport class RollbackCounter {\n  private rollbackFrames: RollbackFramesType = {};\n  private rollbackFrameCount = 0;\n  private rollbackPlayerIdx: number | null = null; // for keeping track of rollbacks by following a single player\n  private lastFrameWasRollback = false;\n  private currentRollbackLength = 0;\n  private rollbackLengths: number[] = [];\n\n  public checkIfRollbackFrame(currentFrame: FrameEntryType | undefined, playerIdx: number) {\n    if (this.rollbackPlayerIdx === null) {\n      // we only want to follow a single player to avoid double counting. So we use whoever is on first.\n      this.rollbackPlayerIdx = playerIdx;\n    } else if (this.rollbackPlayerIdx !== playerIdx) {\n      return;\n    }\n\n    if (currentFrame) {\n      // frame already exists for currentFrameNumber so we must be rolling back\n      if (this.rollbackFrames[currentFrame.frame]) {\n        this.rollbackFrames[currentFrame.frame]!.push(currentFrame);\n      } else {\n        this.rollbackFrames[currentFrame.frame] = [currentFrame];\n      }\n      this.rollbackFrameCount++;\n      this.currentRollbackLength++;\n      this.lastFrameWasRollback = true;\n    } else if (this.lastFrameWasRollback) {\n      this.rollbackLengths.push(this.currentRollbackLength);\n      this.currentRollbackLength = 0;\n      this.lastFrameWasRollback = false;\n    }\n    return this.lastFrameWasRollback;\n  }\n\n  public getFrames() {\n    return this.rollbackFrames;\n  }\n\n  public getCount() {\n    return this.rollbackFrameCount;\n  }\n\n  public getLengths() {\n    return this.rollbackLengths;\n  }\n}\n","import type { StatOptions, StatsType } from \"./stats\";\nimport {\n  ActionsComputer,\n  ComboComputer,\n  ConversionComputer,\n  InputComputer,\n  Stats,\n  StockComputer,\n  generateOverallStats,\n} from \"./stats\";\nimport type { FrameEntryType, FramesType, GameEndType, GameStartType, MetadataType, RollbackFrames } from \"./types\";\nimport { SlpParser, SlpParserEvent } from \"./utils/slpParser\";\nimport { getInput, getMetadata, iterateEvents, openSlpFile, SlpInputSource } from \"./reading\";\nimport type { SlpReadInput } from \"./reading/slpReader\";\n\n/**\n * Slippi Game class that wraps a file\n */\nexport class SlippiGame {\n  private input: SlpReadInput;\n  private metadata: MetadataType | null = null;\n  private finalStats: StatsType | null = null;\n  private parser: SlpParser;\n  private readPosition: number | null = null;\n  private actionsComputer: ActionsComputer = new ActionsComputer();\n  private conversionComputer: ConversionComputer = new ConversionComputer();\n  private comboComputer: ComboComputer = new ComboComputer();\n  private stockComputer: StockComputer = new StockComputer();\n  private inputComputer: InputComputer = new InputComputer();\n  protected statsComputer: Stats;\n\n  public constructor(input: string | ArrayBuffer | Uint8Array, opts?: StatOptions) {\n    this.input = getInput(input);\n\n    // Set up stats calculation\n    this.statsComputer = new Stats(opts);\n    this.statsComputer.register(\n      this.actionsComputer,\n      this.comboComputer,\n      this.conversionComputer,\n      this.inputComputer,\n      this.stockComputer,\n    );\n    this.parser = new SlpParser();\n    this.parser.on(SlpParserEvent.SETTINGS, (settings) => {\n      this.statsComputer.setup(settings);\n    });\n    // Use finalized frames for stats computation\n    this.parser.on(SlpParserEvent.FINALIZED_FRAME, (frame: FrameEntryType) => {\n      this.statsComputer.addFrame(frame);\n    });\n  }\n\n  private _process(settingsOnly = false): void {\n    if (this.parser.getGameEnd() !== null) {\n      return;\n    }\n    const slpfile = openSlpFile(this.input);\n    this.readPosition = iterateEvents(\n      slpfile,\n      (command, payload) => {\n        if (!payload) {\n          // If payload is falsy, keep iterating. The parser probably just doesn't know\n          // about this command yet\n          return false;\n        }\n        this.parser.handleCommand(command, payload);\n        return settingsOnly && this.parser.getSettings() !== null;\n      },\n      this.readPosition,\n    );\n  }\n\n  /**\n   * Gets the game settings, these are the settings that describe the starting state of\n   * the game such as characters, stage, etc.\n   */\n  public getSettings(): GameStartType | null {\n    // Settings is only complete after post-frame update\n    this._process(true);\n    return this.parser.getSettings();\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    this._process();\n    return this.parser.getLatestFrame();\n  }\n\n  public getGameEnd(): GameEndType | null {\n    this._process();\n    return this.parser.getGameEnd();\n  }\n\n  public getFrames(): FramesType {\n    this._process();\n    return this.parser.getFrames();\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    this._process();\n    return this.parser.getRollbackFrames();\n  }\n\n  public getStats(): StatsType | null {\n    if (this.finalStats) {\n      return this.finalStats;\n    }\n\n    this._process();\n\n    const settings = this.parser.getSettings();\n    if (settings === null) {\n      return null;\n    }\n\n    // Finish processing if we're not up to date\n    this.statsComputer.process();\n    const inputs = this.inputComputer.fetch();\n    const stocks = this.stockComputer.fetch();\n    const conversions = this.conversionComputer.fetch();\n    const playableFrameCount = this.parser.getPlayableFrameCount();\n    const overall = generateOverallStats({ settings, inputs, conversions, playableFrameCount });\n\n    const stats = {\n      gameComplete: this.parser.getGameEnd() !== null,\n      lastFrame: this.parser.getLatestFrameNumber(),\n      stocks,\n      last_combo: this.comboComputer.fetch(),\n      actionCounts: this.actionsComputer.fetch(),\n      settings,\n      inputs,\n      overall,\n    };\n\n    if (this.parser.getGameEnd() !== null) {\n      // If the game is complete, store a cached version of stats because it should not\n      // change anymore. Ideally the statsCompuer.process and fetch functions would simply do no\n      // work in this case instead but currently the conversions fetch function,\n      // generateOverallStats, and maybe more are doing work on every call.\n      this.finalStats = stats;\n    }\n\n    return stats;\n  }\n\n  public getMetadata(): MetadataType | null {\n    if (this.metadata) {\n      return this.metadata;\n    }\n    this.metadata = getMetadata(this.input);\n    return this.metadata;\n  }\n\n  public getFilePath(): string | null {\n    if (this.input.source !== SlpInputSource.FILE) {\n      return null;\n    }\n\n    return this.input.filePath ?? null;\n  }\n}\n","import { SlpInputSource } from \"../reading/slpReader\";\nexport * from \"./metadata\";\nexport * from \"./slpReader\";\n\nexport const getInput = (input: string | ArrayBuffer | Uint8Array) => {\n  if (typeof input === \"string\")\n    return {\n      source: SlpInputSource.FILE,\n      filePath: input,\n    };\n  if (input instanceof ArrayBuffer)\n    return {\n      source: SlpInputSource.BUFFER,\n      buffer: new Uint8Array(input),\n    };\n  if (input instanceof Uint8Array)\n    return {\n      source: SlpInputSource.BUFFER,\n      buffer: input,\n    };\n  throw new Error(\"Cannot create SlippiGame with input of that type\");\n};\n","import { decode } from \"@shelacek/ubjson\";\nimport { getRef, readRef, getLenRef } from \"./browserReading\";\nimport type { MetadataType } from \"../types\";\nimport type { SlpRefType, SlpReadInput } from \"./browserReading\";\n\n// This function gets the position where the raw data starts\nfunction getRawDataPosition(ref: SlpRefType): number {\n  const buffer = readRef(ref, 1, 0);\n\n  if (buffer[0] !== \"{\".charCodeAt(0)) {\n    return 0; // return error?\n  }\n\n  return 15;\n}\n\nfunction getRawDataLength(ref: SlpRefType, position: number): number {\n  const fileSize = getLenRef(ref);\n  if (position === 0) {\n    return fileSize;\n  }\n\n  const buffer = readRef(ref, 4, position - 4);\n\n  const rawDataLen = (buffer[0]! << 24) | (buffer[1]! << 16) | (buffer[2]! << 8) | buffer[3]!;\n  if (rawDataLen > 0) {\n    // If this method manages to read a number, it's probably trustworthy\n    return rawDataLen;\n  }\n\n  // If the above does not return a valid data length, return a file size\n  // based on file length. This enables some support for severed files\n  return fileSize - position;\n}\n\nexport function getMetadata(input: SlpReadInput): MetadataType | null {\n  const ref = getRef(input);\n  const rawDataPosition = getRawDataPosition(ref);\n  const rawDataLength = getRawDataLength(ref, rawDataPosition);\n  const metadataPosition = rawDataPosition + rawDataLength + 10; // remove metadata string\n  const metadataLength = getLenRef(ref) - metadataPosition - 1;\n\n  if (metadataLength <= 0) {\n    // This will happen on a severed incomplete file\n    return null;\n  }\n  const buffer = readRef(ref, metadataLength, metadataPosition);\n\n  try {\n    const metadata = decode(buffer);\n    return metadata;\n  } catch (ex) {\n    return null;\n  }\n}\n"],"names":["VALID_STAGE_IDs","reader","FileReaderSync","processGame","file","result","readAsArrayBuffer","game","SlippiGame","Uint8Array","metadata","getMetadata","lastFrame","startAt","startsWith","Object","keys","players","length","names","netplay","code","invalidMetadata","stats","getStats","settings","stocks","inputs","is_teams","includes","stageId","gameMode","p0_deaths","filter","s","playerIndex","endFrame","p1_deaths","player_0_airborne","airborne","player_1_airborne","invalidStats","self","onmessage","data","postMessage","Character","Stage","UnknownCharacter","id","name","shortName","colors","externalCharacters","getCharacterInfo","externalCharacterId","characterColor","UnknownMove","moves","getMoveInfo","moveId","UnknownStage","stages","getStageInfo","State","Timers","PUNISH_RESET_FRAMES","RECOVERY_RESET_FRAMES","COMBO_STRING_RESET_FRAMES","getSinglesPlayerPermutationsFromSettings","opponentIndex","frame","prevFrame","stocksRemaining","isInControl","state","ground","squat","groundAttack","isGrab","isTeching","TECH_END","isDown","DOWN_END","isDamaged","DAMAGE_FALL","isGrabbed","CAPTURE_END","isCommandGrabbed","BARREL_WAIT","isDead","DYING_END","percent","ComboEvent","Command","GameMode","Frames","JoystickRegion","dashDanceAnimations","ActionsComputer","constructor","this","playerPermutations","Array","Map","playerCounts","setup","forEach","indices","set","wavedashCount","wavelandCount","airDodgeCount","dashDanceCount","spotDodgeCount","ledgegrabCount","rollCount","lCancelCount","success","fail","grabCount","throwCount","up","forward","back","down","groundTechCount","away","in","neutral","wallTechCount","animations","processFrame","get","playerFrame","post","opponentFrame","incrementCount","field","condition","current","currentAnimation","actionStateId","push","last3Frames","slice","prevAnimation","newAnimation","isEqual","didRoll","previousAnimation","isCurrentlyRolling","isRolling","wasPreviouslyRolling","didSpotDodge","isCurrentlyDodging","isSpotDodging","wasPreviouslyDodging","didAirDodge","isAirDodging","didGrabLedge","isCurrentlyGrabbingLedge","isGrabbingLedge","wasPreviouslyGrabbingLedge","didGrabSucceed","GRAB","animation","didGrabFail","opponentDir","facingOpponent","positionX","facingDirection","MISSED_WALL_TECH","AERIAL_ATTACK_END","lCancelStatus","counts","isSpecialLanding","last","isAcceptablePrevious","isAboveMin","isBelowMax","recentFrames","recentAnimations","keyBy","size","fetch","from","values","map","val","ROLL_FORWARD","SPOT_DODGE","AIR_DODGE","CLIFF_CATCH","ComboComputer","args","super","last_combo","didKill","lastHitBy","startFrame","startPercent","currentPercent","endPercent","combo","move","resetCounter","lastHitAnimation","event","allFrames","frames","currentFrameNumber","prevFrameNumber","prevPlayerFrame","prevOpponentFrame","oppActionStateId","opntIsDamaged","opntIsGrabbed","opntIsCommandGrabbed","opntDamageTaken","calcDamageTaken","actionStateCounter","comboStarted","_prevOpponentFrame$pe","lastAttackLanded","hitCount","damage","COMBO_EXTEND","COMBO_START","opntIsTeching","opntIsDowned","opntDidLoseStock","didLoseStock","opntIsDying","_opponentFrame$percen2","shouldTerminate","_prevOpponentFrame$pe2","COMBO_END","emit","EventEmitter","ConversionComputer","conversions","lastEndFrameByOppIdx","conversion","terminated","openingType","opntInControl","_populateConversionTypes","conversionsToHandle","groupedConversions","groupBy","orderBy","isTrade","lastMove","oppEndFrame","InputComputer","inputCount","joystickInputCount","cstickInputCount","buttonInputCount","triggerInputCount","pre","invertedPreviousButtons","physicalButtons","currentButtons","pressing_start","isAirborne","newInputsPressed","x","count","bits","prevAnalogRegion","getJoystickRegion","joystickX","joystickY","currentAnalogRegion","DZ","prevCstickRegion","cStickX","cStickY","currentCstickRegion","physicalLTrigger","physicalRTrigger","y","region","NE","SE","SW","NW","N","E","S","W","generateOverallStats","playableFrameCount","inputsByPlayer","originalConversions","conversionsByPlayer","conv","_conv$moves$","conversionsByPlayerByOpening","mapValues","gameMinutes","player","playerInputs","inputCounts","buttons","triggers","cstick","joystick","total","conversionCount","opponentIndices","opp","isTeams","teamId","totalDamage","killCount","inputsPerMinute","getRatio","openingsPerKill","damagePerOpening","neutralWinRatio","getOpeningRatio","ratio","type","openings","opponentOpenings","flatten","defaultOptions","processOnTheFly","Stats","options","lastProcessedFrame","allComputers","assign","process","v","comp","register","computer","i","isCompletedFrame","addFrame","SlpInputSource","StockComputer","stock","_prevPlayerFrame$perc","deathAnimation","_playerFrame$percent","toHalfwidth","str","ret","_","char","convertChar","charCode","charCodeAt","String","fromCharCode","getRef","input","source","BUFFER","buffer","Error","readRef","ref","position","getLenRef","SlpStreamMode","decodeBuf","buf","convert","to","split","shift","command","payload","sliced_buffer","byteOffset","byteLength","view","DataView","slpVersion","readUint8","readBool","isPAL","readUint16","cfOffset","dashback","readUint32","cfOption","nametagStart","nametagBuf","nameTagString","nametag","displayNameStart","displayNameBuf","displayNameString","displayName","connectCodeStart","connectCodeBuf","connectCodeString","connectCode","offset","port","characterId","startStocks","controllerFix","scene","readInt32","isFollower","seed","readFloat","positionY","trigger","selfInducedSpeeds","airX","attackX","attackY","groundX","internalCharacterId","shieldSize","currentComboCount","miscActionState","lastGroundId","jumpsRemaining","hurtboxCollisionState","typeId","velocityX","velocityY","damageTaken","expirationTimer","spawnId","missileType","turnipFace","chargeShotLaunched","chargePower","owner","readInt8","latestFinalizedFrame","gameEndMethod","lrasInitiatorIndex","canReadFromView","getFloat32","getInt32","getInt8","getUint32","getUint16","getUint8","SlpStreamEvent","defaultSettings","suppressErrors","mode","AUTO","SlpParserEvent","SlpStream","slpOptions","opts","gameEnded","payloadSizes","previousBuffer","Buffer","payloadSize","restart","_write","newData","encoding","callback","concat","dataView","index","toString","_this$payloadSizes$ge","MANUAL","payloadPtr","payloadDataView","payloadLen","_processCommand","err","_writeCommand","entirePayload","payloadBuf","bufToWrite","RAW","processReceiveCommands","COMMAND","_this$payloadSizes$ge2","parsedPayload","parseMessage","Writable","commandByte","createInt32Buffer","number","alloc","writeInt32BE","createUInt32Buffer","writeUInt32BE","RollbackCounter","rollbackFrames","rollbackFrameCount","rollbackPlayerIdx","lastFrameWasRollback","currentRollbackLength","rollbackLengths","checkIfRollbackFrame","currentFrame","playerIdx","getFrames","getCount","getLengths","SETTINGS","defaultSlpParserOptions","strict","SlpParser","rollbackCounter","gameEnd","latestFrameIndex","settingsComplete","lastFinalizedFrame","handleCommand","_handleGameStart","_handlePostFrameUpdate","_handleFrameUpdate","_handleItemUpdate","_handleFrameBookend","_handleGameEnd","reset","getLatestFrameNumber","_this$latestFrameInde","getPlayableFrameCount","Math","max","FIRST_PLAYABLE","getLatestFrame","frameIndex","default","getSettings","getGameEnd","getRollbackFrames","lengths","getFrame","num","_finalizeFrames","semver","gte","_completeSettings","playersByIndex","location","lte","items","_this$frames$currentF","frameToFinalize","playerFrameInfo","finalStats","parser","readPosition","actionsComputer","conversionComputer","comboComputer","stockComputer","inputComputer","statsComputer","FILE","filePath","ArrayBuffer","on","_process","settingsOnly","slpfile","full_data","raw_data_position","rawDataPosition","rawDataLength","file_size","length_info","raw_data_len","messageSizes","message_metadata","payloadLength","message_sizes_buffer","slpFile","getShouldStop","startPos","stopReadingAt","message_size","overall","gameComplete","actionCounts","fileSize","rawDataLen","metadataPosition","metadataLength","decode","ex","getFilePath","_this$input$filePath"],"sourceRoot":""}